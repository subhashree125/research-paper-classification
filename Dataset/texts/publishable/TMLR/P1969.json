{
  "Abstract": "In this paper, we introduce LInK, a novel framework that integrates contrastive learningof performance and design space with optimization techniques for solving complex inverseproblems in engineering design with discrete and continuous variables. We focus on thepath synthesis problem for planar linkage mechanisms. By leveraging a multimodal andtransformation-invariant contrastive learning framework, LInK learns a joint representa-tion that captures complex physics and design representations of mechanisms, enablingrapid retrieval from a vast dataset of over 10 million mechanisms. This approach improvesprecision through the warm start of a hierarchical unconstrained nonlinear optimizationalgorithm, combining the robustness of traditional optimization with the speed and adapt-ability of modern deep learning methods. Our results on an existing benchmark demon-strate that LInK outperforms existing methods with 28 times less error compared to astate-of-the-art approach while taking 20 times less time on an existing benchmark. More-over, we introduce a significantly more challenging benchmark, named LINK-ABC, whichinvolves synthesizing linkages that trace the trajectories of English capital alphabetsaninverse design benchmark task that existing methods struggle with due to large nonlinear-ities and tiny feasible space. Our results demonstrate that LInK not only advances thefield of mechanism design but also broadens the applicability of contrastive learning and",
  "Introduction": "Linkage mechanisms play a pivotal role in mechanical engineering, serving as fundamental componentsin applications ranging from the automation of manufacturing processes to the development of roboticsystems. These mechanisms are crucial for translating input motionsoften rotationalinto desired outputtrajectories or paths, thereby enabling the execution of complex tasks through relatively simple inputs. Thedesign of linkage mechanisms relies heavily on kinematics the study of motion without considering the forcesinvolved and kinematic synthesis, the design process of mechanisms to achieve specific motions. Despite the reliance on the established practices of kinematics and kinematic synthesis, designing complexkinematic systems remains a challenge Lipson (2008). The design process often requires trial and error,specialized expertise, or heuristic approaches to find effective solutions.The complexity arises becausekinematic synthesis requires defining both the discrete components of a mechanism and their connections,as well as determining their continuous spatial locations, making it a mixed combinatorial and continuousproblem. This paper focuses on the inverse design of planar linkage mechanisms, where the design involves determininghow many joints a mechanism has, what type of joints they are (either fixed or revolute joints, and how thesejoints are connected to one another using rigid linkages. Further, the initial position of the joints in spacemust be determined. At each of these levels, mechanisms can be infeasible, and the majority of randomlysampled mechanisms tend to be invalid Heyrani Nobari et al. (2022). By examining the continuous valuesof initial positions, the nonlinear and discontinuous nature of the problem becomes apparent. For instance, illustrates a mechanism that writes the letter B, where all design variables are held constant exceptfor one joint (highlighted in red), which is moved in the x and y directions to demonstrate the feasible regionsfor these variables. The red-shaded area indicates where the mechanism fails to function. The three greypatches of feasibility for just one joint demonstrate the problems nonlinearity and discontinuity, featuringmultiple feasible regions. Furthermore, adjusting one joint alters the shape and number of feasible regionsfor all others. This discussion has focused solely on the continuous variables of joint positioning, yet thecombinatorial challenge of defining the mechanisms structure also plays a critical role. Not surprisingly,kinematic synthesis is sometimes regarded more as an art than a science due to its complexities 10. (2018). In this paper, we introduce a contrastive learning and optimization framework to address such inverse designchallenges, exemplifying broader issues in kinematic synthesis and engineering design that involve integrat-ing continuous and discrete variables within functional and engineering constraints. Our approach not onlyaddresses existing difficulties in kinematic design but also leverages deep learning to drive advancements inmechanical systems (Regenwetter et al., 2022). A significant challenge in applying deep learning to engi-neering is the accurate capture of physics-based performance, achieving precision in meeting requirements,effective representation of design and performance spaces, and the mitigation of data scarcity. To demonstrate the effectiveness of our proposed framework, we focus on a specific type of kinematic syn-thesis, called, the path synthesis problem.This problem involves designing the aforementioned linkagemechanisms such that they can trace a desired curve with one circular motion of a single actuator. Planarlinkage mechanisms use revolute and prismatic pairs to produce rotating, oscillating, or reciprocating mo-tions which can combine into complex motions that trace desired curves. These mechanisms are commonlyfound in everyday machinery, such as in the moving parts of printing presses, auto engines, and roboticscomponents, making their design critical to a wide range of applications. Most research on the inverse design of planar linkage mechanisms has applied deep learning to a limited prob-lem of only generating a specific set of mechanism types (typically, four-bar and six-bar mechanisms) (Cabreraet al., 2002; Varedi-Koulaei & Rezagholizadeh, 2020; Ebrahimi & Payvandy, 2015; 10., 2010; Khan et al.,2015b; McGarva, 1994; Chu & Sun, 2010a; Deshpande & Purwar, 2019a; Vasiliu & Yannou, 2001; Deshpande& Purwar, 2019b; 2020; Khan et al., 2015a). In other cases, deep learning frameworks such as deep rein-forcement learning, are applied to one task (a single target curve) at a time, only to find a single solution",
  "Published in Transactions on Machine Learning Research (10/2024)": "The concept of a shared cross-modal embedding space is highly analogous to the retrieval problem discussedbefore.This is because these models map data from different modalities into the same space based onsimilarity, which makes these embedding spaces ripe for retrieval problems. As it turns out, this has beenexplored in many works of research surrounding cross-modal retrieval. In an approach very similar to whatwe do here Izacard et al. (2022) uses this concept of contrastive embedding spaces for retrieval for the task ofdocument retrieval. These kinds of approaches have also been explored for cross-modal retrieval tasks, suchas temporal moment retrieval from videos based on text Zhang et al. (2021) or text-based molecular retrievalfor molecule design Liu et al. (2023), which demonstrates the effectiveness of cross-modal embedding spacesbuilt using contrastive learning for retrieval tasks. In our approach, we employ contrastive learning-enabledcross-modal spaces for mechanism retrieval based on kinematic objectives.",
  "ActuatorFree JointFixed Joint": ": This figure illustrates the LInK algorithms workflow. LInK first precomputes joint embeddingsfor mechanisms and curves, allowing it to retrieve numerous candidate mechanisms for any new target curvewithin seconds. With these high-quality initial candidates, a rapid BFGS optimization process efficientlyconverges to path synthesis solutions. These solutions significantly outperform existing methods in bothspeed and performance.",
  "Background and Related Works": "This section outlines relevant literature and contextualizes the research presented here. We begin with anoverview of the specific problem we aim to address and its inherent complexities. We then review traditionalcomputational methods and recent learning-based advancements applied to this problem. Finally, we discussprior works that have influenced our framework and the methodologies it incorporates.",
  ": This figure demonstrates the path synthesis problem which involves mixed combinatorial andcontinuous values. This figure also shows how mechanisms are represented as graphs": "Inverse Kinematics:Inverse kinematics is a computational technique primarily used in robotics, com-puter graphics, and biomechanics to determine the positions and angles of a mechanisms joints, such asin a robotic arm. This method specifically targets positioning the end effector, the terminal componentof the mechanism, at a desired location or along a predetermined trajectory. While standard applicationsinvolve adjusting joint angles within an existing configuration, inverse kinematic synthesis involves designingnew mechanisms to achieve specified motion objectives. The process is challenging due to its nonlinear andcombinatorial nature, which often leads to multiple viable solutions for a given target. This complexityunderscores the importance of inverse kinematics as a field that requires precise, controlled movements andpositioning. Planar Linkage Mechanisms:In our study of inverse kinematics, we focus on planar linkage mechanisms,which consist of rigid interconnected links joined by joints that move within a two-dimensional plane (see). These joints include revolute joints, which allow free rotation while keeping the linkage endpointsfixed, and fixed joints, which restrict the linkage end to a stationary position in 2D space. The mechanismsunder study have a single degree of freedom, controlled by a rotary actuator connected to a fixed joint. Thisactuators movement dictates the entire mechanisms configuration, determining the positions of all otherjoints and linkages based on its rotation.",
  "(1)": "Where M is the graph describing the mechanism, and start and end describe the range of motion for theactuator. F(M) is the path traced by the mechanism M, and Ptarget is the target path. DOF(M) is thedegrees of freedom for mechanism M, which has to be always 1 (to be exactly defined by the motion of thesingle actuator), and Singularity(M, start, end) is a function that determines if there are any singularitiesin a given mechanism M for the actuator range of motion from start to end.",
  "Moved Joint For Feasibility Analysis": ": This figure shows results from LInK on the larger alphabet test set. As can be seen, the pathsproduced by the generated mechanisms do not capture the alphabet shapes as well as we see in the other testsets. This shows that despite LInK performing well even on this test, this test set presents a more challengingbenchmark for path synthesis and can serve as a good benchmark for future methods. The ordered distancevalue for each curve is displayed above the curves for each alphabet path.",
  "Computational Design of Planar Linkage Mechanisms": "This section outlines significant research efforts aimed at solving inverse kinematics problems similar tothe one discussed in this paper. The literature on path synthesis methods falls into three main categories:numerical atlas-based, optimization-based, and deep learning-based approaches. Detailed discussions areprovided in Appendix A. Numerical Atlas-Based Approaches: These involve creating a database of mechanisms and their paths,which serves as a \"numerical atlas\" to find the best match for a target path. However, comparing targets tolarge databases can be computationally expensive, so these databases are often limited in size or to specificmechanism types, like four-bar or six-bar mechanisms McGarva (1994); Chu & Sun (2010b); Sun et al.(2015). Optimization-Based Approaches: These predominately involve modified versions of common conven-tional algorithms. Methods include genetic algorithms Lipson (2008); Khan et al. (2015b), Fourier descriptor-based optimization Ullah & Kota (1997); Wu et al. (2011), and Mixed-Integer Conic/Nonlinear Program-ming (MICP, MINLP) Pan et al. (2023). The approaches often refine existing solutions Bcher et al. (2015);Thomaszewski et al. (2014) or are limited to specific problems Lipson (2008); Baskar & Plecnik (2021).Despite their generalizability, the effectiveness of these methods is limited by their computational intensityand they often struggle (as our results show) to work for large mechanisms with many joints and targetpoints due to the highly constrained nature of the problem. Deep Learning-Based Approaches: These aim to accelerate and enhance path synthesis by integratingtraditional methods into data-driven frameworks. The techniques involve using generative models such asVariational Autoencoders (VAEs)Kingma & Welling (2014), clustering-based searchesDeshpande & Purwar(2019a;b; 2020), and Reinforcement Learning (RL) Fogelson et al. (2023). While promising, these methodseither require retraining (RL-based methods) for new targets or can be limited by dataset size and mechanismtype Deshpande & Purwar (2021); Vasiliu & Yannou (2001). In this paper, we propose a hybrid method that combines the speed of deep learning with the precision ofoptimization, aiming to surpass current state-of-the-art methods in both inference time and performance.",
  "Contrastive Learning and Retrieval": "Retrieval, in the context of machine learning, refers to the process of finding and returning relevant informa-tion from a dataset in response to a query. This can involve matching query features with itemss featuresin the dataset to identify the best matches based on similarity metrics. While most deep learning retrievalresearch has focused on vision applications like Bontent-Based Image Retrieval (CIBR) Dubey (2022); Chenet al. (2023), our work shifts attention to cross-modal retrieval, particularly retrieving graphs of mechanismsbased on their 2D kinematic paths. See Appendix B for more details. Most cross-modal works involve retrieving images based on multimodal information, such as text and otherimages. Early works like the correspondence autoencoder (Corr-AE) Feng et al. (2014) train autoencodersfor text and images to create embeddings close to each other. The Deep Visual-Semantic Hashing (DVSH)model Cao et al. (2016) and similar methods like Textual-Visual Deep Binaries (TVDB) Shen et al. (2017) cre-ate joint embedding spaces for text-based retrieval. Adversarial learning approaches, such as Self-Supervised",
  "i=1 logexp(sim(fi, gi)/)Nj=1 exp(sim(fi, gj)/),(2)": "where sim(fi, gi) measures the cosine similarity between feature embeddings fi and gi, and is the temper-ature parameter and N is the number of samples (typically batch size during training). This generalizabilitymakes CLIP suitable for downstream tasks, such as multimodal retrieval applications used in our methodol-ogy. Shared cross-modal embedding spaces have been shown to be effective for retrieval in such cases. Forinstance, Izacard et al. (2022) use contrastive embedding spaces for document retrieval. Similar approacheshave been explored for tasks like temporal moment retrieval from videos based on text Zhang et al. (2021)and text-based molecular retrieval for molecule design Liu et al. (2023). Contrastive learning has immensepotential for simultaneous modeling of design and performance spaces in engineering applications. For thecurrent problem, we create a contrastive learning-enabled cross-modal approach for retrieving mechanismsbased on their kinematic paths. More details are provided in subsequent sections.",
  "Methodology": "Our methodology is illustrated in , where we begin by retrieving potential matches from a datasetof 10 million mechanisms using a processed version of the input curve.These initial matches seed ouroptimization algorithm to refine the designs further. This section elaborates on our dual approach. Firstly,we train a contrastive learning model that bridges the physics underlying the mechanisms with their designrepresentations. This model is crucial for accurately identifying relevant mechanisms from the extensivedataset. Secondly, we detail our optimization algorithm, termed the Learning-accelerated Inverse Kinematics(LInK) algorithm, which builds upon the foundations laid by the contrastive retrieval model. This deepoptimization strategy enhances our capability to fine-tune and improve the designs based on the initialmatches identified by the retrieval process.",
  "Contrastive Learning Framework": "The first stage of our framework involves retrieving candidates from a massive dataset of linkage mechanismsfor a given target curve such that these candidates are best suited to be refined for the given input. We use theLINKS dataset proposed by Heyrani Nobari et al. (2022), which includes 100 million mechanisms with up to20 joints. Searching through such a massive dataset of this size by comparing curves and using conventionalmethods would be prohibitively expensive and time-consuming. Furthermore, most conventional metrics forsearching in such datasets are sensitive to rotations, scale, and other spatial transformations, which makesthem less useful. To improve this in our approach, we build a cross-modal contrastive embedding to quickly",
  "Mechanism Representation and Model": "We employ a subset of 10 million mechanisms from the LINKS dataset, which undergoes extensive pre-processing for normalization. To achieve scale invariance, we standardize the actuator arm length to 0.05units. We further normalize these mechanisms with respect to translation by centering the actuators at theorigin. Additionally, the mechanisms are aligned such that the actuator angle is set to zero, standardizingboth position and rotation. This normalization process is critical for the effective training of our contrastivelearning model. Furthermore, we meticulously process the dataset to eliminate any redundant joints, i.e., ajoint in the mechanism whose kinematic solution depends on the kinematics of all the other joints. In our approach, we model planar linkage mechanisms as undirected graphs M as we described above withslight variation. The only difference between the graphs we use for training and the prior described graphs isthat instead of only two joint types and initial positions, the node features of the graph are defined such thatthe first element row indicates if a node is fixed or moving (0 for moving joints and 1 for fixed joints), thesecond element indicates whether a joint is actuated and the third indicates if a given joint is the terminaljoint (i.e., the joint which should produce the target curve). The two other elements in each row are set to be",
  ",(3)": "where h(k)vis the output features for node/joint v at layer k, (k) is a learnable parameter as described inthe original work by Xu et al. (2019) and N(v) refers to the set of neighbors of node v. In our approach, weintroduce hop-attention, where at the end of computing all layers we compute a final feature for each nodethrough a graph attention (GAT) driven attention mechanism. To do this, we take the outputs of all layers,concatenate them for each node, and perform a single GAT convolution on the resulting graph:",
  ",(4)": "where h(GAT )vis the output of the graph attention convolution, and N is the number of attention heads inthe GAT. W n is the weights of each attention head linear transformation, while is a nonlinearity function,and h(k)vis the output of the k-th layer of the GIN model. We then use the output of the GAT as the query.We additionally use the outputs of each layer for a given node as the keys and values for a multi-headeddot-product attention. The attention is applied to obtain the final output of each layer. This means that atthe end of each node/joint in the graph/mechanism, we have the following:",
  "row matrix with h(GAT )vas its only row, andh(1)v h(2)v h(M)vis a matrix whose columns are assembled by": "the output of each layer of the GIN model. WQi , WKi , WVi refer to the weight of the linear transformationapplied at each attention head, and WO is the final linear transformation applied to the concatenatedattention head outputs resulting the final representation for each node/joint. The intuition behind this kindof architecture is evident in the solvers approach to computing the kinematics of the mechanisms. In thesolver we start with the known joints (i.e., 0-1 hops), then propagate the solution to a joint with two knownneighbors (1st hop) and repeat this process until all joints are solved (variable number of hops dependingon the mechanism skeleton). This means to correctly describe the kinematics of the mechanism each jointrequires a different number of hops (see ). Conventional graph convolution approaches simply do not",
  "Path Representation and Building Robust Invariances for Retrieval": "In our approach to mechanism retrieval, the goal is to identify mechanisms that accurately trace a targetcurve without concern for the curves scale, location, orientation, or the tracing velocity at different parts ofits motion. To achieve invariance to these factors, we employ specific preprocessing steps: Normalization for Scale and Translation: We utilize the first two steps of Procrustes analysisto normalize the scale and translation of the curves. This is done by centering the curve around itsmean and scaling it by its standard deviation:",
  "Building Rotation Invariance: To build invariance to rotation, we randomly rotate curves duringtraining": "Timing Invariance: We also need to build invariance to timing; i.e., the curves should be madeup of points that are equidistant from one another. To do this, we simply take any given curve andinterpolate points across the curves such that the points are equidistant. Being invariant to timingand making paths equidistant is important for path synthesis since in this kind of problem we donot care about the speed and timing of the motion rather just the shape (see Appendix C for moredetails). These steps, illustrated in , ensure that our contrastive learning model becomes robust to irrelevantgeometric transformations, focusing purely on the kinematic compatibility of the mechanisms with the targetcurves. Modeling Partial Target Curves:The curves in the LINKS dataset are always closed. However, thetarget curves that one can give to a model during testing may not always be closed. To effectively manageboth closed and open target curves in our contrastive cross-modal space, we implement a robust preprocessingstrategy that accommodates varying curve types. To do this, we randomly generate partial curves of theoriginal curves that a mechanism generates, normalize them exactly like we do for the full curves, and removetiming from them (see ). To gather these samples we randomly cut out a portions of the full closedcurves (between 10% to 100% of the curve) and process them as described before. We then introduce partialcurves as a separate modality into the overall contrastive learning space to ensure that open curves are alsohandled by the contrastive representation space. This is a unique contribution of this approach, as previousapproaches are limited to closed curves.The ability to handle partial curves is particularly challenging",
  "Consolidated Methodology": "In this section, we consolidate our methodology for training contrastive learning models and searching withinthe dataset. Our approach maps both mechanisms and curves into a unified representation space usingcontrastive learning. This mapping allows any introduced curve to be accurately paired with correspondingmechanism candidates based on its spatial representation.We employ a dual-model strategy for curvesalongside a specialized graph-based model for mechanisms. Specifically, the mechanism model utilizes thepreviously discussed GHop architecture. For curve processing, we utilize two ResNet50 models (He et al.,2015): one handling full curves and another for partial curves. The training leverages two distinct contrastivelosses, akin to the methodology used in the CLIP model (Radford et al., 2021):",
  "i=1 logexp(sim(gi, hi)/)Nj=1 exp(sim(gi, hj)/),(9)": "where sim(a, b) measures the cosine similarity between feature embeddings a and b extracted by any of themodels, and is the temperature parameter controlling the sharpness of the similarity scores. Importantly,the output of the mechanism model corresponds to fi, the output of the full curve model corresponds to gi,and the output for the partial curve model corresponds to hi, and N is the batch size. Notably, mechanismsare matched to their corresponding curves, and presumed dissimilar to others in the batch.While thisassumption holds given our diverse dataset, no specific measures have been implemented to handle potentialsimilarities between different mechanisms curves. Handling partial curves as a separate modality is crucialdue to their inherently noisier signal. Partial curves often contain common repeated patterns, such as arcs,which can lead to ambiguous associations if directly matched with mechanisms. By treating them separatelyand matching them with full curves, we leverage more detailed geometric information like curvature, allowingfor cleaner associations. This approach helps maintain the quality of the learned representations and preventsthe introduction of noise into the mechanism-curve associations. This setup is visualized in , detailingthe interaction between these components in our training framework. Once these models are trained, we have effectively established an approach to map mechanisms (designspace) and curves (performance space) into a unified space. This mapping enables rapid searches acrossour extensive dataset for any given curve by leveraging precomputed embeddings of all mechanisms. Forretrieval, we compute cosine similarities between the target curves embedding and those of the mechanisms,subsequently ranking them by similarity.",
  "Our framework for path synthesis includes three stages": "1. Initial Search: In the first stage, we perform a search on a 10 million sample subset of the LINKSdataset and find an initial pool of candidates based on the input curves using a contrastive learning-based search. 2. Batch Optimization: In the second stage, we perform a gradient-based optimization building offof the BFGS BROYDEN (1970); Fletcher (1970); Goldfarb (1970); Shanno (1970) method, which isapplied to all of the mechanisms retrieved in the first stage. To accelerate the process, we implementa batch BFGS optimization on GPU which performs the BFGS optimization on multiple mechanismssimultaneously. We describe this in more detail in this section. In this stage we only perform 10steps of optimization as optimizing the larger initial pool of candidates can be slow. 3. Final Refinement: After the batch optimization of the candidates, we then re-evaluate the mech-anisms and pick the top 10% amongst the candidates to move to the next stage. In the final stageof optimization, we further refine the smaller candidate pool using the BFGS optimization for 150steps, at which point the final design is output to the user. Each step of this framework is crafted to ensure a fast yet accurate synthesis of paths, optimizing performanceand computational efficiency. The following sections will delve deeper into the specifics of these optimizationtechniques.",
  "Forward Kinematics Solver Path": ": This figure illustrates the path the solver takes to solve the kinematics of a given mechanism,showing how the skeleton of a mechanism (combinatorial design variables) is involved in the mechanismsolution. Initially, the solver starts with the known joints (i.e., fixed and actuated joints highlighted red),and step by step the solver solves joints with two solved neighbors (Eqn. 10).In this example, joint 3 (thelast joint to be solved) is solved in three steps. The numbered joints indicate the order of solution. In our gradient-based optimization step, we focus only on optimizing the positions of joints in mechanisms asconnectivity parameters, which determine how joints are linked, are not differentiable. To efficiently conductthese optimizations, we employ a differentiable and vectorized solver that allows for rapid simulation anddifferentiation, enabling practical batch processing on GPUs.",
  "To vectorize and parallelize this process we have to perform two steps:": "Pre-Sorting Mechanisms: To facilitate vectorization and batch processing, we first establish aconsistent solution path for all mechanisms in the dataset. By presorting the joints of each mechanismin a solution-ready order, we eliminate the need to identify the solution path in real time duringsimulations. This sorting, conveniently, has already been handled by Heyrani Nobari et al. (2022)method. Resizing Mechanisms: The other necessary step that allows for the batch solution by a vectorizedGPU solver is that all of the mechanisms must have the same size (i.e., the same number of joints).To do this, we add unconnected fixed joints to all mechanisms that are smaller than the largestmechanism in the dataset such that the mechanisms in the dataset all have the same number of joints.This step ensures that multiple mechanisms can be processed simultaneously without discrepanciesin size. With the mechanisms appropriately sorted and resized, the next step is to implement the vectorized solverthat can efficiently handle batches of mechanisms.This solver operates on the principle of solving forany given joint based on the positions of two known adjacent joints at each timestep using the followingequation Bcher et al. (2015):",
  "||XTj XTk ||2 ||XTi XTj ||,(11)": "where X0i is the initial position of joint i.As can be seen, these equations are easily vectorizable formultiple mechanisms (essentially by turning the X vectors into tensors with an additional dimension of thesame size as the batch size) and multiple time steps. Furthermore, all of the above-mentioned equationsare differentiable (except the sign function which will not be differentiable at zero). This allows us to usebackpropagation to compute the gradients with respect to the initial positions X0 and run the simulationmuch faster in a vectorized fashion for a batch of mechanisms and for all timesteps simultaneously. Weimplement such a GPU-accelerated solver using Pytorch and use the automatic differentiation features ofPytorch to obtain the gradients of the solution with respect to the initial positions of the joints.",
  "yS2minxS1 x y2,(12)": "where S1 is the set of points in the target curve and S2 is the set of points in the curve traced by a mechanism.Chamfer distance is a well-established point cloud-based shape comparison metric and as we have seen thisplays a major role in our approach. Although Chamfer distance provides a great metric for comparing thegeneral shape of the curves, it lacks information about path connectivity or ordering. As such we also haveto look at some metric that encompasses this. For this purpose, we use the objective function proposed byPan et al. (2023) in their MICP optimization approach. This metric is defined as the ordered distance (OD):",
  "Xcouplero1(i) Xtargeti2(13)": "where N is the number of points sampled in both the target curve and mechanism traced curve. Xcoupleriis the i-th point on the curve traced by the mechanisms, and Xtargetiis the i-th point on the target curve.This while o1(i) is the i-th point in the optimal ordering to match the curves and O1 is the set of all possibleclockwise and counter-clockwise orderings of the curve traced by a mechanism. The constant 2 is kept forconsistency across different works to allow for meaningful comparison of results to prior works that use thismetric. Finally, in our gradient-based optimization, we have the following objective function:",
  "d = 1 dOD + 2 dCD.(14)": "In our approach, we assign weights to each metric in the optimization process, with 1 = 0.25 for Chamferdistance and 2 = 1.0 for ordered distance. Using Chamfer distance alone sometimes results in solutionsthat disregard the ordering of points, focusing merely on matching point clouds.Incorporating ordereddistance helps prevent this issue by maintaining the sequence integrity of points, leading to more accuratepath tracing. However, relying solely on ordered distance can yield suboptimal solutions and slow down theconvergence rate of the optimization process. Typically, a combination of both metrics tends to producerobust solutions.",
  "Batch BFGS Optimization on GPU": "The BFGS approach for gradient-based optimization has been established as a robust method for uncon-strained nonlinear gradient-based optimization. However, there are two important matters that we mustaddress before being able to apply this method to our problem. First, our problem is not unconstrained.This is because if the initial positions of the mechanism being optimized are moved to a position that leadsto the term in the inverse cosine seen in equation 11, becoming greater than 1 or less than -1, we will havea locking/infeasible mechanism. As such, instead of using a simple line search for the optimization steps inBFGS, we use a heuristic approach to prevent infeasible and locking configurations. We thus use the commonWolfe conditions (Wolfe, 1971) for inexact line search to find the step size in each iteration of optimization;however, on top of the Wolfe conditions, we also check that a given step size does not lead to infeasiblemechanisms by checking if the simulation has resulted in any NaN values. The traditional approach of performing BFGS optimization individually for each mechanism is inefficientand time-consuming, particularly when leveraging CPU computation. To address this and take advantageof GPU acceleration, we have developed a new batch BFGS scheme that vectorizes the BFGS Hessianupdates and line searches across multiple mechanisms simultaneously. This adjustment allows us to processall optimizations in parallel, significantly speeding up the refinement of candidates and the generation ofoptimal solutions. For the sake of brevity, further details on how this is done are omitted here; interestedreaders are referred to our publicly available code for the detailed implementation.",
  "Implementation Details of the Optimization Framework": "Our methodology begins by precomputing embeddings for 10 million mechanisms from the LINKS datasetusing our contrastive learning model tailored for mechanisms. For any provided target curve, we normalizeit as outlined earlier, including a smoothing step for hand-drawn or rough curves. This smoothing involvesa fast Fourier transform to retain only the first seven frequencies, which we use to reconstruct the curve andcompute the curves embedding. All further optimization processes use the original, unsmoothed curves.This step is only done for computing the embedding of the target curve; the other optimization steps usethe original input curves directly. Given the embedding for the target curve, we then measure the cosine distance between the target embed-ding and all of the precomputed embeddings of the mechanisms in our dataset and pick the top 500 mostsimilar (i.e., lowest cosine distance) mechanisms for the optimization. As mentioned earlier, we then perform10 steps of batch BFGS on all of the 500 mechanisms and the target curves. To do this, we normalize thetarget curve and the paths generated by the candidate mechanisms, then find the optimal orientation of thetarget for the curves the candidate mechanisms produce. We then perform a brute-force grid search with 200equally-spaced rotation angles (from 0 to 2), and identify the optimal rotation that minimizes the Chamferdistance. This rotation is identified for each mechanism in the candidate set. The target curve is rotatedto match the candidate paths as well as possible. Then we perform the BFGS with curves that have beenoriented properly. Once the initial 10 steps of BFGS are performed, we then pick the top 50 best-performingat this stage of optimization and perform an additional 150 steps of BFGS on them. We call this deepoptimization framework for path synthesis the Learning-accelerated Inverse Kinematics (LInK). We look atLInKs performance and efficiency in the following sections. Please note that the number of candidates and optimization steps at each stage are choices made empirically.We will demonstrate that these choices yield highly accurate solutions in rapid time compared to prior works.This approach strikes a balance between speed and accuracy. The optimization process can be made morecomputationally intensive if desired, potentially allowing for further improvements in the final solution.However, our current parameters have proven effective in achieving excellent results within reasonable timeconstraints.",
  "Manufacturability Considerations": "So far, we have only focused on the topics of kinematics and path synthesis, however, not all mechanismsthat can be kinematically solved can additionally be manufactured. In a mechanism, linkages move freelythrough space, and therefore are typically stacked in layers to avoid collision. Linkages, or multi-layer joints,that occupy the same space as other linkages must be avoided, which is often resolved by adding more layersto a mechanism, increasing its complexity and decreasing its feasibility. This issue can also be overcomewith exotic designs for joints that enable circumventing collisions, but that would be costly and difficult toachieve in practice. As such, we must establish if any given mechanism is manufacturable with conventionalparts. We can thus formulate an optimization problem to obtain the optimal configuration for a given linkagemechanism such that the total number of layers needed to manufacture a mechanism is minimized. Each linkage will have a z value, which we denote with zi for the i-th linkage in the set of linkages L. Eachjoint has an attachment to some number of linkages and collides with a set number of linkages as well. Foreach joint j in the set of all joints J, we denote the set of linkages attached to it as Aj, and the set of linkagescolliding with the joint as Cj for the j-th joint. Finally, each linkage is in collision with some other linkages.We denote the set of linkages colliding with the i-th linkage as Oi, which excludes self-collision. Finally, asubset of J denoted G J is the set of grounded joints. Our objective is to minimize the maximum of zi forall linkages. To obtain Oi, Aj and Cj, we simulate the mechanism and find the colliding geometries. Given",
  "(16)": "This optimization simulation will yield z values which will be integers ranging from 0 to a maximum of|L| 1, which would be equivalent to having one layer per linkage. It is also important to note that thecollisions for fixed joints are not considered. This is because each linkage can be grounded in space withoutthe need for a joint to pass through the mechanism. This formulation lends itself very well to mixed-integerlinear programming (MILP) algorithms. In this case, we use Gurobi to solve the problem and determine ifany given mechanism yields a feasible MILP problem; and if so, determine what the optimal configurationfor that given mechanism is. Note that since all of the operations in our approach happen in batches, atevery step, we obtain many candidates, and as such we easily check the manufacturability of each mechanismfrom best to worst performing until the most manufacturable mechanism is found. This is an importantaspect of the process that prior methods have ignored; few check for manufacturability at all. In our workfrom here on to the end, all mechanisms we identify as solutions are manufacturable; the above MILP isfeasible for the mechanisms that are shown and discussed in this paper. For more details on this aspect ofthe work and visualizations of linkage assemblies please see Appendix D.",
  "Results and Discussion": "In this section, we share the results of a few different sets of experiments using our model and compare theresults of our approach to the state of the art. Before discussing the details of the experiment, it is importantto first discuss our experimental settings and the evaluation metrics we use to evaluate both our method andother approaches.",
  "Evaluation Metrics and Experiment Details": "As we discussed before in path synthesis, the primary aim is to come up with mechanisms that allow for thetracing of a desired target path. As such, to measure the performance of any model for this task we need tolook at metrics that allow for comparing two given paths purely based on their shape/path. Here we tracktwo highly correlated metrics but, each provides slightly different insight. These metrics are the Chamfer",
  "distance and ordered distance as discussed in Equation 12 and Equation 13 respectively. We discussed thetrade-offs of each metric with regards to comparing paths in .2.1": "It is also important to note that in our tests we resample all target and traced curves (by the mechanisms)by interpolating the curves to 2000 equidistant points. This is necessary to remove timing bias in the curvestraced by mechanisms, since the motion of the mechanism is not at a constant velocity. Removing timingis needed since the objective of path synthesis is to trace a path without any prescribed kinematics such asspeed and acceleration. Now that the metrics, and how we measure them are established, we will conductsome tests to compare our method to prior works. Finally, we will introduce two new benchmarks for thisproblem to establish a concrete benchmark for future works.",
  ": This figure shows the 8 test curves used in prior works (Left), 24 random samples from the LINKStest subset (Middle), and the alphabet test curves (Right)": "We will first test our model on three sets of problems and report the results of our approach on each of thesetest cases. Currently, the existing literature lacks standardized test sets. As such, it is hard for us to compareour model against the state of the art, as these methods have limited code availability and replicating themcan be complicated. Despite this, a specific set of test curves have been proposed by Pan et al. (2023), whichhave been evaluated using multiple methods. However, this set is very small (i.e., only 8 curves), and is notwell suited for rigorous testing of path synthesis methods such as ours. However, we use this dataset, as itprovides an avenue for comparison to the state of the art. : This table presents the quantitative results of our model on the three different test sets we used toevaluate our model. For each test case, we run our model 5 times and report the best solution found withinthe 5 runs. The numbers following are the standard deviation across the samples in each test case. Notethat although we normalize the LINKS and alphabet test curves, we use the original scaling on the 8 testcurves, as they were measured in prior works at that scale.",
  "Path Traced By Generated MechanismTarget Path": ": This figure shows 20 random results from LInK on the larger LINKS test subset. We do notvisualize mechanisms and only visualize the curve traced by the mechanisms to save space. As it can beseen in almost all cases, the solution found is nearly identical to the target curve, which shows that when itcomes to in-distribution target curves, LInK performs exceptionally well. Each of the three cases discussed above are visualized in , which displays all of the curves in thealphabet and the test curves proposed by Pan et al. (2023), while showing a random subset of the datasettest curves. We run our model for all three test cases and display the results visually in figures 9 and 7 for thealphabet and 8 test curves respectively. Finally, we show a few random example solutions from the LINKStest set in . As it can be seen when it comes to the 8 test curves our model performs exceptionallywell and as we will see later when compared to the state of the art our approach significantly outperformsprior methods. Furthermore, we see that the models performance on the in-distribution test case is alsovery good, which should be expected as these samples are similar to the training curves. However, we cansee that the curves produced for the alphabet test case do not follow a similar trend. Although for someletters the model has performed well, for many of the complex curves the results are under-whelming and do",
  "not trace the curves as expected. This test set, therefore, serves as a great benchmark for future methodsas it presents a more demanding challenge": "Beyond the qualitative results discussed so far, we measure the performance of our model on each of the testsets and report both the ordered distance and Chamfer distance in . As can be seen, the qualitativeobservations are confirmed with both metrics, with the model performing well on the in-distribution testand the 8 test curves, while performing notably worse on the challenging alphabet curves (see the ordereddistance of the alphabet test).",
  "Comparison To State of Art Methods": "In their work, Pan et al. (2023) proposed 8 curves for which they used MICP to perform path synthesis andreported their results. Since then, the current state-of-the-art method in path synthesis using deep learning(i.e., GCP-HOLO Fogelson et al. (2023)), has evaluated their method on this set. As such, we will test ourmethod on this set of target paths as well, and compare our performance to the state of the art based onthese paths. In , we present the results of our approach for each of the 8 curves: both GCP-HOLO and MICPare used, and as we can see, LInK significantly outperforms these approaches by an order of magnitudedemonstrating more than a 94% improvement over the state of the art. One of the main explanations forthe shortcomings of the approaches mentioned in this study is that these approaches are limited to smallermechanisms, due to the high computational cost of dealing with increasingly larger mechanisms with thesemodels. Despite limiting their size, these models are still significantly slower than our proposed framework.We discuss the efficiency and inference speed in later sections. Regardless, we run LInK on limited-sizeddatasets to demonstrate that LInK outperforms the state of the art, even when limited to smaller mechanisms.To do this we run LInK with a limit of 7 to 20 joints for each curve and show these results in . For",
  "Inference Speed and Scalability": "We have so far only looked at the pure performance of the mentioned methods in terms of how well they canperform path synthesis. However, an important aspect of path synthesis algorithms is their limitations interms of inference speed and scalability to large, complex mechanisms. To test the scalability and inferencespeed of different methods, we investigate both the inference time and size of the mechanisms each methodcan produce. : This table shows the average inference time for each method. For SOTA methods we report therough inference time reported by the authors (they report a range, and we report the middle of that rangehere), as the code for the work by Pan et al. (2023) is not publicly available. For GCP-HOLO, we runboth of their variants on our hardware using an Intel i9-14900K and an RTX 4090 GPU, which providesbetter inference speed than the authors reported. We also run our model on the same hardware. In eachcase, 10 tests are run, and the average time is reported below. The percentages are reported based on theinference speed up compared to MINLP. We observe that, on average, LInK is 150 times faster than thefastest GCP-HOLO. At the bottom of the table, we also include the timing of manually searching the datasetof 10M samples for retrieval only using manual ordered distance calculation and using cosine search usingfor contrastive retrieval. The value of contrastive retrieval is clear with multiple orders of magnitude fasterretrieval compared to manual search.",
  "Manual Search of 10M Samples (GPU)20-10178Manual Search of 10M Samples (CPU)20-48421Contrastive Retrieval In 10M Samples (GPU)20-0.0259Contrastive Retrieval In 10M Samples (CPU)20-6.407": "presents the inference speed and maximum mechanism sizes that each method is capable of producingwithin that inference time. Furthermore, we show in this table the simulation fidelity, which determines thenumber of points sampled for each method. We can see that LInK is not only 99.95% faster than the MINLPmethod, but it is also more than 99% faster than the fastest method in the state of the art capable ofproducing mechanisms that go beyond 4-bar and 6-bar mechanisms, GCP-HOLO. Beyond this, we see thatLInK is capable of producing much more complex mechanisms with up to 20 joints and simulating with2000 timesteps during optimization. This is in contrast with the 11 joints and 20 timesteps that the bestcompeting method is working with while having 99% slower inference. We also look at the inference speedof retrieval using manual search (i.e., measuring ordered distance to all curves in the dataset manually andpicking the top candidates) and the contrastive retrieval approach we propose. We see clearly that manuallysearching the dataset would be computationally prohibitive and would require times closer to the slowestbaselines of MINLP and MICP, while contrastive retrieval takes under 0.1 seconds accelerating retrieval bymany orders of magnitude, while also allowing for retrieval based on partial curves which would be not beas simple as measuring ordered distance. These results demonstrate that frameworks like LInK can be verypowerful for speeding up these kinds of optimization-based methods by removing the majority of the burdenfrom the optimizer, enabling faster and more precise optimization.",
  "Conclusion and Future Work": "In this work, we introduced LInK, a novel framework that combines contrastive learning with optimizationtechniques for effectively solving complex engineering design problems, with a specific focus on the pathsynthesis problem for planar linkage mechanisms. By leveraging a vast dataset and employing a multimodal,transformation-invariant contrastive learning framework, LInK adeptly captures intricate physics and designrepresentations, enabling the rapid and precise retrieval and optimization of mechanisms. This approach notonly significantly expedites the search process, but also enhances precision through a hierarchical optimizationalgorithm.The results demonstrate the effectiveness of LInK through improvement in both speed andperformance by an order of magnitude. For future work, the adaptability and robustness of LInK opens new avenues for exploring its applicabilityacross a broader spectrum of engineering challenges, beyond linkage synthesis. Direct analogs exist in softrobotics and compliant mechanisms Sun et al. (2024), where kinematic synthesis of a similar nature isinvestigated in non-rigid body components. In these fields, particularly compliant mechanisms, there often",
  "Moritz Bcher, Stelian Coros, and Bernhard Thomaszewski.Linkedit: Interactive linkage editing usingsymbolic kinematics. ACM Trans. Graph., 34(4), jul 2015. ISSN 0730-0301. doi: 10.1145/2766985. URL": "Aravind Baskar and Mark Plecnik. Synthesis of Watt-Type Timed Curve Generators and Selection FromContinuous Cognate Spaces. Journal of Mechanisms and Robotics, 13(5):051003, 05 2021. ISSN 1942-4302.doi: 10.1115/1.4050197. URL C. G. BROYDEN.The Convergence of a Class of Double-rank Minimization Algorithms 1. GeneralConsiderations.IMA Journal of Applied Mathematics, 6(1):7690, 03 1970.ISSN 0272-4960.doi:10.1093/imamat/6.1.76. URL",
  "J.A. Cabrera, A. Simon, and M. Prado.Optimal synthesis of mechanisms with genetic algorithms.Mechanism and Machine Theory, 37(10):11651177, 2002.ISSN 0094-114X.doi:": "Yue Cao, Mingsheng Long, Jianmin Wang, Qiang Yang, and Philip S. Yu.Deep visual-semantic hash-ing for cross-modal retrieval.In Proceedings of the 22nd ACM SIGKDD International Conferenceon Knowledge Discovery and Data Mining, KDD 16, pp. 14451454, New York, NY, USA, 2016.Association for Computing Machinery.ISBN 9781450342322.doi:10.1145/2939672.2939812.URL Ting Chen, Simon Kornblith, Mohammad Norouzi, and Geoffrey Hinton. A simple framework for contrastivelearning of visual representations. In International conference on machine learning, pp. 15971607. PMLR,2020a. Ting Chen, Simon Kornblith, Kevin Swersky, Mohammad Norouzi, and Geoffrey E Hinton.Big self-supervised models are strong semi-supervised learners. Advances in neural information processing systems,33:2224322255, 2020b.",
  "Jinkui Chu and Jianwei Sun.Numerical atlas method for path generation of spherical four-bar mech-anism.Mechanism and Machine Theory, 45(6):867879, 2010b.ISSN 0094-114X.doi: URL": "Shrinath Deshpande and Anurag Purwar. A Machine Learning Approach to Kinematic Synthesis of Defect-Free Planar Four-Bar Linkages. Journal of Computing and Information Science in Engineering, 19(2), 022019a. ISSN 1530-9827. doi: 10.1115/1.4042325. URL 021004. Shrinath Deshpande and Anurag Purwar. Computational Creativity Via Assisted Variational Synthesis ofMechanisms Using Deep Generative Models. Journal of Mechanical Design, 141(12), 09 2019b. ISSN1050-0472. doi: 10.1115/1.4044396. URL 121402. Shrinath Deshpande and Anurag Purwar.An Image-Based Approach to Variational Path Synthesis ofLinkages. Journal of Computing and Information Science in Engineering, 21(2), 10 2020. ISSN 1530-9827. doi: 10.1115/1.4048422. URL 021005.",
  "Shrinath Deshpande and Anurag Purwar. An image-based approach to variational path synthesis of linkages.Journal of Computing and Information Science in Engineering, 21(2), 2021": "Shiv Ram Dubey. A decade survey of content based image retrieval using deep learning. IEEE Trans. Cir. andSys. for Video Technol., 32(5):26872704, may 2022. ISSN 1051-8215. doi: 10.1109/TCSVT.2021.3080920.URL Saeed Ebrahimi and Pedram Payvandy. Efficient constrained synthesis of path generating four-bar mech-anisms based on the heuristic optimization algorithms. Mechanism and Machine Theory, 85:189204,2015.ISSN 0094-114X.doi: Fangxiang Feng, Xiaojie Wang, and Ruifan Li. Cross-modal retrieval with correspondence autoencoder. InProceedings of the 22nd ACM International Conference on Multimedia, MM 14, pp. 716, New York, NY,USA, 2014. Association for Computing Machinery. ISBN 9781450330633. doi: 10.1145/2647868.2654902.URL Federico Ferrari and Ole Sigmund.Revisiting topology optimization with buckling constraints.Struc-tural and Multidisciplinary Optimization, 59(5):14011415, March 2019. ISSN 1615-1488. doi: 10.1007/s00158-019-02253-3. URL",
  "Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition,2015": "Amin Heyrani Nobari, Akash Srivastava, Dan Gutfreund, and Faez Ahmed. Links: A dataset of a hundredmillion planar linkage mechanisms for data-driven kinematic design. Volume 3A: 48th Design AutomationConference (DAC), Aug 2022. doi: 10.1115/detc2022-89798. R Devon Hjelm, Alex Fedorov, Samuel Lavoie-Marchildon, Karan Grewal, Phil Bachman, Adam Trischler,and Yoshua Bengio. Learning deep representations by mutual information estimation and maximization.In International Conference on Learning Representations, 2018. Gautier Izacard, Mathilde Caron, Lucas Hosseini, Sebastian Riedel, Piotr Bojanowski, Armand Joulin, andEdouard Grave. Unsupervised dense information retrieval with contrastive learning. Transactions on Ma-chine Learning Research, 2022. ISSN 2835-8856. URL Ashish Jaiswal, Ashwin Ramesh Babu, Mohammad Zaki Zadeh, Debapriya Banerjee, and Fillia Makedon.A survey on contrastive self-supervised learning. Technologies, 9(1), 2021. ISSN 2227-7080. doi: 10.3390/technologies9010002. URL",
  "Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan Wierstra, andMartin Riedmiller. Playing atari with deep reinforcement learning, 2013": "Zherong Pan, Min Liu, Xifeng Gao, and Dinesh Manocha. Joint search of optimal topology and trajectoryfor planar linkages. The International Journal of Robotics Research, 42(4-5):176195, 2023. doi: 10.1177/02783649211069156. URL Alec Radford, Jong Wook Kim, Chris Hallacy, Aditya Ramesh, Gabriel Goh, Sandhini Agarwal, GirishSastry, Amanda Askell, Pamela Mishkin, Jack Clark, Gretchen Krueger, and Ilya Sutskever. Learningtransferable visual models from natural language supervision, 2021.",
  "David F Shanno. Conditioning of quasi-newton methods for function minimization. Mathematics of compu-tation, 24(111):647656, 1970": "Yuming Shen, Li Liu, Ling Shao, and Jingkuan Song. Deep binaries: Encoding semantic-rich cues for efficienttextual-visual cross retrieval. In Proceedings of the IEEE international conference on computer vision, pp.40974106, 2017. Kihyuk Sohn, Honglak Lee, and Xinchen Yan. Learning structured output representation using deep condi-tional generative models. In C. Cortes, N. Lawrence, D. Lee, M. Sugiyama, and R. Garnett (eds.), Ad-vances in Neural Information Processing Systems, volume 28. Curran Associates, Inc., 2015. URL Jianwei Sun, He Lu, and Jinkui Chu.Variable step-size numerical atlas method for path generation ofspherical four-bar crank-slider mechanism. Inverse Problems in Science and Engineering, 23(2):256276,2015. doi: 10.1080/17415977.2014.890615. URL Zhihong Sun, Chengxin Zheng, Xiaoqing Sun, Xiusong Hou, and Yikun Yang. Dual multi-objective opti-mization design method for compliant guide mechanism. Structural and Multidisciplinary Optimization,67(5), May 2024. ISSN 1615-1488. doi: 10.1007/s00158-024-03793-z. URL Bernhard Thomaszewski, Stelian Coros, Damien Gauge, Vittorio Megaro, Eitan Grinspun, and MarkusGross. Computational design of linkage-based characters. ACM Trans. Graph., 33(4), jul 2014. ISSN 0730-0301.doi: 10.1145/2601097.2601143.URL Irfan Ullah and Sridhar Kota. Optimal Synthesis of Mechanisms for Path Generation Using Fourier Descrip-tors and Global Search Methods. Journal of Mechanical Design, 119(4):504510, 12 1997. ISSN 1050-0472.doi: 10.1115/1.2826396. URL",
  "Aaron van den Oord, Yazhe Li, and Oriol Vinyals.Representation learning with contrastive predictivecoding, 2019": "SM Varedi-Koulaei and H Rezagholizadeh. Synthesis of the four-bar linkage as path generation by choosingthe shape of the connecting rod. Proceedings of the Institution of Mechanical Engineers, Part C: Journalof Mechanical Engineering Science, 234(13):26432652, 2020.doi: 10.1177/0954406220908616.URL Adrian Vasiliu and Bernard Yannou. Dimensional synthesis of planar mechanisms using neural networks:Application to path generator linkages.Mechanism and Machine Theory, 36:299310, 02 2001.doi:10.1016/S0094-114X(00)00037-9. Bokun Wang, Yang Yang, Xing Xu, Alan Hanjalic, and Heng Tao Shen. Adversarial cross-modal retrieval. InProceedings of the 25th ACM International Conference on Multimedia, MM 17, pp. 154162, New York,NY, USA, 2017. Association for Computing Machinery. ISBN 9781450349062. doi: 10.1145/3123266.3123326. URL Chao Wang, Zhi Zhao, Ming Zhou, Ole Sigmund, and Xiaojia Shelly Zhang. A comprehensive review ofeducational articles on structural and multidisciplinary optimization. Structural and MultidisciplinaryOptimization, 64(5):28272880, October 2021. ISSN 1615-1488. doi: 10.1007/s00158-021-03050-7. URL Yunchao Wei, Yao Zhao, Canyi Lu, Shikui Wei, Luoqi Liu, Zhenfeng Zhu, and Shuicheng Yan. Cross-modalretrieval with cnn visual features: A new baseline. IEEE Transactions on Cybernetics, 47(2):449460,2017. doi: 10.1109/TCYB.2016.2519449.",
  "Philip Wolfe. Convergence conditions for ascent methods. ii: Some corrections. SIAM Review, 13(2):185188,1971. doi: 10.1137/1013035. URL": "Jun Wu, Q. J. Ge, Feng Gao, and W. Z. Guo. On the Extension of a Fourier Descriptor Based Method forPlanar Four-Bar Linkage Synthesis for Generation of Open and Closed Paths. Journal of Mechanisms andRobotics, 3(3), 07 2011. ISSN 1942-4302. doi: 10.1115/1.4004227. URL 031002. Yiling Wu, Shuhui Wang, and Qingming Huang.Online asymmetric similarity learning for cross-modalretrieval. In 2017 IEEE Conference on Computer Vision and Pattern Recognition (CVPR), pp. 39843993, 2017. doi: 10.1109/CVPR.2017.424.",
  "Keyulu Xu, Weihua Hu, Jure Leskovec, and Stefanie Jegelka. How powerful are graph neural networks?,2019": "Erkun Yang, Cheng Deng, Wei Liu, Xianglong Liu, Dacheng Tao, and Xinbo Gao. Pairwise relationshipguided deep hashing for cross-modal retrieval. Proceedings of the AAAI Conference on Artificial Intelli-gence, 31(1), Feb. 2017. doi: 10.1609/aaai.v31i1.10719. URL Hao Zhang, Aixin Sun, Wei Jing, Guoshun Nan, Liangli Zhen, Joey Tianyi Zhou, and Rick Siow MongGoh. Video corpus moment retrieval with contrastive learning. In Proceedings of the 44th InternationalACM SIGIR Conference on Research and Development in Information Retrieval, SIGIR 21, pp. 685695,New York, NY, USA, 2021. Association for Computing Machinery. ISBN 9781450380379. doi: 10.1145/3404835.3462874. URL",
  "As discussed prior most methods in kinematic synthesis fall into three primary categories: numerical atlas-based approaches, otimization-based approaches, and deep learning-based approaches": "Numerical Atlas:In numerical atlas approaches, a database of mechanisms is first created or gatheredand simulated to obtain the paths that each mechanism traces in the database. Then these mechanisms andtheir corresponding paths are used as a numerical atlas. Given a target path, one can look up all of themechanisms in a database to find the best matching candidate in the database McGarva (1994); Chu & Sun(2010b); Sun et al. (2015). It can be computationally expensive to compare a target to a large number ofmechanisms; therefore, in the majority of these approaches, the database is usually limited in size or limitedto a handful of mechanism types, such as a four-bar or a six-bar mechanism. Optimization-Based Kinematic Synthesis:A different kind of approach to solving this kind of problemis applying different optimization approaches. Some apply genetic algorithms to the problem Lipson (2008);Khan et al. (2015b), While others have developed Fourier descriptor-based optimization algorithms Ullah& Kota (1997); Wu et al. (2011). At the same time, many approaches focus on specific problems withoutgeneralizability or refining existing solutionsLipson (2008); Bcher et al. (2015).Most of the aforemen-tioned methods commonly work with existing solutions Bcher et al. (2015); Thomaszewski et al. (2014)or are limited to specific kinds of mechanisms or problems Lipson (2008); Baskar & Plecnik (2021). Mostpromising amongst the recent developments is the method proposed by Pan et al. (2023), which formulatesthe optimization problem discussed prior as a mixed-integer conic-programming (MICP) and mixed-integernonlinear programming (MINLP). However, these methods use a branch and bounds method to optimizethe problem, which limits their capacity in the number of joints and the number of points in their target",
  "B.1Learning Based Retrieval": "When it comes to deep learning-based approaches for retrieval the majority of research has been dedicatedto vision applications, specifically Content Based Image Retrieval (CIBR). Dubey (2022) and Chen et al.(2023) have conducted comprehensive surveys on the deep learning developments for different types andapplications of CIBR, which provide a more in-depth discussion on the topic for readers seeking a moredetailed review. Here we will focus on discussing some of the more directly related works of research onthe topic. In our work, we aim to retrieve mechanisms (represented as graphs) given target kinematics (2Dpaths), which makes the approach one that involves different modalities of data representation. As such herewe focus on cross-modal retrieval methods, discuss some of the ways that others have approached problemsof this nature, and refer readers to the aforementioned surveys for a review of other types of retrieval models. Cross-modal image retrieval refers to the task of retrieving images in a dataset based on information involvingmore than one modality. A prominent example of this is text and image-based retrieval, which comes upin text query-based image retrieval and image labeling based on text retrieval. One of the earliest workson the topic by Feng et al. (2014), called Correspondence AutoEncoder (Corr-AE) trains two autoencoderssimultaneously one for text and one for images, and attempts to build correspondence by encouraging theembeddings of the two autoencoders to be close to each other through an L2 loss function between the text and",
  "B.2Contrastive Learning and Contrastive Learning Based Retrieval": "As discussed before, most of the methods built for retrieval using deep learning were built to be specializedand included mechanisms specific to text and image datasets, which are not adaptable to general taskslike the one we perform here. Given this, and the fact that the inverse kinematic problem involves a verygeneral and context-free nature, the kinematics simulations are the only directly available information forany given mechanism. This exists in isolation, unsupervised, and self-supervised approaches are best suitedfor building a robust retrieval mechanism for kinematic synthesis. These requirements lend themselves ratherwell to contrastive learning. Contrastive learning at its core refers to unsupervised or self-supervised learning methods that aim to de-velop models that learn to distinguish between similar and dissimilar data points Jaiswal et al. (2021).These methods gained popularity as a result of the early seminal works in deep contrastive learning Hjelmet al. (2018); van den Oord et al. (2019); Chen et al. (2020a) that demonstrated the powerful capabilitiesof these approaches for both conventionally supervised deep learning problems (e.g. contrastive learningfeature extraction for classification and regression) and unsupervised representation learning. Among theseearly approaches, the work by Chen et al. (2020a;b), known as an effective framework for contrastive learn-ing (SimCLR) stands out as a rather generalizable and robust framework. Although SimCLR itself was builtand tested on a single modality of data, primarily images, similar approaches soon emerged in other worksof research that adapted similar techniques to contrastive learning on multiple modalities. Most notably thework by Radford et al. (2021), introduces the Contrastive Language-Image Pretraining (CLIP) model, whichcreates a cross-modal embedding space for text and images. However, unlike highly specialized text-imageretrieval models, the CLIP approach is rather generalizable to other cross-modal embedding spaces. Thisis evident in the loss function used by CLIP (Equation 2). This means that so long as trainable modelscan be implemented for data representations in each modality, the CLIP approach applies to the problem.Given this robustness and generalizability, we incorporate the CLIP loss in our approach for unsupervisedrepresentation learning in the inverse kinematics problem.",
  ": Different types of problems in inverse kinematics of planar linkage mechanisms. Note that theyellow arm is the actuator arm": "In these kinds of planar linkage mechanisms, the problem of inverse kinematic synthesis can have differenttypes of objectives, such as path synthesis, motion synthesis, and signal generation McCarthy & Soh (2010).The path synthesis problem can be described as the problem of designing linkage mechanisms that cangenerate a particular path that is described by a finite series of point coordinates. As such in this type ofproblem, the speed and timing of the motion of the mechanism are not considered as part of the objective.Motion generation on the other hand can be thought of as the generalized version of the path generationwhere aside from point coordinates, the orientation of an attached rigid body (such as a robot arm) andits timing and speed are also prescribed. Finally, the function generation problem refers to the problem ofgenerating a specific series of output crank angles (or slider positions) at given angles (or positions) at theactuator, essentially transforming the signal from the actuator (angle or position) to a different signal at theoutput crank (or slider). See for more details. LInK is created with a primary focus on the PathSynthesis problem, although with some tweaking the data could be adapted to be used for other types ofproblems such as Function Generation and Motion Synthesis (See ).",
  "DAdditional Visualizations": "Here we will visualize the mechanisms that trace the curves in the 8 test curves and alphabet tests. Foreach set of tests, we will visualize the kinematics of the entire mechanisms in 2D graph and path figures.We will also provide the optimal assembly of the mechanisms in 3D to visualize what the actual assembledmechanism would look like. Note that these solutions are the best perfoming solutions, as such they tend tohave more joints since higher complexity mechanisms tend to produce more precise solutions.",
  "D.1Eight Test Curves": "shows the mechanisms associated with the solutions found by LInK for each of the 8 test curves.This figure shows the mechanisms and their kinematic in 2D while Figures 14, 15 show the optimal assembliesfor each of these mechanisms to avoid collisions while using the fewest layers in the z-axis according to theoptimization scheme described in .4. : This figure shows the best results from LInK on the 8 test curves. As it is visible here, LInK hasmatched the target curves effectively without much challenge. Here, we visualize the mechanisms in 2D andalso plot the paths traced by all the joints in each mechanism.",
  "D.2Alphabet Test Curves": "The figures in this subsection are similar in nature to the figures in the prior subsection. Again it is importantto acknowledge that these are the best perfoming solutions. Compared to simpler curves such the letter Othe produced mechanism is more complex because the more complex mechanisms achieve an exceptionallyaccurate solution. Note that the LInK approach can be limited to any number of joint counts as mentionedin the main text."
}