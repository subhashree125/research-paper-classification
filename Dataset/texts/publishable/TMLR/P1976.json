{
  "Abstract": "We tackle the problem of sequential brick assembly with LEGO bricks to create combinatorial3D structures.This problem is challenging since this brick assembly task encompassesthe characteristics of combinatorial optimization problems. In particular, the number ofassemblable structures increases exponentially as the number of bricks used increases. Tosolve this problem, we propose a new method to predict the scores of the next brick positionby employing a U-shaped sparse 3D convolutional neural network.Along with the 3Dconvolutional network, a one-initialized brick-sized convolution filter is used to efficientlyvalidate assembly constraints between bricks without training itself. By the nature of thisone-initialized convolution filter, we can readily consider several different brick types bybenefiting from modern implementation of convolution operations.To generate a novelstructure, we devise a sampling strategy to determine the next brick position consideringthe satisfaction of assembly constraints. Moreover, our method is designed for either budget-free or budget-aware scenario where a budget may confine the number of bricks and theirtypes. We demonstrate that our method successfully generates a variety of brick structuresand outperforms existing methods with Bayesian optimization, deep graph generative model,and reinforcement learning.",
  "Introduction": "Most real-world 3D structures are constructed with smaller primitives. A broad range of studies have tackledinteresting assembly problems such as molecule generation (Ertl et al., 2017; Neil et al., 2018; You et al.,2018), building construction (Talton et al., 2011; Martinovic & Van Gool, 2013; Ritchie et al., 2015), andassembly generation (Sung et al., 2017; Lee et al., 2021; Jones et al., 2021b; Lee et al., 2022).1 In particular,if unit primitives are used to construct 3D structures we desire to assemble, this task becomes an instanceof combinatorial optimization problems, in which a search space increases exponentially as a search depthincreases. Formally, given n primitives with k possible connections between two primitives, the search spaceincreases by O(kn). In addition to the combinatorial property, the consideration of assembly constraintsbetween unit primitives makes the problem more challenging.",
  "BrECS (Ours)MultipleSLNo target conditioning for a generation taskConvolutionIncomplete target volume for a completion taskoperations": "The problem of sequential assembly with LEGO bricks inherits the aforementioned properties, in that adecision-making process sequentially determines where a brick is placed. Supposing that we are given manybricks to assemble, there are a large number of assemblable combinations. Moreover, the decision-makingprocess must consider complex assembly constraints, i.e., the disallowance of overlap, no isolated bricks, andLEGO-specific connections. Compared to generic 3D generation methods (Wu et al., 2016; Gadelha et al.,2018; Achlioptas et al., 2018), our brick assembly task can generate 3D structures in an open space andprovide brick-wise instructions to build the structures. Several attempts have been employed to solve sequential brick assembly by utilizing Bayesian optimiza-tion (Kim et al., 2020), deep graph generative models (Thompson et al., 2020), and reinforcement learn-ing (Chung et al., 2021), as summarized in .Those methods end with the consideration of theassembly with only 24 LEGO bricks they might be capable of assembling other brick types withoutsignificant modification, though. Moreover, the previous literature has several respective limitations. TheBayesian optimization-based method (Kim et al., 2020) requires heavy computations due to its iterativeoptimization process. Another method (Thompson et al., 2020) has been proposed using masks to filter outinvalid actions along with their graph generative model, but the use of masks degrades assembly performance.To predict a valid action, the recent work (Chung et al., 2021) utilizes an auxiliary neural network that oftenfails to predict legitimate moves perfectly. More importantly, these methods share a common limitation:they inevitably become slower in validating assembly constraints as the number of bricks increases, due tothe exponentially increasing search spaces. To tackle the limitations mentioned above, we devise a novel brick assembly method with a U-shaped neuralnetwork utilizing a one-initialized brick-sized convolution filter to validate complex constraints efficiently.Notably, our one-initialized convolution filter enables our method to validate the constraints in a parallelizableand scalable manner without training itself, where several different brick types are considered. Using thesampling procedure proposed in this work, our method can create diverse sequences of LEGO bricks togenerate high-fidelity brick structures.Furthermore, we consider two scenarios, budget-free and budget-aware assembly pipelines where a budget limits the number of bricks and their types. Henceforth, we referto our method as sequential Brick assembly with Efficient Constraint Satisfaction (BrECS).",
  "Related Work": "3D Shape Generation.Point cloud and voxel representations are widely used in 3D shape genera-tion. Various methods with variational auto-encoders (Gadelha et al., 2018), generative adversarial net-works (Achlioptas et al., 2018), and normalizing flows (Yang et al., 2019) have been proposed to generatepoint clouds. On the other hand, voxel-based 3D shape generation has been studied. Wu et al. (2016) pro-pose a generative adversarial network to generate voxel occupancy. Choy et al. (2019) generate 3D shapes onvoxel grids with a fully convolutional network that includes efficient sparse convolution. Zhang et al. (2021)propose a method to generate high-quality voxel-based shapes applying 3D convolutional networks. Sequential Part Assembly.Similar to the sequential brick assembly problem, sequential part assemblyshares common difficulties with a combinatorial optimization problem.Chen et al. (2022) introduce apairwise shape assembly model but the model is limited to the pairwise assembly. Jones et al. (2021a);Willis et al. (2022) suggest CAD parts assembly model which assembles parts by exploiting semantic CADshape information and extracting features from it. Ghasemipour et al. (2022) aim to assemble multi-partobjects and tackle the problem with large-scale reinforcement learning and graph-based model architecture.Sung et al. (2017) assemble incomplete 3D parts with a part retrieval network and a position predictionnetwork. Hu et al. (2020) propose a model that sequentially moves a piled box into another container withdifferent shapes. They tackle the problem by representing previous boxes into graphs and reinforcementlearning with rewards considering physical constraints in a new container. Sequential Brick Assembly.Unlike generic 3D shape generation methods and part assembly methods,the sequential brick assembly approaches (Kim et al., 2020; Thompson et al., 2020; Chung et al., 2021)consider the assembly constraints that are introduced by attachable connections between two adjacent bricksand the disallowance of brick overlap, as shown in . As discussed in the work (Kim et al., 2020),these constraints encourage us to accentuate the nature of combinatorial optimization since a huge number ofassemblable combinations exist in the presence of complex constraints. However, it is not trivial to validatesuch constraints. As in , to overcome these difficulties, Kim et al. (2020) sample a subset of availablenext brick positions, Thompson et al. (2020) mask out invalid positions by validating all possible positions,and Chung et al. (2021) train an auxiliary network for validating positions. Brick Assembly in Physical World.Luo et al. (2015) show a method to find LEGO brick structures inconsideration of physical constraints. Ngele et al. (2020) propose a two-layer planning approach for multi-robot LEGO brick assembly. Li et al. (2021) suggest a bi-level robot framework to learn to design and buildbridges with blocks under the assumption that a blueprint is not accessible. Liu et al. (2023) develop a robotsystem to learn assembly and disassembly processes from human demonstration. Liu et al. (2024) provideanalysis on the physical stability of 3D structures with LEGO bricks examining force balancing equations.",
  "In this section we introduce the brick assembly problem tackled in this paper": "Formulation.Similar to the previous work (Chung et al., 2021), a new brick is connected to one or(possibly) more bricks of previously assembled bricks. It implies that the position of the next brick can bedetermined as a relative displacement from a certain brick directly connected to the next brick. we denotethis indicator brick as a pivot brick. After choosing the pivot brick, we finally determine a relative position toassemble from the pivot brick. Ultimately, the goal of this work is to predict a sequence of brick placementsfrom scratch or from an incomplete brick structure. In particular, in an inference stage, our model does notutilize any guidance for final brick structures. Objectives.Our sequential brick assembly aims at assembling LEGO bricks to 3D structures that resemblethe 3D structures used in the training of our proposed model. As described above, we do not provide anyguidance for final target structures in an inference stage and construct 3D structures from scratch or fromincomplete brick structures. Note that a scenario of building 3D structures from scratch is called a generation",
  "task and a scenario of building 3D structures from incomplete brick structures is called a completion task.Moreover, we consider a budget-free or budget-aware scenario in sequential brick assembly": "Constraints.Inspired by the standard LEGO bricks, we take into account three constraints in the brickassembly problem: (i) bricks should not overlap with each other (no-overlap); (ii) all bricks of the currentstructure should be connected to each other so that the current structure is represented as one connectedstructure (no-isolation); (iii) a new brick must be directly attached to the upper or lower position of otherbricks (vertical-assemble). Budgets.Suppose that a brick budget is predefined, where a budget indicates the number of assemblablebricks for each brick type. For example, if we are given four 24 and two 22 LEGO bricks as a brickbudget, we can only assemble those six bricks in total. On the other hand, if we are given an infinite budget,our framework can choose any brick type without restriction.",
  "Proposed Approach": "Here, we explain four steps of our method BrECS, which are illustrated in . To sum up, we generatea brick structure under assembly constraints by repeating the following steps: (i) score computation of nextbrick positions, (ii) exclusion of invalid positions, (iii) sampling of a pivot brick, and (iv) determination ofa relative brick position. Note that a neural network for computing the scores of next brick positions is anonly learnable component in our framework.",
  "Efficient Constraint Satisfaction": "We propose a novel method to tackle the challenge of satisfying the following constraints: no-overlap, whichis validated by using convolution operations; no-isolation and vertical-assemble, which are satisfied byfollowing the brick assembly formulation with pivot bricks and relative brick positions. Borrowing the conceptof constraint satisfaction (Tsang, 1993), which is the problem of finding solutions that satisfy a predefinedset of constraints, our method is designed to establish an approach to efficient constraint satisfaction forsequential brick assembly. Predicting Next Brick Positions.Given a voxel representation of a structure at step t, which is denotedas Bt {0, 1}aaa where a is the size of 3D space, we first feed the voxel representation Bt into a U-shaped",
  "(c)": ": Illustration of how one-initialized brick-size convolution filters work where a red brick is a pivotbrick and a green brick has been assembled to the red brick. The grid shows the validity Vt+1 of eachbrick position on the red brick for a brick type 22. The pixels in a red rectangle indicate attachable brickpositions on the red brick. The green pixels indicate that overlap with the green brick will occur if a new brickis attached to the corresponding position. Therefore, (a) and (c) violate no-overlap and no-isolation,respectively, and (b) satisfies the assembly constraints.",
  "Bt = U-Net(Bt),(1)": "in order to capture global and local contexts effectively and retain the same dimensionality. Due to itspyramidal feature extraction structure, the U-Net extracts robust features understanding multi-dimensionalcontexts. In particular, we validate that the U-Net effectively extracts important contexts and thus improvesoverall performance compared to other neural networks; see for a thorough study on neural archi-tectures. Moreover, we expect that our neural network produces a likely complete or potentially next-step3D structure, which is represented by a probability of voxel occupancy. Note that the network parametersin this U-Net are the only learnable component in our framework BrECS. In this section, we assume thatwe are given the pretrained U-Net.",
  "At+1 = Bt K,(2)": "where is a convolution operation. We match the size of At+1 to the size of Bt by applying zero padding. Inparticular, the size of the convolution filter is the same as the brick size we assemble wb db where wb and dbare the width and depth of the brick, respectively, so that we can determine the scores over all the possiblepositions of the next brick by aggregating the corresponding voxels. For example, if we use 24 bricks, thesize of the convolution filter is 2 4 1. Moreover, K is always initialized as a tensor filled with 1 withoutupdating its values in a training stage to aggregate wbdb voxels equally with a single convolution operation.",
  "Published in Transactions on Machine Learning Research (09/2024)": "G. Yang, X. Huang, Z. Hao, M.-Y. Liu, S. Belongie, and B. Hariharan. PointFlow: 3D point cloud generationwith continuous normalizing flows. In Proceedings of the International Conference on Computer Vision(ICCV), 2019. J. You, B. Liu, Z. Ying, V. Pande, and J. Leskovec. Graph convolutional policy network for goal-directedmolecular graph generation. In Advances in Neural Information Processing Systems (NeurIPS), 2018.",
  "Vt = Bt K.(3)": "The filter K is identical to the filter used in computing the score for the next brick positions. After applyingthe convolution filter across Bt, all attachable brick positions are determined if the value of the position ofinterest is zero, which means that no overlap exists within the brick positions. As visualized in ,the validity of each position in terms of overlap and the number of attachable positions with respect to thebrick of interest are readily determined by applying the convolution filter of the corresponding brick type. Using these two branches for computing At+1 and Vt, which are shown in Equations (2) and (3), we candefine validated scores for next brick positions Ct+1. Each entry of Ct+1 is equal to its score for next brickpositions filtering out invalid brick positions. Formally, we describe Ct+1 of assembling a wb db brick on apivot brick:",
  "Ct+1 = 1[Vt]ijk=0 i,j,k[a](Vt) At+1= 1[BtK]ijk=0 i,j,k[a](Bt K) (U-Net(Bt) K),(4)": "where 1[Vt]ijk=0 i,j,k[a] is an indicator function, K Rwbdb1 is the one-initialized convolution filter,and is a convolution operation. Since the calculation of the masked score tensor Ct+1 uses convolutionoperations, we efficiently compute it with modern GPU devices. Specifically, while the validity check of(64, 64, 64) voxels without parallelization takes 4.7 seconds, the identical validity check with our methodtakes only 0.0021 seconds; ours yields approximately 2,300 times faster inference on the validity check. Selecting Pivot Bricks by Sampling.To place a single brick, we need to choose one of previouslyassembled bricks, i.e., a pivot brick, to attach a new brick. The motivation of our method to select a pivotbrick is that a pivot brick with higher sum of attachable brick scores should be preferable to one withlower sum of attachable brick scores, rather than choosing a pivot brick that is connected to a positionwith the highest score of Ct+1.Since a neural network tends to memorize training samples and theirassembly sequences, choosing a position with the highest score fails to create a novel structure. Instead of adeterministic approach based on Ct+1, we alter a method to select a pivot brick into a sampling method. Tocompare the number of attachable positions, we define a pivot score Tijk of the pivot of (i, j, k) to aggregatescores of attachable positions:",
  "(l,m,n)pivots Tlmn.(7)": "Our sequential procedure for pivot brick predictions is inspired by Monte-Carlo tree search (MCTS) (Coulom,2006). MCTS evaluates possible actions by expanding a search tree with Monte-Carlo simulations and back-ups. Similar to this, our method also evaluates pivot brick candidates by aggregating their attachable brickscores, so that pivot with more attachable bricks will more likely be selected. Our method utilizes the U-shaped sparse 3D convolutional neural network to predict possible brick positions, which is analogous to apolicy network of the MCTS method (Silver et al., 2016), which employs a neural network to predict priordistributions for search tree expansion.",
  "z {1, 1}.(10)": "By considering the conditions described in Equations (8), (9), and (10), we choose the relative brick position(x, y, z) with the highest score of Ct+1. A brick must be attached to the pivot brick as we add scores ofevery attachable brick in Equation (5). In this step, we do not employ a sampling method due to its poorempirical results. As a result, Algorithm 1 presents the overall procedure to assemble a single brick. By repeating Algorithm 1,we can assemble a number of bricks where either budget-free or budget-aware scenario is assumed.",
  "Training Procedure of the Score Function": "Similar to research on language modeling (Mikolov et al., 2010; Sutskever et al., 2014) and reinforcementlearning (Sutton & Barto, 2018), our model also predicts a next brick position sequentially. To train such aprediction model, a pair of ground-truth state transition is required as a training sample. However, final voxeloccupancy is only available as ground-truth information. It implies that we cannot access intermediate statesexplicitly. To resolve this issue, we generate an assembly sequence [B0, B1, . . . , BT 1] from the ground-truthvoxel occupancy following the procedure described in this section. Eventually, we can utilize this generatedsequence to train a model in an autoregressive manner. In addition, generated sequences are unique anddiverse, since the stochasticity is injected from the sampling strategy previously introduced. Since there exist numerous possible sequences to assemble bricks to a certain 3D structure, a single-steplook-ahead with a pair of contiguous states, i.e., (Bt, Bt+1), is not enough to model practical assemblyscenarios. In addition, the training becomes unstable even though the training pairs slightly change. Toaddress these issues, we train our sequential model to predict a k-step look-ahead state using pairs of statesat step t and step t + k, i.e., ( Bt, Bt+k). From now, we call this technique sequence skipping. We employ a voxel-wise binary cross-entropy to train our model. By restricting the voxel prediction usinga sigmoid function and minimizing the voxel-wise binary cross-entropy, our model learns to predict validvoxel-wise probabilities of the Bernoulli distribution. To sum up, we train our sequential prediction modelas follows:",
  "Inference for Sequential Brick Assembly": "In an inference stage, we determine the next brick positions by following our aforementioned procedure,given B0. We provide a different form of B0 depending on a task, i.e., completion and generation, andsequentially generate Bt until a terminal step T. For a completion task that is designed to assemble bricksfrom a incomplete brick structure, we use an intermediate state, i.e., incomplete brick structure, as B0. Fora generation task that is designed to assemble bricks from scratch, we sample an initial brick position froma discrete uniform distribution, i.e., (x, y, z) U({2, 2}3). Then, we assemble bricks on a zero-centeredvoxel grid of size (64, 64, 64) and use the voxel occupancy of the initial brick position sampled as B0.",
  "Budget-Aware Sequential Brick Assembly": "Suppose that we are given k brick types. Shape of i-th brick type is different to the other brick type shapes,where the volume of i-th brick type is vi. For the sake of brevity, we define that the volume of the largestbrick type is v1 and the volume of the smallest brick type is vk. More concretely, vk vk1 v1. Abudget of brick types is represented as c = [c1, . . . , ck] and c1 = n is the total budget of bricks we canassemble, which implies that we have ci bricks for i-th brick type for i [k]. Then, a probability of the nextbrick placement at over brick types is post-processed by the following:",
  "Experimental Results": "We demonstrate that our model generates diverse structures with high fidelity satisfying assembly constraintsin the experiments on the completion and generation of brick structures with distinct brick types. Moreover,more elaborate studies are conducted in order to validate BrECS. Dataset.To generate ground-truth assembly sequences and the training pairs based on the ground-truthsequences, we use the ModelNet40 dataset (Wu et al., 2015). In particular, the categories of airplane, table,and chair are used for assembly experiments. 3D meshes in the dataset are converted into (64, 64, 64)-sizedvoxel grids, and then they are scaled down to 1/4 of the original size to reduce the number of required bricks.",
  "m,(13)": "where mvalid is the number of brick structures that satisfy assembly constraints and m is the number of brickstructures assembled. In addition, we utilize a class probability of a target class, which is the softmax outputof the target class, in experiments on the generation of brick structures. The probability of the target classis measured using a pretrained classifier with the ModelNet40 dataset. We generate 100 samples and reportaveraged metrics over 100 samples for all experiments. Baseline Methods.We compare the assembly performance of our method against a sequential assemblymethod with Bayesian optimization (Kim et al., 2020), denoted as BayesOpt, Brick-by-Brick (Chung et al.,2021), denoted as BBB, and the deep generative model of LEGO graphs (Thompson et al., 2020), denotedas DGMLG, in Tables 2 and 3. BayesOpt optimizes brick positions to maximize IoU between assembledshapes and target shapes. For the method by Kim et al. (2020), we provide exact target structures whichbelong to a particular category. BBB learns to assemble bricks given multi-view images of target structures.Following its formulation, we also provide three images (top, left, and front) of target structures in a testdataset. DGMLG generates a structure by utilizing the graph representation of brick structures and a deepgraph generative model. Note that our approach does not provide any guidance (image or target shape) toproduce a new structure. It is noteworthy that such different formulation is inevitable due to their respectiveassumptions. Importantly, we would claim that our method requires weaker guidance than other methods.",
  "Completion of Brick Structures": "We test our method on a completion task for sequential brick assembly where unseen partial structures aregiven. To establish the completion task for brick assembly problems, we first assemble LEGO bricks usinga brute-force approach to filling voxel occupancy in a test dataset with LEGO bricks. Then, we remove afraction of bricks assembled without losing connectivity between bricks and provide it as an initial state B0.Each model is trained with a training dataset and then complete brick structures from the initial states. Wecompare the completion performance by measuring IoU between ground-truth voxel occupancy and completebrick structure. In addition, we report valid assembly ratio and inference time. As shown in , our method outperforms the other three baseline methods in terms of IoU. The resultsshow that our method creates high-fidelity brick structures compared to other methods, despite exhaustive",
  "airplanetablechairaverageairplanetablechairaverage": "BayesOpt*0.0390.0430.0690.050100.0100.0100.0100.0Brick-by-Brick*0.4300.0420.0320.1686.03.02.03.7DGMLG0.2280.0230.0270.0930.00.00.00.0BrECS (24)0.4150.2500.4040.356100.0100.0100.0100.0BrECS (24 + 22)0.4470.2290.4190.365100.0100.0100.0100.0 constraint satisfaction. Moreover, our method performs the best in validity ratio alongside BayesOpt, butours is also the best in inference time. We additionally test our model with distinct brick types by appending22 bricks after assembling 24 brick type first. The performance of our method is further improved byusing two brick types since different brick types can fill brick positions more densely and express the fineaspect of structures in consequence.",
  "Generation of Brick Structures": "As our method is a generative model, our brick assembly model can generate a brick structure that belongsto a particular category. To compare the quality of generated structures semantically, we train a classifierover voxel grids with a small number of 3D convolution layers using the ModelNet40 dataset; the detailedarchitecture of the classifier is presented in Section F. Given a pretrained classifier over voxel grids, wemeasure the class probability of generated brick structures for a target class.To feed the voxel grid ofgenerated structure into the classifier, we match the voxel grid size of generated structure with the grid sizeof the training dataset for the classifier. Quantitative results are presented in Tables 3 and 4. Our method achieves the best scores in terms of classprobabilities and coverage. The results indicate that our method generates diverse and high-quality brickstructures compared to the other methods. We also emphasize that the semantic generation quality canbe improved using additional 22 brick types. Brick structures with distinct brick types are generated byassembling 24 bricks first and then 22 LEGO bricks. This performance gain is led by the additionalimprovement on structure refinement that cannot be filled with a single brick type; see Figures 3 and 4.",
  "Budget-Aware Generation": "We further conduct experiments on budget-aware scenarios. In the budget-aware experiments, we measuregeneration performance on various scenarios and analyze how our framework helps to generate 3D structurescloser to a target shape. To measure generation quality, we employ the target class probabilities predictedby the pretrained voxel classifier following the evaluation procedure for the generation task.",
  ": Qualitative results of structure generation. Best viewed in color": "We examine four different scenarios on brick budgets: even, shortage, many_big and many_small. To fairlycompare them, the same numbers of voxels are provided across the scenarios excluding the shortage case;if four 24 bricks are given for one scenario, we provide eight 22 bricks for another scenario the numbersof voxels are all 32. We assume that we are given three brick types, i.e., 22, 24, and 28. For the evencase, we evenly distribute the number of voxels for each brick type; the total number of voxels is 400. Forthe shortage case, we reduce the total number of voxels and evenly distribute the number of voxels for eachbrick type so that it can fill up to 240 voxels. For the many_big case, we allot twice as many voxels to thelargest brick type, compared to the other brick types. On the contrary, the number of voxels for the smallestbrick type is twice as many as the other brick types in many_small. As shown in , even, shortage, and many_big outperform 24 only and many_small. It is becausethe use of diverse brick types can increase the number of possible connections and helps express the fine partsof the structures. Notably, many_small fails to create structures since the number of attachable positionsfor 22 bricks is less than the other brick types.",
  "We analyze the components included in BrECS by verifying each of them in completion or generation tasks,as presented in Tables 6, 7, and 8": "Firstly, we compare different model architectures for a score prediction model. Specifically, we show thecomparisons between U-Net and fully convolutional networks. For fair comparisons, we use the same numberof convolutional filters. We present the results of generation and completion in . We find that theU-Net performs better than the fully convolutional network in both generation and completion. We presumethat the U-Net is capable of extracting features more robustly because of the pyramidal structure of U-Net. Secondly, we carry out a study on the impact of stochasticity in the selection process for brick positions bycomparing them in terms of completion and generation performance. As presented in , stochasticityimproves generation performance as expected. Interestingly, completion quality is also improved by stochas-ticity. In the completion task, we remove half of the bricks, and the model completes partially-assembledresults, which lose a large amount of their information. Stochasticity may help infer its original shape bymaking multiple candidates. Wan et al. (2021) also report that stochasticity improves the FID scores ofimage completion tasks if they are masked out a part of the original image. Moreover, we compare our original model to models without validity check or sequential skipping in thecompletion task. As reported in , each component in our model is effective for improving the qualityof brick assembly. Similar to the previous completion experiments, we complete brick structures from theintermediate states of the unseen structures in a test dataset. According to the results, the validity checkusing convolution filters plays a critical role in constraint satisfaction. Moreover, the performance of our",
  "Conclusion": "We have proposed a brick assembly method to efficiently validate complex assembly constraints and effectivelygenerate high-fidelity brick structures. To sequentially assemble LEGO bricks into 3D structures, our modelchecks the validity of brick positions using one-initialized brick-sized convolution filters and calculates brickscores utilizing the U-Net architecture. Finally, we showed that our method performs better than severalexisting methods, tested our method in both budget-free and budget-aware scenarios, and analyzed thecomponents involved in our method through diverse empirical studies.",
  "Broader Impact Statement": "From the perspective that our model tackles an instance of combinatorial optimization problems, which isan attractive problem in computer science, our work does not have any negative broader impact. However,our approach might be used to generate unethical products, because ours can create novel structures in acombinatorial manner. Thus, this negative ability should be carefully monitored and managed. This work was supported by NRF grant (No. 2023R1A1C200781211 (65%)) and IITP grants (RS-2021-II212068: AI Innovation Hub (25%), RS-2021-II211343: AI Graduate School Program at Seoul NationalUniversity (5%), and RS-2019-II191906: AI Graduate School Program at POSTECH (5%)) funded by theKorea government (MSIT).",
  "J. Lee, J. Kim, H. Chung, J. Park, and M. Cho. Learning to assemble geometric shapes. In Proceedings ofthe International Joint Conference on Artificial Intelligence (IJCAI), 2022": "Y. Lee, E. S. Hu, and J. J. Lim. IKEA furniture assembly environment for long-horizon complex manipulationtasks. In Proceedings of the International Conference on Robotics and Automation (ICRA), 2021. Y. Li, T. Kong, L. Li, Y. Li, and Y. Wu. Learning to design and construct bridge without blueprint. InProceedings of the IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2021.",
  "A. Martinovic and L. Van Gool. Bayesian grammar learning for inverse procedural modeling. In Proceedingsof the IEEE International Conference on Computer Vision and Pattern Recognition (CVPR), 2013": "T. Mikolov, M. Karafit, L. Burget, J. Cernock`y, and S. Khudanpur.Recurrent neural network basedlanguage model. In Proceedings of the Conference of the International Speech Communication Association(Interspeech), 2010. L. Ngele, A. Hoffmann, A. Schierl, and W. Reif. LegoBot: Automated planning for coordinated multi-robotassembly of LEGO structures. In Proceedings of the IEEE/RSJ International Conference on IntelligentRobots and Systems (IROS), 2020. D. Neil, M. Segler, L. Guasch, M. Ahmed, D. Plumbley, M. Sellwood, and N. Brown.Exploring deeprecurrent models with reinforcement learning for molecule design. In International Conference on LearningRepresentations Workshop, 2018.",
  "D. Ritchie, B. Mildenhall, N. D. Goodman, and P. Hanrahan. Controlling procedural modeling programswith stochastically-ordered sequential Monte Carlo. ACM Transactions on Graphics, 2015": "D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. van den Driessche, J. Schrittwieser, I. Antonoglou,V. Panneershelvam, M. Lanctot, S. Dieleman, D. Grewe, J. Nham, N. Kalchbrenner, I. Sutskever, T. Lil-licrap, M. Leach, K. Kavukcuoglu, T. Graepel, and D. Hassabis. Mastering the game of Go with deepneural networks and tree search. Nature, 2016.",
  "Z. Wan, J. Zhang, D. Chen, and J. Liao. High-fidelity pluralistic image completion with transformers. InProceedings of the International Conference on Computer Vision (ICCV), 2021": "K. D. D. Willis, P. K. Jayaraman, H. Chu, Y. Tian, Y. Li, D. Grandi, A. Sanghi, L. Tran, J. G. Lambourne,A. Solar-Lezama, and W. Matusik. JoinABLe: Learning bottom-up assembly of parametric CAD joints. InProceedings of the IEEE International Conference on Computer Vision and Pattern Recognition (CVPR),2022. J. Wu, C. Zhang, T. Xue, B. Freeman, and J. Tenenbaum. Learning a probabilistic latent space of objectshapes via 3D generative-adversarial modeling. In Advances in Neural Information Processing Systems(NeurIPS), 2016. Z. Wu, S. Song, A. Khosla, F. Yu, L. Zhang, X. Tang, and J. Xiao. 3D ShapeNets: A deep representation forvolumetric shapes. In Proceedings of the IEEE International Conference on Computer Vision and PatternRecognition (CVPR), 2015.",
  ": Overall procedure of our method": "presents the overall procedure of our method BrECS. Our method starts from a brick score calcu-lation step with a current brick structure. Then, we adjust brick scores to assemble within a given budget.Finally, we determine a brick position using brick scores from the previous steps. These steps are repeatedfor assembling a fixed number of bricks into a brick structure.",
  "B.1Bayesian Optimization": "We employ Bayesian optimization to tackle a sequential brick assembly problem.We follow the setupproposed by Kim et al. (2020). The number of bricks is limited to 160 bricks at most. Every brick positionis optimized by maximizing IoU between current and ground-truth structures. Note that we have to provideground-truth voxel information for this strategy.",
  "B.2Brick-by-Brick": "We use Brick-by-Brick as a baseline method and compare it to our method in terms of the performanceof brick assembly.We follow the model architecture and training setup of the model described in thework (Chung et al., 2021). Also, we would like to emphasize that partial ground-truth voxel informationhave to be provided for this strategy, as the method requires three images of ground-truth shapes to createtarget shapes. The number of bricks is limited to 75 bricks at most, which is the same as the original setup,due to the excessively increasing memory requirements of the model. In an inference stage, a generationsequence is halted when the newly placed brick violates the constraints, following the environment resetcondition of the method.",
  "B.3Deep Generative Model of LEGO Graphs": "We solve the problem of brick assembly generation using the deep generative model of LEGO Graphs andcompare it against ours. We follow the model architecture and training setup described in the work (Thomp-son et al., 2020). To train the graph generation model, we need the graph representations of target shapes.We therefore create target shapes with ground-truth voxel shapes. Then we convert brick structures intographs by representing bricks as nodes and direct connections between bricks as edges, following the previouswork (Thompson et al., 2020). We train this model for 200 epochs.",
  "B.4BrECS": "To efficiently train a model for 3D voxel generation, we utilize Minkowski Engine (Choy et al., 2019) and its 3Dsparse convolution operation. We train our model with a fixed learning rate of 5e-4, Adam optimizer (Kingma& Ba, 2015), a batch size of 32, sequence skipping with a step size k = 8, a buffer size of 1024, and themaximum number of bricks of 150. The input size of our model is (64, 64, 64), and the output size is also(64, 64, 64). We train the model until reaching 100k steps.",
  "DDetails of Hyperparameters": "We train our model using the Adam optimizer with a learning rate of 0.0005 and a weight decay of 0.0. Weset a batch size to 32, an internal buffer size to 1024, the number of steps to skip to 8, and a voxel size to64. The numbers of convolution kernels in the score prediction model are 7, 5, 5, 3, 3, 3, 3, 3, 3, and 3 fromtop to bottom. The number of output channels for the score prediction model is 1.",
  "GLimitations": "Our model can process any rectangular bricks with a small amount of modification. However, it is difficultto deal with more diverse brick types such as a brick with a slope and circular brick. Assembling moregeneral brick types and even free-form brick types is left for future work; since non-rectangular materials arecommon in real-world scenarios, it would make our work more effective. In addition, our model does notconsider the inefficiency that occurs when the next brick is attached to multiple bricks previously assembled.More precisely, while different pivot bricks and the corresponding relative positions are selected, the samestructure can be produced. In future work, it will be considered to improve assembly efficiency by avoidingsuch a possibility."
}