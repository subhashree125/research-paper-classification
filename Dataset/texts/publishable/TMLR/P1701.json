{
  "Abstract": "Previous work has shown that the languages recognized by average-hard attention transform-ers (AHATs) and softmax-attention transformers (SMATs) are within the circuit complexityclass TC0. However, these results assume limited-precision arithmetic: using floating-pointnumbers with O(log n) bits (where n is the length of the input string), Strobl showed thatAHATs can be approximated in L-uniform TC0, and Merrill & Sabharwal showed that SMATscan be approximated in DLOGTIME-uniform TC0. Here, we improve these results, showingthat AHATs with no approximation, SMATs with O(poly(n)) bits of floating-point precision,and SMATs with at most 2O(poly(n)) absolute error are all in DLOGTIME-uniform TC0.",
  "Introduction": "Previous work (summarized in ) has shown that the languages recognized by average-hard attentiontransformers (AHATs) and softmax-attention transformers (SMATs) are within the circuit complexity classTC0. This places some interesting computational problems beyond the power of these transformers. Inparticular, if TC0 = NC1 (as is often assumed, Williams 2022), then these transformers cannot solve anyNC1-complete problems. For example, consider Boolean formulas with constants 0 and 1 and no variables,like (0 1) ( 0 1). Checking the syntax of such formulas is equivalent to the Dyck language, whichis recognizable by both AHATs (Yao et al., 2021) and SMATs (Yang & Chiang, 2024). But computing thesemantics of such formulas, that is, deciding whether a formula is true, is NC1-complete (Buss, 1987) andtherefore not solvable by these transformers (unless TC0 = NC1). However, these non-solvability results assume limited-precision arithmetic. The best results that we areaware of use floating-point numbers with O(log n) bits (where n is the length of the input string): Strobl(2023) showed that AHATs can be approximated in L-uniform TC0, and Merrill & Sabharwal (2023b) showedthat SMATs can be approximated in DLOGTIME-uniform TC0. These results leave open the possibility thatAHATs and SMATs, as defined on paper using real numbers, might not be subject to the same limitations.Here, we improve these results, showing that:",
  "Background": "We write [n] for the set {1, 2, . . . , n}. We write x for the floor of x (greatest integer less than or equal tox), and x for the ceiling of x (least integer greater than or equal to x). We write O(poly(n)) for the familyof functions k0 O(nk).",
  "Complexity classes": "A TC0 circuit is one with made from the usual AND, OR, NOT gates, as well as MAJORITY gates, whichare true if a strict majority of their inputs are true. A TC0 circuit family is a set of circuits indexed bylengths n > 0, such that the circuit for length n has polynomial size, bounded depth, and unbounded fan-in.DLOGTIME-uniform TC0 is the set of TC0 circuit families for which queries about the circuit for lengthn can be decided in deterministic O(log n) time. Throughout this paper, whenever we say TC0, we meanDLOGTIME-uniform TC0. The class TC0 is also the class of languages definable in first-order logic with majority quantifiers (Mx.(x)iff (x) is true for a majority of positions x) and the BIT predicate (BIT(x, y) iff the y-th bit of x is 1)(Barrington et al., 1990). Depending on the context, it may be easier to think about TC0 in terms of circuitsor in terms of logical formulas. Our descriptions of functions in TC0 abstract away from details of eithercircuits or formulas, making use of functions already known to be in TC0 together with the fact that functionsin TC0 are closed under serial and parallel composition (Jebek, 2012).",
  "maxi[n] ai, bi =maxi[n] aiB/bi, B.(8)": "Lemma 6. Let T be an AHAT with rational weights, p-bit position embeddings, and no layer normalization.Let L be the depth of T. Then the computation of T needs O(pnL) bits for each intermediate and final value. Proof. First, note that if a1, b1 uses O(nk) bits and a2, b2 uses O(nk) bits, then their sum, product, andquotient (Eqs. (2) to (4)) also use O(nk) bits. But if ai, bi for i [n] use O(nk) bits each, then their sum(Eq. (7)) uses O(nk+1) bits. We prove the lemma by induction on L. If L = 0, we just look up the embeddings, which need O(p) bitsper value. If L > 0, assume that layer (L 1) required O(pnL1) bits per value. In the self-attention, thequeries, keys, values, and scores need O(pnL1) bits. The sum of the maximum-scoring values, which therecould be up to n of, needs O(pnL) bits, as does the average. Finally, the activations of the FFNN also needO(pnL) bits.",
  "Published in Transactions on Machine Learning Research (01/2025)": "Remark 8. We now have a more or less complete characterization of which regular languages can berecognized by AHATs. Barrington et al. (1992) showed that every regular language L is either in ACC0 orNC1-complete. If L is in ACC0, then it can be defined in linear temporal logic with modular counting (Baziramwaboet al., 1999), and therefore it can be recognized by an AHAT with suitable position encodings (Barcelet al., 2024).",
  "Next, we turn to SMATs, extending Merrill & Sabharwals proof from O(log n) bits to O(poly(n)) bits": "Definition 9. A p-bit floating-point number is a pair m, e where m (called the significand) and e (calledthe exponent) are integers, |m| {0} [2p1, 2p), and e [2p, 2p). The value of m, e is m 2e. We writeroundp(x), where x is either a real number or a floating-point number, for the p-bit floating-point numbernearest to x. If there are two such numbers, we call x a breakpoint and define roundp(x) to be the one withan even significand.",
  "(According to this definition, a p-bit floating-point number actually requires (2p + 2) bits: (p + 1) for thesignificand and its sign, and (p + 1) for the exponent and its sign.)": "To compute a SMAT with p-bit floating-point numbers means to approximate the operations in the SMATwith operations on floating-point numbers. In typical floating-point implementations, addition, multiplica-tion, division, and square root are rounded to the nearest floating-point number, but exp is only approximatedwith a relative error of about 2p. We also assume that summation of n numbers is performed exactly andthen rounded (following Liu et al. 2023; Chiang et al. 2023; Merrill & Sabharwal 2023a; but pace Li et al.(2024), who argue that rounding should be performed after each addition).",
  "(b) Iterated multiplication of n numbers": "Proof. These operations on O(poly(n))-bit integers are in TC0 (Theorem 2). We just have to show that theyare also definable on floating-point numbers. This is not a new result, but we try to fill in some details herethat are missing elsewhere. First, roundp(m, e) can be computed in TC0 as follows:Count the number of significand bits q =log2 |m| + 1 (Theorem 2d), shift m right by (q p) bits, and increment e by (q p).Round m tothe nearest integer, and if |m| = 2p, shift m and increment e once more. For the operations (a), we have",
  "O(poly(n)) pO(poly(n))": ": Overview of algorithm for iterated addition of p-bit floating-point numbers. The summands aregrouped into blocks that each span O(poly(n)) bits. They are separated by at least p + log2 n bits, so thatthe block-sums are separated by at least p bits. The result has three fractional bits (called the guard, round and sticky bits), which ensure that the result iscorrectly rounded to the nearest floating point number (Goldberg, 2017). Note that this can be computedefficiently even if b is a large power of 2.",
  "Weve left the block-sums unnormalized; that is, their significands could have more or less than p bits": "Step 3. Let s(i) =m(i), e(i)be the sum of the block with the i-th largest absolute sum. Then the firstblock-sum s(1) dominates the whole sum; any number not in the first block has absolute value less than2p, e(1) 2p log2 n. So we can bound the rest of the sum as:",
  "Case 2: If s(1) is a breakpoint, then we need to look at the remainder r to see which way to round. Sincer < 2e(1) (Eq. (9)), its enough to look at the sign of r, which is the sign of m(2)": "Case 3: Otherwise, s(1) is sufficiently far (on the number line) from a breakpoint that the addition of rcannot change the result. Due to cancellation, m(1) could have fewer than p bits, down to just one bit. Sothe distance to the nearest breakpoint could be as small as 2e(1)p. But r < 2e(1)p by Eq. (9).",
  "Approximating SMATs with 2O(poly(n)) error": "Defining transformers with p-bit precision and characterizing the class of languages they recognize iscomplicated, because there are many different ways to perform rounding, which can lead to differences inexpressive power (Li et al., 2024). In this section, we propose an alternative approach, which is to limit theerror of the final result of a transformer approximation and abstract away from details (like precision androunding) of how that level of error is achieved. We show that approximating a SMAT with absolute errorat most 2O(poly(n)) can be done in TC0. This has two advantages. First, it has a simple and unambiguous definition. Second, it will allow us to saysomething about the expressivity of a large subclass of exact SMATs, namely, those that accept or rejectstrings with margin 2O(poly(n)).",
  "The upper bound C on all activations was shown by Hahn (2020), and in operation (d), the lower bound cexists because we defined layer normalization to add a constant to the variance (Eq. (1))": "To simplify the error analysis, all of the above operations are performed on O(poly(n))-bit rational numbers.In TC0, all of these operations can be computed exactly (Lemma 5), except x and exp x, which can beapproximated with relative error for any 2O(poly(n)), by Lemma 12. In that Lemma, the case forsquare root asks for r [ 1",
  "a + 1. Finally, if k is odd, increment it by 1": "Fix final > 0.We show by induction that, for each operation i in the computation of T, there is ai (/poly(n)) such that if we compute operation i with error i, then the final answer has error final.In particular, it is possible to compute T using O(poly(n))-bit rationals and achieve a final error of at most2O(poly(n)).",
  "For each operation, we will show that for any > 0, there is a (/n) such that if the inputs to theoperation are approximated with error , then the output is approximated with error": "If a function f : Rd R is -Lipschitz continuous, then for any > 0, if h /, then |f(x + h) f(x)| h . Operations (ad) are -Lipschitz continuous with not depending on n, while iterated additionof n numbers (e) is n-Lipschitz continuous, and softmax of n numbers (f) is -Lipschitz continuous with not depending on n.",
  "Corollary 16. Any language that is recognizable by a SMAT with margin 2O(poly(n)) is in TC0": "Proof. Let L be a language recognized by SMAT T with margin 2O(poly(n)). By Theorem 14, there is afunction T in uniform TC0 such that for all w, we have T(w) T(w) . If w L, then T(w) > ,so T(w) T(w) > 0. Similarly, if w L, then T(w) < , so T(w) T(w) + < 0. Therefore, T alsorecognizes L.",
  "Limitations and Conclusions": "The levels of precision considered here go far beyond what is practical to compute with. Nevertheless, theseresults are valuable because they further strengthen the case that transformers cannot compute any functionoutside of TC0. Moreover, offers an alternative approach to limited-precision transformers that may be useful inmore realistic settings. In particular, an analogous argument shows that it takes O(log n) bits of precision toachieve an error of 1/O(poly(n)), which may make SMATs with margin 1/O(poly(n)) an interesting targetfor future research.",
  "Emil Jebek.Root finding with threshold circuits.Theoretical Computer Science,462:5969,2012.doi:10.1016/j.tcs.2012.09.001.URL": "Zhiyuan Li, Hong Liu, Denny Zhou, and Tengyu Ma. Chain of thought empowers transformers to solve in-herently serial problems. In Proceedings of the 12th International Conference on Learning Representations(ICLR), 2024. URL Bingbin Liu, Jordan T. Ash, Surbhi Goel, Akshay Krishnamurthy, and Cyril Zhang. Transformers learnshortcuts to automata. In Proceedings of the Eleventh International Conference on Learning Representa-tions (ICLR), 2023. URL WilliamMerrillandAshishSabharwal.Theparallelismtradeoff:Limitationsoflog-precisiontransformers.Transactions of the Association for Computational Linguistics, 11:531545, 2023a.doi:10.1162/tacl_a_00562.",
  "arXiv:2308.03212": "Lena Strobl, William Merrill, Gail Weiss, David Chiang, and Dana Angluin. What formal languages cantransformers express? A survey. Transactions of the Association for Computational Linguistics, 12:543561, 2024. doi:10.1162/tacl_a_00663. Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, LukaszKaiser, and Illia Polosukhin.Attention is all you need.In Advances in Neural Information Pro-cessing Systems 30 (NeurIPS), 2017.URL R. Ryan Williams.Some estimated likelihoods for computational complexity.In Bernhard Steffen andGerhard Woeginger (eds.), Computing and Software Science: State of the Art and Perspectives, pp. 926.Springer-Verlag, 2022. doi:10.1007/978-3-319-91908-9_2."
}