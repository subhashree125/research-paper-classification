{
  "Abstract": "Finding dense subnetworks, with density based on edges or morecomplex structures, such as subgraphs or-cliques, is a fundamentalalgorithmic problem with many applications. While the problemhas been studied extensively in static networks, much remains tobe explored for temporal networks.In this work we introduce the novel problem of identifying thetemporal motif densest subnetwork, i.e., the densest subnetwork withrespect to temporal motifs, which are high-order patterns charac-terizing temporal networks. Identifying temporal motifs is an ex-tremely challenging task, and thus, efficient methods are required.To address this challenge, we design two novel randomized ap-proximation algorithms with rigorous probabilistic guarantees thatprovide high-quality solutions. We perform extensive experimentsshowing that our methods outperform baselines. Furthermore, ouralgorithms scale on networks with up to billions of temporal edges,while baselines cannot handle such large networks. We use our tech-niques to analyze a financial network and show that our formula-tion reveals important network structures, such as bursty temporalevents and communities of users with similar interests.",
  "Introduction": "Networks (or graphs) are fundamental abstractions for understand-ing and characterizing complex systems, such as social networks ,biological systems , and more . An important primitivein graph mining is the discovery of dense subgraphs . Dense-subgraphs find applications in areas such as visualization ,anomaly detection , finance , and social networks .The density of a subnetwork is often defined as the total numberof its edges divided by the number of its vertices, and the densest KDD 24, August 2529, 2024, Barcelona, Spain 2024 Copyright held by the owner/author(s).This is the authors version of the work. It is posted here for your personal use. Notfor redistribution. The definitive Version of Record was published in Proceedings ofthe 30th ACM SIGKDD Conference on Knowledge Discovery and Data Mining (KDD 24),August 2529, 2024, Barcelona, Spain,",
  "(b)": ": 1a: Representation of a temporal network with =7 vertices, = 18 edges (edge labels denote the timings, andcommas denote multiple edges), and a temporal motif withits ordering (i.e., captures the temporal dynamics of themotif ). 1b: for = 10 only the green sequences (1,2) are-instances of in ; the red sequences are not -instances,since 3 cannot be mapped on the motif following , and 4exceeds the timing constraint on . subnetwork is the one attaining maximum density. The definitionof density can be extended to higher-order structures, such as -cliques or -vertex motifs , leading to subnetworks thatoffer a more nuanced characterization of the data, e.g., more tightly-connected communities in social networks.Many real-world networks are inherently temporal , contain-ing information about the timing of the interactions . Temporalnetworks enable the study of novel phenomena not observableotherwise, such as bursty activities , dynamic reachability, tem-poral centrality , and more .Temporal motifs are small-size subgraphs with edges havingtemporal information and a duration bound . Thetemporal information on the edges captures the temporal dynamicsof the motif, for example, information can spread on a temporal path 1 2 only if 1 < 2. In addition, a duration constraintensures that relevant events occur sufficiently close in time, e.g.,2 1 is not too large. Temporal motifs are building blocks for tem-poral networks, finding novel applications, such as cryptocurrencynetwork analysis , anomaly detection , and more .There has been growing interest in developing efficient algo-rithms to count and enumerate temporal motifs [11, 44, 47, 54, 56,",
  "KDD 24, August 2529, 2024, Barcelona, SpainIlie Sarpe, Fabio Vandin, and Aristides Gionis": "dynamic Networked Data\", and project National Centre for HPC,Big Data and Quantum Computing (CN00000013). This work isalso supported by the ERC Advanced Grant REBOUND (834862), theEC H2020 RIA project SoBigData++ (871042), and the WallenbergAI, Autonomous Systems and Software Program (WASP) fundedby the Knut and Alice Wallenberg Foundation. Walid Ahmad, Mason A. Porter, and Mariano Beguerisse-Diaz. 2021.Tie-Decay Networks in Continuous Time and Eigenvector-Based Centralities. IEEETransactions on Network Science and Engineering 8, 2 (April 2021), 17591771.",
  "Example. Consider a financial temporal network and a temporal": "triangle : 1 2 3 as from a, where captures potential money laundering activities occurring betweenusers in a short duration . Some users may be known to beinvolved in suspicious activities (e.g., they transfer large amountof money; shown in red in a) while others are not (e.g., nohistory is available for their transactions; shown in yellow or bluein a). By finding the marked densest subnetwork ({1, . . . , 5})according to motif we can identify a tightly-connected subsetof users potentially involved in suspicious activities. Interestingly,this subnetwork may contain new suspicious users (in yellow ina), not previously identified. Other promising applications captured by our formulation are,for example, (i) identifying frequent destinations appearing togetherfrom user travel data, i.e., groups of attractions visited followinga specified travel journey captured by a temporal motif ; and(ii) detecting dense groups of users and items according to spe-cific purchase sequences on e-commerce platforms, again capturedtrough temporal motifs . In both scenarios, the temporalmotif-subnetwork densest subnetwork can provide unique insights,for (i) it can be used to design novel public transport routes or travelpasses; and for (ii) it can be used for personalized advertising oridentifying users with common purchase habits.Solving the problem we propose requires exact enumeration of alltemporal motif instances in the input network, which is extremelyinefficient to perform. To address this issue we propose ALDENTE,a suite of randomized approximation ALgorithms for the tempo-ral motif DENsest subneTwork problEm. ALDENTE contains twonovel approximation algorithms leveraging a randomized samplingprocedure, which has been successfully employed for temporal mo-tif counting . Our novel algorithms can leverage anystate-of-the-art unbiased sampling algorithm for temporal motifcounting. The first algorithm in ALDENTE peels the vertex set inbatches until it becomes empty (removing vertices participating infew temporal motif instances), estimating for small > 0 within(1 ) the different counts needed for peeling. The second algo-rithm adopts a similar estimated batch-peeling technique but onlyfor a fixed number of steps. On the remaining vertices it appliesa greedy-peeling approach, where vertices that participate in fewtemporal motif instances are peeled one at a time. By carefully com-bining estimates, our methods output a high-quality solution withcontrolled error probability. Both our algorithms avoid exhaustiveenumeration of all temporal motifs in the input network. We show that the problem we study cannot be solved by directlyapplying existing techniques tailored to static high-order densityformulations that ignore the information provided by temporal mo-tifs , as this leads to poor quality solutions.We then embed temporal information in a weighted set of subgraphs,which can be used to leverage existing techniques for the identifica-tion of -vertex Motif Densest Subnetworks (-MDS). This resultsinto three baselines (an exact methods and two approximate ones),extending previous ideas for static networks .We finally show that the methods in ALDENTE find high-qualitysolutions on billion-edge temporal networks in few hundreds of sec-onds, where all other baselines cannot terminate in hours.Summarizing, our contributions are as follows: 1. We introduce the Temporal Motif Densest Subnetwork (TMDS)problem, asking for the densest subnetwork of a temporal network,where the density considers the number of instances of a temporalmotif. The TMDS problem strongly differs from existing temporalcohesive subgraph formulations given its temporal motif -baseddensity formulation. We show that the TMDS problem is not cap-tured by analogous formulations on static networks (-MDS) thatdisregard temporal information. We then develop three baselinesextending ideas for -MDS discovery embedding temporal infor-mation in a suitable weighted set of subgraphs, unfortunately suchalgorithms do not scale on large data.",
  ". We design ALDENTE, a suite of two novel approximation al-gorithms based on randomized sampling and peeling techniques,providing high-quality solutions and scaling on massive networks": "3. We perform experiments on medium- and large-size temporalnetworks, with up to billions of edges, validating ALDENTE. Weshow that baselines are often inefficient on large datasets. Ourrandomized algorithms consistently achieve speedups from 2 to43, saving hundreds of GBs of memory, and reporting high-qualitysolutions. We conclude with a case study on a financial networkdiscovering interesting temporal motif dense subnetworks.Details on application scenarios for TMDS are provided in App. A,and a summary of the notation is found in App. B. We report in theAppendix, detailed proofs of our results (App. E), additional discus-sion on methods (App. D and App. F) and experiments (App. H).Our implementation is publicly available.1",
  "Preliminaries": "A temporal network is a pair = (, ), where = {1, . . . , }is a set of vertices and = {(, ,) : , , R+} is a setof temporal edges. We let = | | be the number of vertices and = | | be the number of edges. Each edge = (, ,) contains a timestamp , representing the time of its occurrence.2",
  "A -vertex -edge temporal motif is also identified by the se-quence (1,1), . . . , (,) of edges of ordered according to.An illustration of a temporal motif is shown in a": "Definition 2.2 (-instance of a temporal motif). Given a tempo-ral network , a temporal motif , and a value R+ corre-sponding to a time-interval length, a time-ordered sequence =(1,1,1), . . . , (,,) of unique temporal edges of is a-instance of the temporal motif = (1,1), . . . , (,) if:",
  "The bijection implies that edges in are mapped onto edges in in the same ordering . Additionally, a -instance is not required tobe vertex-induced. An example of Definition 2.2 is shown in b": "Let S = { : is a -instance of in } be the set of-instancesof a motif for a given time-interval length . Computing the setS is extremely demanding, first such a set can have size O,and, in general even detecting a single -instance of a temporalmotif is an NP-hard problem .We define a weighting function : S R+ that assigns anon-negative weight to each -instance S based on its edgesand vertices, e.g., accounting for importance scores for verticesand/or edges, or available metadata. Given = (1,1,1), . . . ,(,,) S two possible realizations of weighting functions are:",
  "(ii) a decaying function : () =1": "1=2 exp(( 1)),where > 0 controls the time-exponential decay.In the above, is a simple weighting function where each -instance receives a unitary weight, this can be used in most ex-ploratory analyses where no prior information is known aboutthe network. The decaying function is inspired from link-decaymodels, where the value of corresponds to the inverse of theaverage inter-time distance of the timestamps in . Therefore, thefunction accounts for decaying processes over networks, whichare common in various domains, e.g., email communications, andspreading of diseases .",
  "(3 + 6) 0.64": "Given = (, ) and a subset of vertices , we denotewith the temporal subnetwork induced by as =( , ), where = {(, ,) : , , (, ,) } is the set edges from among the vertices in . Given , a temporal motif , and R+, for ease of notation, wedenote with S the set of all -instances of in . Withthese definitions at hand we can now assign weights to the set",
  "| |": "The TMDS problem takes in input a temporal motif , a weight-ing function , and the time-interval length R+. Differentlyfrom existing works in the literature of temporal-networks we arenot trying to find a time-window to maximize a static (or temporal)density score. As an example, consider and from a, andthe TMDS problem with constant weighting function . ashows the solution obtained with = 10, where the optimal solu-tion is = {1, 2, 3, 4, 5} with ( ) = ( )/| | = 6/5.Note that the timestamps in span an interval length greaterthan (i.e., ).Throughout this paper we say that a vertex set achievesan -approximation ratio, with 1, if ( )/OPT , whereOPT = ( ) is the value of an optimal solution to Problem 1. Analgorithm that returns a solution with an -approximation ratio isan -approximation algorithm.We conclude the preliminaries with defining the temporal motifdegree of vertex by () = S (()1), where1 is an indicator function denoting if the vertex appears atleast once over the edges in the -instance . As an example, if weconsider and as in a,, and = 10, then (4) = 2, as 4participates in two -instances of . We provide a notation table inAppendix B and all the missing proofs are deferred to Appendix E.",
  "Related work": "Densest subgraphs in static networks. Densest-subgraph dis-covery (DSD) is a widely-studied problem asking to find a subset ofvertices that maximizes edge density . Goldberg proposed a polynomial-time algorithm for computing the exactsolution using min-cut. Since min-cut algorithms are expensive,such an algorithm is not practical for large networks. Charikar developed a faster greedy algorithm achieving a 1 2-approximationratio. The idea is to iteratively remove the vertex with the smallestdegree, and return the vertex set that maximizes the edge densityover all vertex sets considered. Bahmani et al. proposed methodstrading accuracy for efficiency, including a1 2(1+) -approximationalgorithm, controlled by a parameter > 0.Most related to TMDS are the problems of -clique, or -motifdensest subgraphs . The-clique densest-subgraph problem modifies the standard density definition by re-placing edges with the number of -cliques induced by a vertexset. This problem is NP-hard. Tsourakakis developed exact and",
  "ProbPeel": "The main idea behind ProbPeel is to avoid exhaustive enumerationof S by using random sampling and peeling vertices in batchesaccording to an estimate of their temporal-motif degree. ProbPeelcarefully combines highly-accurate probabilistic (1, > 0) esti-mates of the temporal motif degrees of all vertices (that are obtainedby suitably leveraging existing algorithms for global temporal motifestimation ), and peels vertices in batches at each step ofsuch a schema, similar non-approximate batch-peeling techniqueshave been employed successfully in other settings .We briefly introduce some definitions. Let = ( , ) =(, ), and recall that S = { : is a -instance of in } isthe set of -instances from S computed only on the subnetwork ,where is not required to the subnetwork induced by . For agiven vertex , extending our previous notation, let () =S () be the temporal motif degree of vertex in the sub-network . Clearly, () = ( ).We assume a sampling algorithm A, which outputs a sample = ( , ) of a subnetwork . Given a subnetwork we will execute the sampling algorithm A to obtain N i.i.d. subnetworks D = {1, . . . , : = A( ) , []}. We use the subnetworks in D to compute an un-biased estimator () of the temporal-motif degree for ,and for the correct choice of it holds () (1 ) (), andcombine these estimates to obtain an estimator ( ) (1)( ).More details on the estimators are given in Appendix D.1.1. Algorithm description. We now present ProbPeel (Algorithm 1),our probabilistic batch-peeling algorithm. The algorithm has threeparameters, > 0, (0, 1) and > 0. The parameter controlsthe relative -approximation ratio of ( ) and (), and con-trols the failure probability of the algorithm, i.e., the guaranteesof ProbPeel hold with probability > 1 . Last, > 0 controls",
  "Scalable Temporal Motif Densest Subnetwork DiscoveryKDD 24, August 2529, 2024, Barcelona, Spain": "M1 M2 M3 M4 M5 M6 M7 M8 M9M10 0.0 0.5 1.0 Sms =172800 r=500r=500 M1 M2 M3 M4 M5 M6 M7 M8 M9M10 0.0 0.5 1.0 Facebook =86400 r=5000r=5000 M1 M2 M3 M4 M5 M6 M7 M8 M9M10 0.0 0.5 1.0 Askubuntu =172800 r=7500r=7500 M1 M2 M3 M4 M5 M6 M7 M8 M9M10 0.0 0.5 1.0 Wikitalk =43200 r=10000r=10000",
  "Lemma 4.1. For any , the count (, ) computed on asampled subnetwork is an unbiased estimate of ()": "The final estimators () for are then computed as thesample average over all the sampled subnetworks (in line 4) ofEq. (1), that is () =1/ =1 (,) for all . Note alsothat ( ) (obtained in line 6) is an unbiased estimator of ( ). Bounding the sample size. Algorithm 1 can employ any unbiasedsampling algorithm A : 2 as subroutine . We usedPRESTO-A for which the authors provide bounds on the numberof samples for event () (1)() to hold with arbitraryprobability > 1 for (0, 1). In our function GetBound we needa stronger result as we need (1 )-approximation for all temporalmotif degree of vertices . Hence we bound individually,for each vertex, the probability that () (1 ) () andcombine such result with a union bound over all vertices. (moredetails are in Appendix D.1.2).",
  "(1+) . In": "D.1.2 we discuss in details how to leverage existing state-of-the-art sampling algorithms, and their guarantees, to obtain a(1 )-approximation of the temporal motif degrees to be used byProbPeel (in line 3), where we also report all the missing detailsof the functions GetBound and GetEstimates. Time complexity. ProbPeel does not require an exhaustive enu-meration of all -instances in the network . In fact, it only es-timates the temporal motif degrees of the vertices in at eachiteration of the algorithm. The running time depends on the num-ber of samples collected at each iteration and the time requiredto process each sample, which is O( ) where denotes the max-imum number of edges of in a time-window of length .Thus, the time complexity is Omax log1+ () + (1+) ,where max = max{}, which depends on and . Such resultcomes from an analysis similar to the one we perform for a baselinein Appendix F.3. Since the algorithm does not require exhaustiveenumeration of S we expect it to be particularly efficient. In ad-dition, since we only store the estimates of the various vertices ateach iteration we expect also the algorithm to be memory efficient.",
  "HybridPeel": "In this section we develop a novel probabilistic hybrid-peeling al-gorithm, denoted by HybridPeel, which combines the randomizedbatch-peeling technique of ProbPeel (to overcome full enumera-tion of S ) with a more refined peeling approach that peels verticesone at a time, to obtain higher quality solutions (as in ). Algorithm description. The algorithm works as follows: (i) giventemporal network = (, ), it starts by removing nodes in a sim-ilar fashion to ProbPeel. That is, at each iteration it computes a(1 )-approximation of the temporal motif degree of each vertex,and vertices are removed in batches according to a thresholdcontrolled by > 0. Instead of iterating the process until the ver-tex set becomes empty, the algorithm executes the randomizedpeeling phase for a fixed number of iterations 1 providedin input. After such iterations, HybridPeel considers the ver-tex set +1 and its induced temporal network [ +1]. Thenit enumerates all temporal motifs on [ +1] (computing S +1)and peels +1 one vertex at a time according to the minimumtemporal motif degree, storing the vertex set maximizing the ob-jective function (), among the ones observed. Hence, this secondprocedure returns a vertex set maximizing () among theO(| +1| ) vertex sets explored, and HybridPeel then returns =arg max{(1)/|1|, . . . , ( )/| |,( )/| |}. The pseu-docode is reported in Appendix D.2.The design of HybridPeel is motivated by a drawback of Prob-Peel: even for very accurate estimates of temporal motif degreesit may provide a sub-optimal solution to TMDS, since even for close to 0, ProbPeel only converges to the approximation ratio of1 (1+) , while the peeling procedure we apply on +1 providesdenser solutions (close to 1/). The intuition behind HybridPeel isthat, the first iterations are used to prune the network sufficiently,for the algorithm to maintain in +1 a dense subnetwork +1 attaining at least a 1/-approximation ratio. Therefore: (i) thealgorithm is scalable, as it avoids the computation of S , and (ii) isexpected to output high-quality solutions.",
  "(1+) (1+) -approximation ratio": "Time complexity. The time complexity of the algorithm can bebounded by O( ProbPeel () + Greedy( [ +1])), i.e., thesum of the runtime () of executing ProbPeel for iterations,and then the peeling procedure that we denote with Greedy on [ +1]. The analysis follows from ProbPeel and our analysis ofa baselines in Appendix F.2. By noting that there exists a value > 1 such that | +1| = O(1/) the complexity is bounded byO(max + 13 / log()). This highlights that first peelingthe network with the randomized batch peeling technique enablesHybridPeel to work on a significantly small network, over whichto execute a more refined peeling algorithm, affording an exactenumeration of temporal motif instances on [ +1], leading toan overall scalable and practical algorithm.",
  "Temporal information impact and baselines": "A natural question is if the temporal information in the temporalnetwork is necessary, or if the directed static network associatedto already captures the TMDS problem formulation. Given atemporal network = (, ) the associated static network of is = (, ), where = {{, } | there exists (, ,) or (,,) }. If we keep the edge directions, a static directednetwork is denoted by .5 For a subset of vertices wedenote by its associated static network.We first show that even for a very simple temporal motif, theoptimal solution on can be arbitrarily bad when evaluated onthe temporal network . This highlights that Problem 1 cannot beaddressed by existing algorithms for -MDS on static networksor aggregations of the input temporal network (i.e., disregardingtemporal information). We then show how to embed temporalinformation in a weighted set of subgraphs to solve the TMDSproblem, to obtain our baselines. Computing such a set requiresfull enumeration of temporal motif instances on , which we recallto be extremely demanding, especially on large temporal networks. Temporal vs. static. We start by some definitions. For a tem-poral motif = (, ), we use [] to denote the undirectedgraph associated to , i.e., [] = (, {{, } : there exists (, )or (,) in }), ignoring directions and multiple edges in . Wesay that a temporal motif is a 2-path if = (, ), (,), with . Given a directed static graph = (, ) we definethe number of static 2-paths (i.e., directed paths of length 2) inducedby a subset of vertices as |2()|. Therefore, a static ver-sion of the TMDS problem on temporal networks with being a2-path, is to consider the aggregated network of (i.e., ) withthe goal of identifying maximizing 2() = |2( ) |",
  "evaluated for TMDS on with being a 2-path. Without loss ofgenerality, we assume the constant weighting function": "Lemma 5.1. Given a temporal network = (, ), and its as-sociated directed network , let be a solution to S2DS on .Let on be the optimal solution of TMDS, for a 2-path motif,with fixed 1. Then there exists a temporal network such that() = 0 while ( ) = O(2). Furthermore, the two solutionsets and are disjoint. Embedding temporal information. Since we cannot simply dis-regard temporal information, we investigate how to compute asuitable weighted set of static subgraphs embedding temporal in-formation. Such a set can be used to solve the TMDS problem byleveraging existing techniques. Given the input to TMDS, we defineH = { : = (, ) , for some it holds [], ( ) > 0, and | | = } be the set of -connected in-duced subgraphs (-CISs) from ,6 where each -CIS, H,encodes a subgraph containing at least a -instance S with() > 0, and is induced in , i.e., has all the edges amongthe vertices . The above conditions are ensured by requiringthe existence of such that [] and ( ) > 0,where [] is the undirected graph associated to the temporalmotif . For example, considering the motif , and the temporalnetwork from , and = 10, then the corresponding setH is H = {(1 = [{1, 2, 3}], 2 = [{2, 3, 4}], 3 = [{1, 3, 5}], 4 = [{3, 4, 5}]}.Next, we need to define the weight of each subgraph = (, )in H. This is done by ( ) = S (), i.e., the weightof the subgraph is the sum of the weights of the -instancesthat occur among the nodes of in . As an example, consider1 = (1 = {1, 2, 3}, {{1, 2}, {2, 3}, {3, 1}}) H from, then (1) = 2 under weight , and = 10, as there aretwo -instances among such nodes. Note that such a construction isin accordance with Lemma 5.1, as to build, and weight the set H weare exploiting full information about the temporal motif -instancesof in . In .1 we provide a summary on how to leveragethe set H to adapt existing techniques for high-order subgraphdiscovery to solve TMDS, while a more detailed description canbe found in Appendix F. Such algorithms will be used as baselinesfor comparison against ALDENTE in our experimental evaluation.All resulting baselines, and the algorithms in ALDENTE that wedeveloped are finally summarized in .",
  "Experimental evaluation": "In this section we evaluate the algorithms in ALDENTE againstthe baselines. We describe the experimental setup in .2,and we compare the solution quality, and runtime of all the algo-rithms in .3. Finally, in .4 we conduct a case studyon a real-world transaction network from the Venmo platform tosupport the usefulness of solving the TMDS problem. We deferto appendices for additional results, e.g., on parameter sensitivity(in Section H.2), memory usage (in Section H.4) and results underdecaying weighting function (in Section H.3).",
  "Baseline overview": "We give a brief, description of our baselines, that leverage theconstruction of the set H (as from ) and that are based onknown ideas in the field, see and Appendix F for more details.Exact: Exact algorithm embedding the set H is a properly weightedflow network, adapting ideas from . It computes multiplemin-cut solutions on the flow network, the algorithm identifies anoptimal solution to the TMDS problem.Greedy: A 1/-approximation greedy algorithm that extend theideas in . The algorithm performs O( ) iterations whereat each iteration a vertex with minimum temporal motif degreeis removed and the set H is updated accordingly. The algorithmreturns the vertex set with maximum density observed.Batch: A 1/((1 + )), > 0 greedy approximation algorithmextending ideas from . At each step the algorithm removesvertices with small temporal motif degree in batches and updatesthe set H returning the maximum density vertex set observed, theoverall number of iterations is bounded by O(log/).All such baselines require the computation of the set H, andtherefore S .7 Unfortunately, this is extremely inefficient and doesnot scale on large data, as we will show next.",
  ",4": ": Temporal motifs (M, ) used in the exper-imental evaluation. Motifs with blue vertices are not usedon EquinixChicago since this network is bipartite. For eachmotif , = 1, . . . denotes the ordering of its edges in . 1008 GB of RAM memory available. For Exact, we use the algo-rithm by Boykov and Kolmogorov to compute the (,)-min cuton the flow network. For the implementation of the min-heap weuse the data structures provided by the Boost library.8 We use thealgorithm of Mackey et al. for exact enumeration of temporalmotif -instances. We use PRESTO-A , with parameter = 1.25,as sampling algorithm in ProbPeel and HybridPeel. At each it-eration of ProbPeel (and HybridPeel) we set = , (i.e., a fixedvalue for all iterations) and we set this parameter accordingly foreach dataset; we discuss the sensitivity of the solution to parameter in Section H.2. We consider as weighting function the constantfunction . Our code is available online.9 Datasets and time-interval length. The datasets considered inthis work span medium and large sizes and are reported in .For each dataset we set to be some multiple of the respectingtime unit (e.g., for datasets with precision in seconds setting =7.2K corresponds to two hours). We also select a value of that isconsistent with previous studies and application scenarios , and large enough to be computationally challenging. Seemore details on datasets in Appendix G. Temporal motifs. The temporal motifs we use are good represen-tative of a general input to TMDS in most applications, and arereported in . They represent different topologies, e.g., trian-gles, squares and more complicated patterns, spanning different",
  "We now compare the runtime and quality of the solution reported bythe algorithms in ALDENTE (ProbPeel, and HybridPeel) againstthe baselines (Exact, Greedy, and Batch)": "Setup and metrics. For each configuration (dataset, motif, valueof ) we run each algorithm five times with a time limit of threehours and maximum RAM of 150 GB on all datasets but Equinix-Chicago, on which we set the memory limit to 200 GB. For eachalgorithm we compute the average running time over the five runs.To assess the quality of the solution of the randomized algorithms,we compute the actual value of the solution in the original temporalnetwork on the returned vertex set. For each configuration overall the algorithms that terminate we computeOPT,10 i.e., the bestempirical solution obtained across all algorithms, and we use thisvalue as reference for comparison of the different algorithms. For allthe deterministic algorithms we show the approximation factor as ( )/| | OPT, where is the solution returned by a given algorithm;for ProbPeel and HybridPeel we show the average approximationfactor over the five runs, and we also report the standard deviation.We set = 0.3 for Batch over all experiments we performed, asit provides sufficiently good solutions in most cases (see Section H.2for a detailed empirical evaluation of such parameter), and use thesame values of for ProbPeel and HybridPeel. For HybridPeelwe set = 3 on large datasets, and = 2 otherwise. When analgorithm does not terminate within the time limit we set its timeto three hours, and its approximation factor to 0. Since our focusis on scalability we place particular emphasis on large datasets, sowe defer results on medium-size datasets to Appendix H.1 as theyfollow similar trends to the ones we will discuss. We also discussresults concerning memory usage in App. H.4.",
  "Such value is guaranteed to be the actual optimum OPT only when Exact terminates": "Results. The results are reported in . Concerning the run-time, we observe different trends on the various datasets. First onStackoverflow, most of the motifs require a small runtime, of fewhundreds of seconds, to be counted (even by Exact), and on suchmotifs most algorithms achieve a comparable runtime. While onsome hard motifs, our proposed randomized algorithms achieve asignificant speed-up of more than 4 and up to 9 over the baselines(e.g., on motifs M1 and M2). On Bitcoin we observe that the runtimefor counting most motifs is prohibitive, and Exact is not able tocomplete the execution on any motif on such dataset. Remarkably,our proposed randomized algorithms achieve a consistent speed-upof at least 3 up to 8 over Greedy and Batch, and more impor-tantly our algorithms are able to complete their execution evenwhen the baselines do not scale their computation (e.g., motifs M1and M2). The scalability aspect becomes more clear on the biggestdatasets that we considered, in fact on Reddit, despite of being con-sistently more efficient than the baselines, our HybridPeel is theonly one that is able to complete its execution on M10 over all tech-niques considered. Finally, on EquinixChicago (with more than twobillions of temporal edges), our randomized algorithms (ProbPeeland HybridPeel) are the only ones that terminate their executionin a small amount of time. We observe that ProbPeel is signifi-cantly more efficient than HybridPeel, at the expense of a slightlyless accurate solution, which we will discuss next. On some of theconfigurations all algorithms do not terminate, this is because someof the motifs are extremely challenging, therefore the timelimitwe set is too strict as a constraint even for randomized algorithms.Overall these experiments suggest that our randomized algorithmssuccessfully enable the discovery of temporal motif densest sub-networks on large temporal networks. This closely matches ourtheoretical insights, capturing the superior efficiency and scalabilityof our randomized algorithms against baselines.Concerning the solution quality we observe similar trends onmost datasets. Batch provides solutions with smaller density thanGreedy, and ProbPeel closely matches Batchs results (as captured",
  "Case study": "Recently, Liu et al. released a dataset containing a small numberof transactions from the Venmo money-transfer platform, whereeach transaction is accompanied by a message. The correspondingtemporal network = (, ) is as follows: each temporal edgeis a tuple (, ,,,) where (, ,) is the temporal edge asconsidered up to now and , are metadata: {0, 1} denotesif (, ) are friends in the social network and is a text message.Since the dataset is very small (see ), we computed exactsolutions to Problem 1. We investigated the following question.Q: What insights about the Venmo platform are captured byoptimal solutions to the TMDS problem according to a temporalmotif , and what subnetworks are captured by varying R+?To answer Q we select motif M5 in , a temporal star withfour temporal edges, corresponding to finding groups of users (i.e.,the vertex at the center of M5) sending many transactions to theirneighbors (i.e., the vertices with no out-edges in M5) in a time-scale controlled by R+. In addition to M5, we provide as inputto TMDS the constant weighting function and 1 = 7 200 (i.e.,2-hours), to capture short-time scale patterns.The optimal solution has 14 vertices, and we report itsdirected static network and its temporal support in (Left).Interestingly, this is a star shaped network, with only the centralvertex (1) exchanging money with all the other vertices (not re-ciprocated), and vertices are not friends. The message associatedto each transaction is identical for all transactions: Sorry! Werealready sold out for tonight! Feel free to join us this even in the reg-ular line and pay cover when you get there. Thanks!. Even moreinterestingly, all events occur really close in time (see (Left)).In fact, this corresponds to a bursty event with merchant 1 over-booking for a specific event, which is identified by the combinationof M5 and small R+. We also observe that such a subnetworkcannot be captured by the existing formulations for dense temporalsubnetworks (see ) as both and its directed staticnetwork have very small edge-density, i.e., 13/14 < 1.We then consider M5 but analyze a much larger time-scale, that iswe solve TMDS with 2 = 172 800. Under this settings of parameterswe expect the optimal solution to contain instances of M5 with v1 v2 v3v4v5v6 v7 v8 v9 v10v11v12v13 v14 2015-05-212018-04-012021-02-09",
  "Time": "Temporal edges : Directed static network of according to dif-ferent values of on M5, we color edges according to thenumber temporal edges that map on each static edge. Beloweach static network we report the temporal support of ,i.e., we place a bar in correspondence of the timings of theevents in over the timespan of observation of the net-work. (Left): 1 = 7 200. (Right): 2 = 172 800. a longer duration (accounting for more historical user activities).The optimal subnetwork has 16 vertices and it is shown again in (Right). As expected the temporal support of such subnetworkis significantly long (spanning from Oct. 2018 to Feb. 2021). Themessages over the transactions of such subnetwork are usuallyrelated to food, theatre and social activities, denoting that usersshare similar interests. But we also identify transactions that arelikely related to sport gambling. Such suspicious transactions reportterms such as bracket season or emojis of basketballs (in fact,M5 captures such patterns as once a user loses a gamble with itsfriends, it usually sends the money using a pattern similar to M5).11 Our findings also support the insights by Liu et al. , who usetemporal motifs to identify poker gamblers on Venmo.In summary, by solving the TMDS problem for temporal mo-tifs of interest and different values of the time-window we cangain precious insights on the network being analyzed not capturedotherwise by previous formulations.",
  "Conclusions": "We introduced a new problem, requiring to identify the temporalmotif densest subnetwork (TMDS) of a large temporal network. Wedeveloped two novel algorithms based on randomized sampling,for which we proved a probabilistic approximation ratio and showexperimentally that they are efficient and scalable over large data.The techniques developed in this work may be useful in other prob-lems, such as the -clique problem given the availabilityof many sampling algorithms with tight guarantees for estimating-clique counts .There are many possible directions for future work, such asimproving the theoretical guarantees offered by our randomizedalgorithm through motif-dependent approximation ratios, and un-derstanding if randomization can be coupled with recent ideas in thefield of densest-subgraph discovery, such as techniques in . We thank Matteo Ceccarello for helpful comments on an earlierversion of the current work. This work is supported, in part, byMUR of Italy, under project PRIN n. 2022TS4Y3N EXPAND: scal-able algorithms for EXPloratory Analyses of heterogeneous and",
  "Nesreen K. Ahmed, Nick Duffield, and Ryan A. Rossi. 2021. Online Sampling ofTemporal Networks. ACM Transactions on Knowledge Discovery from Data 15, 4(April 2021), 127": "Naomi A. Arnold, Peijie Zhong, Cheick Tidiane Ba, Ben Steer, Raul Mondragon,Felix Cuadrado, Renaud Lambiotte, and Richard G. Clegg. 2024. Insights andcaveats from mining local and global temporal motifs in cryptocurrency transac-tion networks. Bahman Bahmani, Ravi Kumar, and Sergei Vassilvitskii. 2012. Densest Subgraphin Streaming and MapReduce. Proceedings of the VLDB Endowment (PVLDB) Vol.5, No. 5, pp. 454-465 (2012). arXiv:1201.6567 [cs.DB] Caleb Belth, Xinyi Zheng, and Danai Koutra. 2020. Mining Persistent Activityin Continually Evolving Networks. In Proceedings of the 26th ACM SIGKDDInternational Conference on Knowledge Discovery & Data Mining. ACM. Sayan Bhattacharya, Monika Henzinger, Danupon Nanongkai, and CharalamposTsourakakis. 2015. Space- and Time-Efficient Algorithm for Maintaining DenseSubgraphs on One-Pass Dynamic Streams. In Proceedings of the forty-seventhannual ACM symposium on Theory of Computing (2015-06). ACM.",
  "Vladimir Boginski, Sergiy Butenko, and Panos M. Pardalos. 2003. On StructuralProperties of the Market Graph. In Innovations in Financial and Economic Networks.Edward Elgar Publishing, 2945": "Digvijay Boob, Yu Gao, Richard Peng, Saurabh Sawlani, Charalampos Tsourakakis,Di Wang, and Junxing Wang. 2020. Flowless: Extracting Densest SubgraphsWithout Flow Computations. In Proceedings of The Web Conference 2020. ACM. Y. Boykov and V. Kolmogorov. 2004. An experimental comparison of min-cut/max-flow algorithms for energy minimization in vision. IEEE Transactions on PatternAnalysis and Machine Intelligence 26, 9 (sep 2004), 11241137. Marco Bressan, Stefano Leucci, and Alessandro Panconesi. 2021. Faster MotifCounting via Succinct Color Coding and Adaptive Sampling. ACM Transactionson Knowledge Discovery from Data 15, 6 (may 2021), 127.",
  "Moses Charikar. 2000. Greedy Approximation Algorithms for Finding Dense Com-ponents in a Graph. In Approximation Algorithms for Combinatorial Optimization.Springer Berlin Heidelberg, 8495": "Chandra Chekuri, Kent Quanrud, and Manuel R. Torres. 2022. Densest Subgraph:Supermodularity, Iterative Peeling, and Flow. In Proceedings of the 2022 AnnualACM-SIAM Symposium on Discrete Algorithms (SODA). Society for Industrial andApplied Mathematics, 15311555. Tianyi Chen, Brian Matejek, Michael Mitzenmacher, and Charalampos E.Tsourakakis. 2023. Algorithmic Tools for Understanding the Motif Structureof Networks. In Machine Learning and Knowledge Discovery in Databases. SpringerInternational Publishing, 319. Tianyi Chen and Charalampos Tsourakakis. 2022. AntiBenford Subgraphs: Un-supervised Anomaly Detection in Financial Networks. In Proceedings of the28th ACM SIGKDD Conference on Knowledge Discovery and Data Mining. ACM.",
  "Rong-Hua Li, Jiao Su, Lu Qin, Jeffrey Xu Yu, and Qiangqiang Dai. 2018. PersistentCommunity Search in Temporal Networks. In 2018 IEEE 34th International Con-ference on Data Engineering (ICDE). IEEE": "Longlong Lin, Pingpeng Yuan, Rong-Hua Li, Jifei Wang, Ling Liu, and Hai Jin.2022. Mining Stable Quasi-Cliques on Temporal Networks. IEEE Transactionson Systems, Man, and Cybernetics: Systems 52, 6 (jun 2022), 37313745. Jieli Liu, Jinze Chen, Jiajing Wu, Zhiying Wu, Junyuan Fang, and Zibin Zheng.2024.Fishing for Fraudsters: Uncovering Ethereum Phishing Gangs WithBlockchain Data. IEEE Transactions on Information Forensics and Security 19(2024), 30383050. Penghang Liu, Rupam Acharyya, Robert E. Tillman, Shunya Kimura, NaokiMasuda, and Ahmet Erdem Saryce. 2023.Temporal Motifs for FinancialNetworks: A Study on Mercari, JPMC, and Venmo Platforms. arXiv (2023).arXiv:2301.07791 [cs.SI] Paul Liu, Austin R. Benson, and Moses Charikar. 2019. Sampling Methods forCounting Temporal Motifs. In Proceedings of the Twelfth ACM International Con-ference on Web Search and Data Mining - WSDM 19 (Melbourne VIC, Australia,2019). ACM Press, 294302.",
  "Ashwin Paranjape, Austin R. Benson, and Jure Leskovec. 2017. Motifs in Tem-poral Networks.Proceedings of the Tenth ACM International Conference onWeb Search and Data Mining (2017). [cs.SI]": "Noujan Pashanasangi and C. Seshadhri. 2021. Faster and Generalized TemporalTriangle Counting, via Degeneracy Ordering. In Proceedings of the 27th ACMSIGKDD Conference on Knowledge Discovery & Data Mining (2021-08). ACM. Giulia Preti, Polina Rozenshtein, Aristides Gionis, and Yannis Velegrakis. 2021.Discovering Dense Correlated Subgraphs in Dynamic Networks. In Advancesin Knowledge Discovery and Data Mining. Springer International Publishing,395407.",
  "Diego Santoro and Ilie Sarpe. 2022. ONBRA: Rigorous Estimation of the TemporalBetweenness Centrality in Temporal Networks. In Proceedings of the ACM WebConference 2022. ACM": "Ahmet Erdem Sariyuce, C. Seshadhri, Ali Pinar, and Umit V. Catalyurek. 2015.Finding the Hierarchy of Dense Subgraphs using Nucleus Decompositions. InProceedings of the 24th International Conference on World Wide Web. InternationalWorld Wide Web Conferences Steering Committee. Ilie Sarpe and Fabio Vandin. 2021. odeN: Simultaneous Approximation of MultipleMotif Counts in Large Temporal Networks. In Proceedings of the 30th ACMInternational Conference on Information & Knowledge Management (2021-10).ACM. Ilie Sarpe and Fabio Vandin. 2021. PRESTO: Simple and Scalable SamplingTechniques for the Rigorous Approximation of Temporal Motif Counts. InProceedings of the 2021 SIAM International Conference on Data Mining (SDM).Society for Industrial and Applied Mathematics, 145153.",
  "Bintao Sun, T.-H. Hubert Chan, and Mauro Sozio. 2020. Fully Dynamic Approxi-mate k-Core Decomposition in Hypergraphs. ACM Transactions on KnowledgeDiscovery from Data 14, 4 (May 2020), 121": "Bintao Sun, Maximilien Danisch, T-H. Hubert Chan, and Mauro Sozio. 2020.KClist++: a simple algorithm for finding -clique densest subgraphs in largegraphs. Proceedings of the VLDB Endowment 13, 10 (jun 2020), 16281640. John Tang, Mirco Musolesi, Cecilia Mascolo, and Vito Latora. 2010. Characterisingtemporal distance and reachability in mobile and online social networks. ACMSIGCOMM Computer Communication Review 40, 1 (jan 2010), 118124. Charalampos Tsourakakis. 2015. The K-clique Densest Subgraph Problem. InProceedings of the 24th International Conference on World Wide Web (2015-05).International World Wide Web Conferences Steering Committee.",
  "Jiabing Wang, Rongjie Wang, Jia Wei, Qianli Ma, and Guihua Wen. 2020. Findingdense subgraphs with maximum weighted triangle density. Information Sciences539 (2020), 3648": "Jingjing Wang, Yanhao Wang, Wenjun Jiang, Yuchen Li, and Kian-Lee Tan. 2020.Efficient Sampling Algorithms for Approximate Temporal Motif Counting. InProceedings of the 29th ACM International Conference on Information & KnowledgeManagement. ACM. Jiajing Wu, Jieli Liu, Weili Chen, Huawei Huang, Zibin Zheng, and Yan Zhang.2022. Detecting Mixing Services via Mining Bitcoin Transaction Network WithHybrid Motifs. IEEE Transactions on Systems, Man, and Cybernetics: Systems 52, 4(apr 2022), 22372249. Qiankun Zhao, Yuan Tian, Qi He, Nuria Oliver, Ruoming Jin, and Wang-ChienLee. 2010. Communication motifs. In Proceedings of the 19th ACM internationalconference on Information and knowledge management - CIKM '10. ACM Press. Ming Zhong, Junyong Yang, Yuanyuan Zhu, Tieyun Qian, Mengchi Liu, andJeffrey Xu Yu. 2024. A Unified and Scalable Algorithm Framework of User-Defined Temporal (, X)-Core Query. IEEE Transactions on Knowledge and DataEngineering (2024), 115.",
  "AApplication scenarios for the TMDS problem": "While we study the TMDS problem in its general form, in thissection we discuss more in depth two possible applications of ournovel problem formulation, showing that the TMDS is a reallyversatile and powerful tool for temporal network analysis. We willdiscuss how the Temporal Motif Densest Subnetwork (TMDS) canbe used to discover important insights from (i) travel networks and(ii) e-commerce networks capturing online platforms.(i) A travel network can be modeled as a temporal network = (, ) with being the set of vertices corresponding to PointsOf Interest (POIs) or particular geographic areas of a city , andedges of the form (, ,) represent trips by user that travelfrom point to point at time . A temporal motif onsuch network captures therefore travel patterns and their dynamics. As an example a temporal motif : 1 2 occurring withinone day often corresponds to a round trip by a user from being thehome location, to being the work location. The TMDS problemformulation, in such a scenario can provide unique insights on thePOIs appearing frequently together in the various travel patterns(isomorphic to ) of the various users. Furthermore, analyzingdifferent time-scales as captured by the temporal motif duration, canyield unique insights about daily vs. weekly vs. monthly patterns.As for our in the TMDS several POIs often coexist, andsuch information can be used to improve connections between POIsthat are not well connected by public transport, or for the design of",
  "SymbolDescription": "= (, )Temporal network , Induced temporal sub-network by ,Number of nodes and temporal edges of ,Directed and undirected static network of = (, )-vertex -edge temporal motif = (, )Multi-graph of the temporal motif Ordering of the edges of in a motifTime window-length of a temporal motif instanceS Set of -instances of in the network S , Set of -instances of in the network Weighting function over S( ), Total weight of the -instances in S()TMDS objective function[]Undirected graph associated to HSet of -CIS over (), Temporal motif degree of vertex in (), Temporal motif degree of vertex in > 0Threshold for batch peeling,Accuracy and confidence parametersSample size in ProbPeel, HybridPeel ()Estimate of the temporal motif degree of in Maximum edges from in a window length of Parameter of the subroutine PRESTO-A travel passes for specific areas of a city with specific time-duration,based on POIs that are often visited together in the various trips.(ii) E-commerce online platforms can be modeled as temporalbipartite networks = (, ), where the set of vertices is parti-tioned in two layers = , with being the set of users (i.e.,customers that purchase online products), and the set of prod-ucts available for purchase. A temporal edge = (, ,) on sucha network captures that user purchased product at a given time . As an example a temporal motif : 1 ,2 occurring within a time-limit corresponds to a pair of productsi.e., and that user buys at distance of at most the providedtime-limit, note also that is purchased after . A temporal motif therefore captures specific purchase habits of users within alimited time-limit (as again controlled by the duration parameterof the temporal motif). The optimal TMDS can be used to collecta set of users (and items) that frequently co-occur. In particular,the TMDS can contain several vertices (i.e., users) with similarpurchase sequences or buying habits, this enables the design ofpersonalized advertisement for those users in the TMDS (e.g., byleveraging the history of other users in the TMDS), furthermorethis can be studied at different time-scales. Note also that this ismore powerful than only considering products that are frequentlyco-purchased together (e.g., consider , then the products and are purchased in different moments), for which many techniquesalready exist.",
  "TMDS (ours)DCCCCCDDD": "CTMDS vs existing formulationsIn this section we present an overview of the existing formulationsfor cohesive subnetwork discovery in temporal networks compar-ing them with our TMDS formulation. The extensive comparisonis reported in . As a summary of such table we highlight thefollowing, our formulation is the unique of its kind combining high-order structures with purely temporal informal information avoidingtherefore temporal aggregation, and additionally it can be used ondirected temporal networks.First we observe that most of the existing formulations workon undirected temporal networks, and it is not straightforward toadapt (or extend) them on directed temporal networks, which aremore general models. Our formulation naturally captures directedtemporal networks, and in fact fully exploits such information, asan example, with the definition of temporal motif that we assume(Definition 2.1) there are eight possible triangles on directed tem-poral networks, but only one such triangle exists on undirectedtemporal networks, reducing significantly the information that wecan gain by analyzing such patterns. Then our formulation avoidsa temporal network model leading to aggregation, which is knownto cause information loss , as computing snapshots of temporalnetworks (or constraining optimal scores to specific fixed intervals)may obfuscate the general temporal properties in the data. Addi-tionally, only one of the surveyed formulations (i.e., ) accountsfor high-order structures in the form of static quasi-cliques whichis a completely different formulation compared to TMDS. Our for-mulation is in fact much more flexible as the temporal motif canby any arbitrary temporal motif of interest. Finally we also avoidsegmentation as the constrain on the time-interval length wellcorrelates with the overall timespan of the reported solution, andwith more complex weighting functions defined over S it isalso possible to control for the temporal properties of the reportedsolution (e.g., a persistence score from ).",
  "D.1Estimating temporal motif-degrees": "D.1.1Building the estimator. We briefly recall from howto compute a (1 ) estimate of the temporal motif degree ()of a vertex . First recall that we assume access to a samplingalgorithm A, which, given as input a subnetwork , ,it outputs a sample = ( , ) . Using such a sample",
  "()1[{ S }],": "where 1[] is an indicator random variable taking value 1 if thepredicate holds, and 0 otherwise. By taking expectation on bothsides, combined with the linearity of expectation, and the fact thatE[1[{ S }]] = the claim follows by the definition of (). Given a subnetwork , we execute the sam-pling algorithm A to obtain N i.i.d. sampled subnetworksD = {1, . . . , : = A( ) , []} (in line 4). Wecan therefore compute the sample average of the estimates obtained",
  "=1 (,),for all ,": "and (,) is computed with Equation (2) on the -th sampledsubnetwork from the randomized sampling algorithm A. As dis-cussed in , it also holds that ( ) = 1/ () isan unbiased estimate of( ), as E[ ()] = () by Lemma D.1combined with the linearity of expectation and the fact that ( ) =1/ (), which is an important property for the finalconvergence guarantees of our algorithms in ALDENTE. D.1.2Leveraging a sampling algorithm. Algorithm 1 can employany sampling algorithm A : 2 as subroutine. In practice weused the state-of-the-art sampling algorithm PRESTO-A for es-timating temporal motif counts of arbitrary shape.12 For PRESTO-Athe authors provide bounds on the number of samples for event() (1 )() to hold with arbitrary probability > 1 for (0, 1), which needs to be adapted to work in our scenariosince we require stricter guarantees. We adapt such algorithm togeneral weighting functions over the set of -instances, and tocompute (), at each iteration of Algorithm 1. Wenow briefly describe how PRESTO-A works and proceed to illustratehow to adapt the bound in to the function GetBound, since atighter concentration result is needed.Given a subnetwork [], PRESTO-A samples a small-size sub-network = ( , ) [] ensuring that all its edges arecontained in a window of length , > 1, i.e., let 1, . . . ,|| bethe sorted timestamps of the edges of then || 1 . Onsuch subnetwork PRESTO-A computes Equation (2) for each ,where =",
  ", where is the length of the-instance S": "and = O(| | 1), i.e., it is simply proportional to thelength of the timespan of []. Such algorithm extracts sampledsubnetworks and computes the unbiased estimates (), and () = 1/ (). Next we show that leveraging thetechniques in we obtain a bound on the number of samples, [] computed through GetBound. In particular, by perform-ing a similar analysis to the one in we obtain the followingcorollary, which specifies the output of the function GetBound.",
  "D.2HybridPeel pseudocode": "We report the missing pseudocode of HybridPeel in Algorithm 2.The algorithm proceeds as follows, it runs for iterations therandomized batch peeling approach (lines 2-8), obtaining there-fore the sets 1, . . . , and +1. For the vertex sets , []the algorithm has only approximate density ()/| | wherethe approximation factor is controlled by the parameter (i.e.,() (1)()), instead on +1 the algorithm can be summa-rized by applying Greedy on [ +1] (that we discuss in details inSection F.2). Therefore greedy peeling is applied on [ +1], whichproceeds by removing vertices one at a time according to their exacttemporal motif degree in [ +1] (line 9). That is, the algorithmcomputes all temporal motif-instances in [ +1] and it greed-ily removes, one at a time, the vertices with minimum temporalmotif-degree, Greedy therefore returns the solution with maximumdensity among the O(| +1| ) vertex sets observed (i.e., it startsfrom +1 and peels it one vertex at a time until it becomes empty).The solution with maximum density is finally returned by Hybrid-Peel, where the maximum is taken over the solutions obtained inthe randomized batch peeling loop and the best solution identifiedby Greedy when executed on [ +1] (line 10). The approximationratio HybridPeel is shown in Theorem 4.3, and it is presented inthe next section.We recall that intuitively, HybridPeel achieves very good per-formances and scales on large data since, at the beginning of itsexecution during the first iterations (when the temporal network",
  "EMissing proofs": "In this section we present the missing proofs for Theorem 4.2,Theorem 4.3, and Lemma 5.1. We show in the dependencygraph for the proofs of Theorem 4.2 and Theorem 4.3 as they dependon results that we obtain in Section F, for a better understanding,we suggest to follow the proofs in reverse order of dependence. Proof of Theorem 4.2. We first fix the random variable cor-responding to the number of iterations of Algorithm 1 to O(log1+ ()) since an analogous result to Lemma F.5 holds alsofor Algorithm 1, i.e., we are conditioning on the realization of in its range. In the following analysis we assume that the events () (1 ) (), hold at each iteration []of our Algorithm 1 with probability > 1 /2, note that this isensured by the function GetBound.First we note that there should exist at least one vertex in (), [], since for contradiction let () > (1+) ()/| | for each , then we can prove the following () = () >(1 + )| | ()/| | hence 1 > (1 + ), > 0, leading to the con-tradiction. The analysis is similar to Lemma F.4 but complicatedby the fact that the quantities involved are estimates. Considerthe iteration in which the first vertex is removed, let",
  "(1 + )(1 + )( )| | .(3)": "Let be the vertex set returned by Algorithm 1 and thesolution achieving the approximation in Equation (3), note that( )/| | (1 )( ) and the output may be such that( )/| | (1)( ) but with ( ) ( ), but noting that( ) (1)( ) then (1)( ) ( )/| | (1+)( )therefore ( ) (1) (1+) ( ) hence the claim follows by combin-ing the above with Equation (3) and the fact that Algorithm 1 willreturn a vertex set achieving at least the solution attained by ,which proves the bound on the approximation factor. Finally, toshow that such guarantees hold with probability > 1 , let bethe event that the probabilistic guarantees of Algorithm 1 fail atiteration [], this occurs only if the following bad event occurs: = there exist such that () (1 ) (). Recallthat at each iteration [1, O(log)] the sample size obtained byGetBound guarantees that P[] /2, then the probability of theevent that the algorithm fails under random iterations duringits execution is bounded by",
  "combining the union bound and the geometric series, concludingthe proof": "Proof of Theorem 4.3 (Sketch). The proof is similar to the oneof Lemma 4.2. We only need to account for some sub-cases thatmay occur when considering the solution obtained in Line 9that is obtained by running Greedy on +1. As for the proofof Lemma 4.2 we assume that at each iteration of the itera-tions by using approximate temporal-motif degrees it holds that () (1 ) () for each and = 1, . . . , .Which also implies that ()/| | (1 )()/| |. Nowlet us consider the first node that gets removed acrossthe iterations of the algorithm, then there may be two distinctcases (I). for some = 1, . . . , ; and (II) or +1. (I)In this case the algorithm returns a solution which attains thesame approximation quality as in Lemma 4.2 since it is easy tosee that (i.e., the subnetwork obtain by Greedy) cannot pro-vide a much worse solution than the best solution observed bythe algorithm during the iterations using approximate temporalmotif degrees. Let be the solution achieving the(1) (1+) (1+) -approximation factor (recall that and , for [] sosuch a solution must exists). Let be the best estimated solutionby the algorithm i.e., = arg max{()/| |, ( )} returnedby HybridPeel, then it is easy to see that ( ) cannot be less than(1 )() since otherwise the algorithm will pick ()/||as optimal solution, therefore the worst case still remains the one",
  "= 1 = 2": ": Temporal network = (1 = (1, 1) 2 = (2, 2))as constructed in the proof of Lemma 5.1. The timestamps ofthe temporal edges are placed below each layer, for simplicityof visualization. 1 is the optimal solution for S2DS but itachieves a solution that is 0 for TMDS problem, for whichthe vertices in 2 achieve the optimal solution O (2).",
  "(1+) (1+) since Greedy evaluates() exactly on and not approximately, concluding thereforethe claim": "Proof of Lemma 5.1. First fix arbitrary large and also assume/12 N to keep the notation simple. Let = 1 2 be theunion of two temporal networks with similar structure, the firstone 1 = (1, 1) where 1 = {1, . . . , 3/4} and 1 = {(, , 2) : [1,/4], [/4 + 1,/2]} {(, , 1) : [/4 + 1,/2], [/2 + 1, 3/4]} and the other network is 2 = (2, 2) where2 = {1, . . . , /4} and 2 = {(, , 1) : [1,/12], [/12 +1,/6]} {(, , 2) : [/12 + 1,/6], [/6 + 1,/4]}. See for a visualization of the resulting network . Let be thedirected static network associated to , then the solutions of S2DSon 1 and 2 are respectively (/4)3/(3/4) and (/12)3/(/4) hence the optimal solution is achieved by = 1. But when weconsider TMDS problem on on a 2-path temporal motif for fixedat least to 1, 1 has a solution whose value is 0 (i.e., () = 0),since none of its temporal paths are time-respecting (there are noinstances of 2-paths in 1), while = 2 achieves a solution( ) = O(2). Finally note that = .",
  "F.1Exact": "We first present Exact, an exact algorithm for the TMDS problem,which solves multiple (,)-min-cut instances on a flow network en-coding weights of-instances in S , leveraging H (which we brieflymentioned in ). This algorithm extends ideas developedfor the exact solution of -vertex motif and triangle (or -clique)densest-subgraph problems in static networks .A flow network = (, ) is a directed network with twospecial vertices (source) and (sink) and a set ofintermediate vertices, such that the source has edges of the form(, ) and the sink is connected by edges of (,) where representsan intermediate vertex. Additionally, each edge over thenetwork is assigned with a weight (), and a (,)-min-cut onsuch network is a partition (S, Z) of the vertices such that Sand Z, and the cost of the cut (defined as sum of the weights ofthe edges going from vertices in S to vertices in Z) is minimized.We first recall some definitions, starting from graph isomor-phism: we say that 1 = (1, 1) and 2 = (2, 2) are isomorphic(denoted by 1 2) if there exists a bijection on the verticessuch that 1 = (,) 1 if and only if 2 = ((),()) 2.Next we recall the construction of the set H, that is givena parameter N, we defined H = { : = (, ) , for some it holds [],( ) > 0, and | | =} to be the set of -connected induced subgraphs (-CIS) from , where each -CIS encodes a subgraph containing at least a-instance with () > 0, and is induced in , i.e., it containsall edges among the vertices . Note that this condition is en-sured by requiring the existence of such that []and ( ) > 0, where [] is the undirected graph associatedto the temporal motif . Given a -vertex -edge temporal mo-tif and a temporal network = (, ), let us consider theweighted flow network = ( = {} H {}, ), with, : R+0, where: each vertex H is associated to a -CIS H; and are the source and sink vertices of the flow network; = (1 2 3) where 1 = {(, ) : H}, 2 ={(, ) : H, , }, 3 = {(,) : },i.e., 1 connects the source to all vertices inH, 2 connectseach vertex H representing a -CIS = (, ) H to its vertices in , and 3 connects each vertexof to the sink ;",
  "( ) = S ()if = (, ) 1,+if 2, andif = (,) 3": "We show how the optimal solution to the TMDS problemis computed in Algorithm 3. The algorithm first enumerates all-instances in the temporal network (line 1) and builds the flownetwork described above (line 3). It then instantiates ,, i.e., therange in which we will seek for the optimal values of the solution toProblem 1, min and used for finding the optimal values throughbinary search (lines 4-5). Then the algorithm starts its main loop(line 6) seeking at each iteration for the optimal solution byrepeatedly solving the (,)-min cut on the flow network withweights , , and updating accordingly at each iteration, whilemaintaining the candidate optimal solution (line 10).We show in the next lemma that Algorithm 3 correctly identifiesthe optimal density value = ( ) = ( )/| | to Problem 1therefore returning the optimal solution .The proof follows similar arguments as in previous work . Some of details are not immediately transferable from previousproofs, such as the connection to the solution on the temporalnetwork , therefore, we present in detail the proof below. Lemma F.1. Given a temporal network = (, ), a temporalmotif , and > 0, let be the optimal value for the solution ofTMDS problem with weighting function . Let (S, Z) be the (,)-mincut on with weighting function ,, 0 at an arbitrary iterationof Algorithm 3. If = S then else . Proof. First of all we note that every min cut (S, Z) should befinite, since trivially the cut ({}, \\ {}) has a value of the cut( )13 and such value is finite. Fix a (,)-min cut (S, Z) then let = S . First of all note that if =(, ) S, H then , for all and therefore S = S S in ,since every minimum cut is finite.",
  "Recall that for a directed and weighted flow network, the cost of the cut (S, Z) isthe sum of the weights on the outgoing edges from S to Z": "Let us consider a finite min-cut (S, Z). Let = S and let be the induced subgraph of in and the inducedsubnetwork of in . Let denote the cost of the cut, i.e., sum ofthe outgoing weighted edges from S to Z. Since the minimum cutcan only be finite, we have the following:",
  "= ( ) ( ) | |(6)": "In the above derivation, Equation (4) follows from the definitionof the cost of a cut, and the fact that if S then each vertex in is also in S since the min-cut is finite. Equation (5)follows from the definition of and the fact that H = (H Z) (H S). To see why Equation (6) holds, let H H andwe have",
  "().(7)": "Note that the above holds since each vertex in H represents adistinct -CIS, i.e., the same vertex cannot represent two identicalvertex sets in the original network . Given Equation (7), we nowobtain Equation (6) by combining S H = S , the definitionof , and the fact that given there exists H suchthat is in H S since the cut is optimal, and conversely, if agiven vertex is in H S then by the finiteness of theminimum cut.We are now ready to show that if then ( ) | | 0.If ( ) | | < 0, then by Equation (6) this min-cut would belarger than the cut ({}, \\ {}) contradicting its optimality.Hence it holds that ( ) | | .Conversely, if = then we show that ( ) | | 0 foreach . Note that this is trivial if H S = , so we willassume that the set H S is not empty. Let for contradiction( ) | | > 0 for a certain . Let H be the set ofvertices in H corresponding to -CIS between vertices of in with at least one -instance S , () > 0, for which itholds H S = H . Consider also the cut (S, Z) = ({} H , \\ {{} H }). Since this cut is finite, byapplying Equation (6) we get",
  "F.2Greedy": "In this section we present Greedy, a 1/-approximation algorithmfor the TMDS problem. In particular, Algorithm 4 is based on anextension of Charikars algorithm for the edge densest-subgraphproblem . Greedy removes vertices one at a time according tothe minimum temporal motif degree in the subset of vertices beingexamined. This will be done by first computing the set H, and thenmaintaining such set updated over the peeling procedure, as weshow next. Algorithm description. Given a temporal network = (, )a temporal motif , a value of and the weighting function ,let let S () = { : S and }, that is the setof -instances in the subnetwork induced by in which participates. Therefore, the temporal motif degree (under weightingfunction ) of vertex is () = S () (), and wewrite () when and are clear from the context. We are readyto describe Algorithm 4, which first enumerates all -instances ofthe temporal motif in (line 1) and then initializes two sets and S, maintaining respectively the vertex set of the network andits corresponding set of -instances (line 3). Entering the main loop(line 4), at iteration the algorithm removes the vertex with the 14Some optimization according to Fang et al. can be used to reduce this range butit cannot improve the overall worst-case complexity.15We assume that () can be computed in at most O() for each given -instance .16More advanced algorithms may require smaller running time.",
  "return arg max=,...,{()};": "minimum temporal motif degree in the subnetwork induced by, updating the corresponding sets of remaining vertices and -instances (lines 5-7), and this is done by properly encoding the set H(see the time complexity analysis for more details). The algorithmreturns as solution the set that maximizes the TMDS objectivefunction among all vertex sets examined. The following resultestablishes the approximation ratio of Algorithm 4.",
  "(| | 1).(8)": "The above inequality follows from the optimality of . Combiningthe above with the fact that \\{} \\{} () + () =( ) we get that () ( )/| |. Let us consider theiteration before Algorithm 4 removes the first vertex . Let denote the vertex set in such an iteration. Then andadditionally we know that given it holds () () () ( )/| |. Hence,",
  "| | , which concludes the proof": "Time complexity. Note that Algorithm 4 requires an enumerationof all -instances in the temporal network , which takes expo-nential time. To provide an efficient implementation we computefor each vertex the temporal motif degree () and webuild a Fibonacci min-heap over these counts (taking O( log)for build up), with amortized update cost of O(1), which we useto retrieve the vertex to be removed at each iteration in O(log)time. Let us define H () = { = (, ) : , H} H.Additionally, for each vertex we maintain the set H ()of the static -CIS in , i.e., subgraphs 1 . . . , |H()| for which",
  "return": "there exists at least one -instance with non-zero weight betweenvertices in , where for each = 1, . . . , |H ()|.By using the Fibonacci min-heap data structure, vertices canbe removed by avoiding the re-calculation of -instances, and weonly update the vertices alive and their instances, i.e., removinga vertex requires for each -CIS , for [1, |H ()|], to beremoved from the lists of all the other 1 vertices involved in each-CIS, requiring O(|H ()| log(|Hmax|)) time where |Hmax| =max {|H ()|}. Therefore, the final time complexity is",
  "F.3Batch": "In this section we show how to speed up Algorithm 4 for the priceof a slightly weaker approximation guarantee, to obtain our lastbaseline. This technique is an important building block for bothProbPeel and HybridPeel. The main idea is similar to existingtechniques in literature : instead of removing one vertexat a time, remove them in batches according to their temporal motifdegree, so that the algorithm terminates in fewer iterations withrespect to Greedy. Additionally, the algorithms leverages a similarapproach to Greedy for using the set H, without the need of storingthe temporal motif degrees in a min heap. The number of iterations,as well as the approximation ratio, are controlled by a parameter > 0. Algorithm description. Batch is shown in detail in Algorithm 5.It takes as input all the parameters to the TMDS problem and anadditional parameter > 0, and after enumerating all -instancesof in (line 1), at each round it peels the set ( ) where isthe vertex set active in that iteration. The vertices ( ) aresuch that their temporal motif degree () (in the subnetworkinduced by ) is small compared to a threshold controlled by (lines 5-6). The algorithm returns the best solution encountered,according to the objective function () of Problem 1 (line 7). Thefollowing result establishes the approximation ratio of Algorithm 5.",
  "(1+) -approximation algorithm forthe TMDS problem": "Proof. First observe that at each iteration the set ( ) is non-empty. Indeed, if we assume () > (1+)( )/| |, for each , then ( ) = () > | |(1 + )( )/| |,hence > (1 + ), with > 0, leading to a contradiction. Let usconsider the optimal solution , and the iteration when the firstvertex is added to ( ). Note that . We knowthat for each ( ) it holds () (1 + )( )/| |hence",
  "proves the claim": "We now provide a bound on the time complexity of Algorithm 5.First observe that we do not need to use a Fibonacci heap to storeweighted counts of the different instances for the graph vertices,since we are peeling the vertices in batches. Instead, we need tokeep track of the -CIS (and hence the set H, and H (), )in containing each vertex, as in Algorithm 4. Therefore, therunning time can be bounded with a similar analysis to Greedy by",
  "HMissing experimental resultsH.1Results on medium sized datasets": "In this section we comment the missing results from .3,i.e., the results relative to the solution quality and running time onthe medium-size datasets from . The settings of such resultis the same as from .3, where we recall we set = 2 onmedium-size datasets for HybridPeel. We observe similar trendsto the large datasets we considered, in particular Greedy gener-ally outputs solutions with similar or better quality than Batchon most instances over all motifs, and both such algorithms havecomparable running times. Interestingly, on such medium-size net-works, for all motifs over most configurations the optimal densesttemporal subnetworks can be identified by Exact, as in generalthis algorithm takes few tens of seconds to conclude its execution(except for specific configurations, such as the Wikitalk dataset ormotif M5). Additionally, regarding the algorithms in ALDENTE, wealso observe the same trends as for our large datasets (discussedin .3), that is ProbPeel provides a solution with closeapproximation-ratio to the one provided by Batch, and Hybrid-Peel often improves ProbPeel, again HybridPeel almost alwaysmatches the solution quality provided by Greedy. Interestingly, onAskubuntu, our randomized algorithms are the only algorithmsthat are able to complete their execution under three hours onM5 where all baselines fail, which again highlights the scalabilityand efficiency of ALDENTE in hard settings, such as challengingtemporal motifs.",
  "H.2Sensitivity analysis": "H.2.1Varying . We show how the solution obtained by Batchvaries according to the value of , this setting is used to under-stand the best possible solution that can be obtained by ProbPeelaccording to various values of (i.e., when 0 then ProbPeelconverges to the solution provided by Batch). We will use datasetsAskubuntu and Sms considering the motifs of (excluding M5and M6 given their high running time). In particular, we start from = 103 and increase it with a step of 5 103 until it reaches 1 andwe execute Batch with each different value of such parameter. Wethen compare each solution obtained by Batch to the optimal solu-tion obtained by Exact. The results are shown in . We see that in general smaller values of correspond to solutions with betterapproximation ratio obtained by Batch. On some instances by vary-ing the solution may vary significantly (e.g., M2 on Askubuntu).In general the algorithm achieves satisfactory approximations onmost configurations for < 0.75, given that for such range thevalue of the solution obtained by Batch is often within 80% of theoptimal solution found with Exact. We also observe that in somesettings the algorithm never outputs solutions with optimal densi-ties (e.g., motif M2, M8 on Askubuntu or M1 on Sms). This supportsthe design of HybridPeel, since for ProbPeel it may often be in-feasible to converge to an optimal solution, as its guarantees arewith respect to Batch (see Theorem 4.2). H.2.2Varying . We show the convergence of the solution ob-tained by ProbPeel to Batchs solution by increasing the samplesize . Recall that we set to a fixed value of for each itera-tion of ProbPeel. For all the motifs of (except M5) and eachmedium-size dataset of we vary the parameter as follows:we select a starting value and compute the approximation ob-tained by ProbPeel on each motif, dataset and (as in ) overfive runs for each value of spanning the range . That is, weincrease at each step starting from by 9/30 so that we computethe solutions over 30 different values of such parameter. We set to 500, 3000, 5000, 2000 for the medium-size datasets of following their order in the table. We only comment some represen-tative behaviors (in ) illustrating possible convergence ratesof ProbPeel over different inputs (motifs and datasets).We first note that, as suggested by Lemma 4.2, as the samplesize increases ProbPeel converges to a solution value close to theone obtained by Batch, and we observe such a behavior across allthe experiments we perform. Additionally, we observe different con-vergence behavior, such as fast convergence (M10 on Askubuntu),convergence to a slightly better solution than with Batch (M3 onWikitalk), alternating solution, i.e., the algorithm switches betweensolution with similar values (M2 on Sms) and slow convergence,i.e., the algorithm requires a large sample to improve the solutionquality (M8 on Wikitalk). These results support the theoretical guar-antees obtained for ProbPeel and that the algorithm achieves tightconvergence in most configurations. But also motivate the designof HybridPeel, combining such results with the one of , thatis ProbPeel may often converge to a sub-optimal density even forsmall .",
  "=2exp(( 1))(9)": "where > 0 controls the temporal decay over the temporal network.The setup is the same as described in .3, where instead ofusing the constant function () that assigns a unitary weight toeach -instance in S , we use the decaying weighting function with = 0.001. As large datasets we will only consider Stackoverflow",
  "Temporal Motif": "Average Runtime (sec) ExactGreedyBatch = 0.3ProbPeel =0.3HybridPeel =0.3 : Results with exponential decaying function as from Equation (9), and = 0.001, on medium and large datasetsfrom . For each configuration we report (top): the quality of the solution compared to the best empirical solution (i.e.,OPT), and (bottom): the running times to achieve such solutions. Overall, the results discussed in this section confirm the findingsof .3 with the small difference that, interestingly, someapproximation algorithms (e.g., Greedy) may slightly decrease theireffectiveness when used with and some other maintain high-quality solutions in output (e.g., HybridPeel on large datasets)compared with the approximation qualities achieved under .",
  ": Approximation ratio of Batch for varying": "and Bitcoin since those are the ones where most algorithms (includ-ing Greedy and Batch) except Exact were able to complete underthe setting of .3 on most of configurations. The results arereported in . We observe that the results follow the trends wediscussed in .3, among the baselines Exact is not able toconclude its execution on challenging configurations (i.e., datasetsand motifs), and Greedy outputs solutions with high approximationratios (often over 0.8), interestingly on some datasets such as Wik-italk and Askubuntu the approximation ratio achieved by Greedy issmaller than the one achieved on the same configurations (dataset,motif and value of ) in .3. This may be caused by thefact that with and = 0.001 the vertices are peeled according tothe weights of instances that are significantly smaller than thoseobtained with . Batch achieves again satisfactory performancesand trading off accuracy for efficiency, especially on large data Sample Size (r) 0.7 0.8 0.9 1.0",
  ": Average approximation factor of ProbPeels solu-tion compared to Batch (i.e., (ProbPeel)/(Batch)), accord-ing to different values of the sample size": "(e.g. on Bitcoin). Again our randomized algorithms in ALDENTE(HybridPeel and ProbPeel) become really efficient and scalableon large datasets saving significant running time on datasets Stack-overflow (e.g., more than 5 faster than Greedy and Batch on M1)and Bitcoin where we have at least a speedup of 2, but more inter-estingly our algorithms scale their computation on hard instanceswhere existing baselines fail to compute a solution. Concerningthe solution quality again ProbPeel matches the approximationquality provided by Batch while being more efficient and scalableon large data as captured by our analysis. And HybridPeel almostalways matches Greedy and Exact, and sometimes also improvesover Greedy (e.g., M3 on Askubuntu) achieving almost optimalresults on most of the motifs considered, being therefore the bestalgorithm in terms of both runtime and approximation quality onmost configurations.",
  "Medium": "M1 M2 M3 M4 M5 M6 M7 M8 M9M10 0.0 0.5 1.0 Sms =172800 =0.001 r=500r=500 M1 M2 M3 M4 M5 M6 M7 M8 M9M10 0.0 0.5 1.0 Facebook =86400 =0.001 r=5000r=5000 M1 M2 M3 M4 M5 M6 M7 M8 M9M10 0.0 0.5 1.0 Askubuntu =172800 =0.001 r=7500r=7500 M1 M2 M3 M4 M5 M6 M7 M8 M9M10 0.0 0.5 1.0 Wikitalk =43200 =0.001 r=10000r=10000",
  "H.4Memory usage": "We measured the peak RAM memory over one single executionof each algorithm on the configurations of .3. We showthe results in recall that the memory limit was set to150 GB on all datasets but EquinixChicago where the limit was set to 200 GB. We do not report data for algorithms that do not finishwithin three hours.Overall, the memory usage of the different algorithms stronglydepends on the temporal motif considered, and in general motifsM1, M2 and M5 require much more memory that other motifs onalmost all datasets. We observe that on such motifs ProbPeel andHybridPeel use much less memory compared to the baselines,saving on M2 more than 100 GB on datasets Stackoverflow andBitcoin and about 90 GB on the Reddit dataset. This is due to thefact that, differently from all other algorithms, our randomizedalgorithms do not store the set H of -CIS (see ). We finallynote the randomized algorithms may use slightly more memorythan the baselines on motifs requiring a small memory usage, sincewe store a copy of the temporal edges of to evaluate the solution",
  "Frequency": "Top K=20 words and their frequency : Histogram associated to the words inside messagescollected on the edges of on the Venmo dataset, for M5and = 172800 (i.e, two days). See .4 for more details,and for a representation of the optimal subnetwork. of the returned vertex set on the original network, and such stepcan be easily be avoided (see .3).These results, coupled with those in .3, show that thealgorithms in ALDENTE, i.e., ProbPeel and HybridPeel, are theonly practical algorithm to obtain high-quality solutions for theTMDS problem on massive networks, requiring a much smalleramount of memory on most of the challenging configurations."
}