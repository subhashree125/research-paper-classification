{
  "ABSTRACT": "Modeling each hit as a multivariate event in racket sports andconducting sequential analysis aids in assessing player/team perfor-mance and identifying successful tactics for coaches and analysts.However, the complex correlations among multiple event attributesrequire pattern mining algorithms to be highly effective and effi-cient. This paper proposes Beep to discover meaningful multivariatepatterns in racket sports. In particular, Beep introduces a new encod-ing scheme to discover patterns with correlations among multipleattributes and high-level tolerances of noise. Moreover, Beep ap-plies an algorithm based on LSH (Locality-Sensitive Hashing) toaccelerate summarizing patterns. We conducted a case study on atable tennis dataset and quantitative experiments on multi-scaledsynthetic datasets to compare Beep with the SOTA multivariatepattern mining algorithm. Results showed that Beep can effectivelydiscover patterns and noises to help analysts gain insights. More-over, Beep was about five times faster than the SOTA algorithm.",
  "Yingcai Wu is the corresponding author": "Permission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full citationon the first page. Copyrights for components of this work owned by others than ACMmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish,to post on servers or to redistribute to lists, requires prior specific permission and/or afee. Request permissions from 2023, Aug 0610, 2023, Long Beach, CA 2023 Association for Computing Machinery.ACM ISBN 978-1-4503-XXXX-X/18/06...$15.00 serving the ball and ending with one player winning a point, con-stitute a multivariate event sequence. Based on such a data model,pattern mining algorithms can discover frequent patterns (shownas ), which can be regarded as players tactics, to help do-main experts in sports obtain insights into players playing stylesand thereby improve their performance. However, in five years ofcollaboration with domain experts in racket sports, we found thatmultivariate event sequences placed high-level requirements onboth effectiveness and efficiency of pattern mining algorithms.Effective pattern mining algorithms can discover patterns thatreveal meaningful information about the sequences. To be effec-tive, a pattern mining algorithm for multivariate event sequencesmust fulfill three conditions: (1) The correlations among multipleattributes within sequences should be preserved for domain analy-sis. For example, in table tennis, a tactical pattern may be that whena player hits the ball to a certain position on the table, the opponentalways uses a specific technique in response. (2) The algorithmshould have a high tolerance for single-value noises (i.e., changeson only one attribute). For example, in table tennis, when a playerapplies a tactical pattern, he/she may only change the technique ofone hit to a similar technique, retaining the overall playing style.(3) The number of returned patterns should be manageable. Giventhat multivariate patterns are complicated, analyzing them is bothtime-consuming and mentally overwhelming.Efficient pattern mining algorithms can mine multivariate pat-terns within an acceptable response time. In practice, the timeallowed for pattern analysis is limited (e.g., one hour). Moreover,some parameters should be adjusted based on the analysts feed-back to satisfy the analysts requirements. Thus, the algorithm isexpected to return the results in several minutes.To the best of our knowledge, existing multivariate pattern min-ing algorithms cannot satisfy these two requirements simultane-ously. Some algorithms transform multivariate sequencesinto univariate ones, such that extracted patterns cannot retain anycorrelations between attributes. Algorithms based on SPM (Sequen-tial Pattern Mining) retain the correlations betweenattributes but usually return an enormous number of patterns ratherthan seeking the most meaningful ones, due to the well-knownproblem of pattern explosion . Algorithms based on MDL (Mini-mum Description Length) summarize a set of patterns to describethe entire sequence dataset instead of searching for each pattern, thus avoiding pattern explosion. However, the currentMDL-based methods have no tailored algorithmic design to handlesingle-value noises in sports and are usually time-consuming.In this paper, we propose Beep, a novel pattern mining algorithmwhich Balances Effectiveness and Efficiency when finding Patternsin racket sports. The contributions are mainly as follows.",
  "PROBLEM FORMULATION": "Beep accepts a multivariate event sequence dataset as input andoutputs a pattern set , demonstrated as .Each sequence is a vector of events, denoted = (1,2, ...,||). All sequences are over the same set of categorical attributes = {1,2, ...,||}. Thus, each event can be considered a vectorof values, denoted = (1 = 1,2 = 2, ...,|| = ||).Each pattern is a subsequence of numerous originalsequences in the dataset , where || indicates the length and ||||indicates the number of non-empty values. For example, in ,four sequences (1 to4) can be summarized by pattern1 (||1|| = 4)and pattern 2 (||2|| = 6). The formal definition of subsequencecan be found in Appendix C. Beep further supports four featuresas follows to obtain informative patterns in real-world datasets. Empty values in a pattern can match any values. For example,in , 2 of 3 in 1 is empty, which matches in 1 and in 4. Empty values allow Beep to tolerate the ever-changingvalues in a pattern, which were less important. Missing values allow patterns to tolerate some noise values insequences. For example, 3 misses 2 of 2 when it is covered by2. Beep considers the possibility (common in real-world data)that the missing value is actually a noise value. Gap events can separate two consecutive events in a patterninto non-consecutive events in sequences. For example, sequence2 has pattern 2, but the gap event 2 of 2 is not captured by2. Beep allows gaps to ignore events that may be noise.",
  "Interleaving patterns overlap over a period of time, e.g.,pattern 1 and 2 are interleaving in 4. Beep allows interleavingpatterns to discover simultaneous patterns": "In practice, domain experts usually expect patterns to be informa-tive (i.e., fewer empty values), authentic (i.e., fewer missing values),and compact (i.e., fewer gaps). Thus, for each pattern , we limit themaximum number of empty values (||), missing values (|||| 10,and at most 1 for each event), and gap events (|| 1). : Examples for constructing candidate patterns.Given two patterns 1 and 2, we construct six candidatepatterns 1 to 6 at different alignments. Candidates 4and 5 demonstrate how we fix a conflict by missing values. 3BEEPIn this section, we introduce our algorithm, Beep, to mine multi-variate patterns in racket sports. Based on the MDL principle ,Beep describes the dataset into two parts i.e., the pattern set andthe description of each sequence based on the pattern set andexpects the minimum description of the two parts (Equation 1).",
  "( | ),(1)": "where ( | ), (), and ( | ) is the description length of dataset based on , pattern set , and sequence based on , respectively(detailed calculation can be found in .2).Inspired by Ditto , Beep optimizes ( | ) iteratively andheuristically. Initially, includes all singleton patterns (i.e., an eventwith only one non-empty value). At each iteration, Beep generates aset of candidate patterns and filters each usefull candidate (i.e., ( | + ) < ( | )). After adding these useful candidatesinto , Beep further filters out each redundant pattern (i.e.,( | ) < ( | )). Beep will not stop until keeps the sameat a certain iteraction, which indicates that approximates theoptimal pattern set with the minimum description length ( | ).The key contribution of Beep lies in three aspects as follows.",
  "Candidates Generation": "Beep constructs complex patterns with simple ones, i.e., combiningeach pair of patterns in at different alignments. For example, in, we list all the candidate patterns (1 to 6) generated basedon multivariate pattern 1 and 2 over three attributes. However,when aligning 2 of 1 and 1 of 2, a conflict exists on value and. We resolve this conflict by regarding it as a missing value of oneof the original patterns. For example, a sequence perfectly matchedby 1 may also be covered by 4 with one missing value.",
  "Description Length Calculation": "The process of calculating description length is shown as ,where we convert pattern set into a code table () and use to encode each sequence into a code stream . We define() and (|) as the digital length of and , respectively.Detailed mathematical calculations can be found in Appendix D.",
  "Beep: Balancing Effectiveness and Efficiency when Finding Multivariate Patterns in Racket SportsKDD 2023, Aug 0610, 2023, Long Beach, CA": ": Examples for explaining the process of encoding.Given sequence and code table , we first obtain cover by describing with the patterns in . We further obtainthe code stream , where is encoded by the codes in . patterns (). For the generate patterns, the code table furtherrecords its gap code (for encoding gap events), fill code (for fillingin the next event in ), and miss code (for encoding missing values).We employ the Huffman coding algorithm to represent eachcode as a distinct binary number according to the frequency it isused to encode the sequences in , in order to ensure that the totaldescription length is minimal. 3.2.2Sequence encoding. Given a code table and a sequence ,we first cover using the patterns in ( in , pseudocodeis in Appendix A). Then, Beep scans each value in in order andpushes the corresponding code to . For example, sequence in is covered by pattern 1, pattern 2 and singleton value .Pattern 1 starts from 1 (the pattern code) and covers 2 and 3(two fill codes), where 2 of 2 is missing (the miss code). Pattern2 starts from 2 (the pattern code), gaps at 3 (the gap code), andcovers 4 and 5 (two fill codes). Singleton occurs at the last. 3.3Algorithm AccelerationDescription length calculation is the most time-consuming step,as it runs for each of thousands of candidates and considers thou-sands of original sequences (see Appendix A for time complexityanalysis). However, a candidate is generated by combining eachtwo patterns. Only when two patterns often occur simultaneouslyor consecutively, the combined candidate is more likely to be afrequent pattern and benefits description length reduction.Thus, we accelerate Beep by filtering out those pairs of patternswith low co-occurrence in advance. For each pattern , we recordthe positions where it occurs when covering the dataset. A positionis an index of a segment of original sequences, where a segmentcontains at most events (default is 20), and a long sequence willbe cut into several segments. Then, we apply weighted LocalitySensitive Hashing (LSH) to examine whether the two patternsoccur in similar sets of positions. If two sets of numbers have aweighted Jaccard similarity larger than a threshold , the weightedLSH algorithm will regard them as the same.",
  "Case Study": "To examine that Beep could discover meaningful patterns (for effec-tiveness), we conducted a case study on a real-world table tennisdataset, with two analysts, each with over three years of experienceanalyzing table tennis data. The dataset collected 716 sequences(average length was 5.91) from 10 matches played in 2019 by ItoMima, one of the top players in the world, against Chinese players.Shown as , the dataset considered four attributes; namely,the technique the player used to hit the ball (Tech), the area wherethe ball impacted the table (Ball), the spin of the ball (Spin), andthe position of the player (Player) (more details can be found inAppendix B). We ran both Ditto and Beep on this dataset andsummarized the results as follows.Beep can summarize a smaller set of informative patternsin shorter time than Ditto. Shown as , Beep summarized62 patterns in 425 seconds, while Ditto summarized 161 ones in1747 seconds. Meanwhile, the patterns summarized by Beep canbe found in more sequences (. . is 12.94), with a reason-able number of missing values (guaranteed the authentication ofpatterns). As a result, Beep reduces the analysis burden of analysts.Beep can find multivariate patterns with tolerances ofsingle-value noises. Shown as , Beep found a multivariatepattern in two sequences 1 and 2. Sequence 1 has a missingvalue at the second hit, where Itos opponent used the technique",
  "KDD 2023, Aug 0610, 2023, Long Beach, CAWu et al": "Smash, Attack, Flick, Twist, Push, Slide, Touch short, Block, Lob, Chop-ping, Pimpled techniques, Other techniques,Ball: The area where the ball hit on the table. There exist 12optional values: Backhand serving, Forehand serving, Short forehand,Half-long forehand, Long forehand, Short backhand, Half-long back-hand, Long backhand, Short middle, Half-long middle, Long middle,Net or edge,Spin: The type of balls spinning. There exist 7 optional values:Strong topspin, Normal topspin, Strong downspin, Normal downspin,No spin, Sink, Without touching,Player: The position of the player. There exist 6 optional values:Backhand serving, Forehand serving, Pivot, Backhand, Forehand, Backturn,",
  "||| |||| |||%(s)||%(s)||%(s)||%(s)||%(s)": "502051001924.5399927.23379927.2334551624.4431924.5380702051001219.09871421.3112151421.31612381218.9291219.0994503051002025.87721326.6284021426.72912762025.91202025.8753502071001527.71040929.130251929.23111411427.7431527.71028502052001724.1175925.339181025.2391491624.1191724.1168 Touch Short, a control technique similar to Push. The analysts be-lieved that summarized 1 well, despite the missing value. Se-quence 2 has a missing value at the third hit, where Ito receivedthe ball at Half-long Backhand, different from Half-long Forehandin . The analysts checked the video and found this value in 2to be recorded incorrectly. If we had instead used the Ditto al-gorithm, these two sequences would have been encoded by othershort patterns and thus unable to reveal these insights.",
  "Quantitative Experiments": "To quantitatively evaluate the performance of Beep, we comparedBeep with Ditto on multi-scaled synthetic data, from the aspectsof the number of summarized patterns, the description length re-duction (both for evaluating effectiveness), and the runtime (forevaluating efficiency), shown as .Given that Beep mainly introduces two improvements namely,the miss codes and the LSH-based acceleration we performed anablation study to evaluate the effects of each improvement. Specif-ically, we considered five algorithms: (1) Ditto, (2) the completeBeep algorithm, (3) Beep-miss (only with miss codes), (4) Beep-LSH(only with LSH-based acceleration), and (5) Beep-none (withoutneither improvements).We construct 5 datasets, varying in terms of the number ofsequences (||), the length of each sequence (| |), the number ofattributes (||), and the number of optional values of each attribute(| |). We further randomly generated 5 patterns and planted themto the datasets, each with 5 non-empty values and a random lengthand covering 10% of the events in the dataset. For each pattern, werandomly chose two occurrences and set one value as a missingvalue for each occurrence, resulting in 10 total missing values.According to our manual check, all five algorithms found all fiveplanted patterns. Meanwhile, Beep-miss and Beep detected all theplanted missing values.Beep and Beep-miss mined a smaller set of patterns withthe highest description length reduction. Comparing Beep-LSH with Beep and comparing Beep-none with Beep-miss, we findthat miss codes can reduce the number of patterns and compressmore information. We believe that miss codes can filter out similarpatterns and preserve only one, leaving a smaller set of meaningfulpatterns. Miss codes also allow for encoding sequences with long patterns with missing values, rather than multiple short patterns,resulting in a short description length.Beep and Beep-LSH had the lowest runtime. ComparingBeep-miss with Beep and comparing Beep-none with Beep-LSH,we found that the LSH-based acceleration substantially reducedruntime but led to more patterns and larger description lengths.In summary, Beep struck a good balance between effec-tiveness and efficiency and outperformed Ditto. Beep bal-anced the strengths of Beep-miss and Beep-LSH, with a nearlybest performance on both information compression and efficiency.Comparing with Ditto, Beep summarized a more refined set ofpatterns (smaller || in most cases) with less runtime (smaller )and a smaller description length (higher %).",
  "CONCLUSION": "In this paper, we propose a novel encoding scheme to describe mul-tivariate patterns in event sequence data. Based on this encodingscheme, we can discover informative patterns that preserve corre-lations among multiple attributes and highlight any single valuenoises in the dataset. To efficiently surface these multivariate pat-terns from the original sequences, we propose Beep, an MDL-basedheuristic algorithm with a tailored acceleration algorithm. Througha case study on a real-world dataset and quantitative experimentson multi-scaled synthetic data, we prove that our algorithm strikesa good balance between effectiveness and efficiency.In the future, we plan to integrate more domain knowledge intoBeep (e.g., encoding domain knowledge as constraints on the pat-terns ) to further enhance its effectiveness. Some subsequencesmay be frequent (thus summarized by the mining algorithm) butcannot reveal players playing styles (thus are not worth analyz-ing). We also plan to use GPU to accelerate Beep to enhance itsefficiency. Note that covering each sequence with the code tablecan be parallel.",
  "Roel Bertens and Arno Siebes. 2014. Characterising seismic data. In Proceedingsof the SIAM International Conference on Data Mining. 884892": "Roel Bertens, Jilles Vreeken, and Arno Siebes. 2016. Keeping it short and simple:Summarising complex event sequences with multivariate patterns. In Proceedingsof the 22nd ACM SIGKDD International Conference on Knowledge Discovery andData Mining. 735744. Yi-Cheng Chen, Ji-Chiang Jiang, Wen-Chih Peng, and Suh-Yin Lee. 2010. Anefficient algorithm for mining time interval-based patterns in large database.In Proceedings of the 19th ACM International Conference on Information andKnowledge Management. 4958.",
  "Sergey Ioffe. 2010. Improved consistent sampling, weighted minhash and l1sketching. In IEEE International Conference on Data Mining. 246255": "Kouki Kawabata, Yasuko Matsubara, and Yasushi Sakurai. 2018. StreamScope:Automatic Pattern Discovery over Data Streams. In Proceedings of the First In-ternational Workshop on Exploiting Artificial Intelligence Techniques for DataManagement. 18. Ji Lan, Jiachen Wang, Xinhuan Shu, Zheng Zhou, Hui Zhang, and Yingcai Wu.2022. RallyComparator: Visual Comparison of the Multivariate and Spatial StrokeSequence in A Table Tennis Rally. Journal of Visualization 25, 1 (2022), 143158.",
  "Jilles Vreeken, Matthijs Van Leeuwen, and Arno Siebes. 2011. Krimp: miningitemsets that compress. Data Mining and Knowledge Discovery 23, 1 (2011),169214": "Jiachen Wang, Jiang Wu, Anqi Cao, Zheng Zhou, Hui Zhang, and Yingcai Wu.2021. Tac-Miner: Visual Tactic Mining for Multiple Table Tennis Matches. IEEETransactions on Visualization and Computer Graphics 27, 6 (2021), 27702782. Jiachen Wang, Kejian Zhao, Dazhen Deng, Anqi Cao, Xiao Xie, Zheng Zhou,Hui Zhang, and Yingcai Wu. 2019. Tac-Simur: Tactic-based Simulative VisualAnalytics of Table Tennis. IEEE Transactions on Visualization and ComputerGraphics 26, 1 (2019), 407417. Cheng-Wei Wu, Yu-Feng Lin, Philip S Yu, and Vincent S Tseng. 2013. Mininghigh utility episodes in complex event sequences. In Proceedings of the 19thACM SIGKDD International Conference on Knowledge Discovery and Data Mining.536544. Jiang Wu, Ziyang Guo, Zuobin Wang, Qingyang Xu, and Yingcai Wu. 2020. Visualanalytics of multivariate event sequence data in racquet sports. In IEEE Conferenceon Visual Analytics Science and Technology (VAST). Jiang Wu, Dongyu Liu, Ziyang Guo, and Yingcai Wu. 2023.RASIPAM: In-teractive Pattern Mining of Multivariate Event Sequences in Racket Sports.IEEE Transactions on Visualization and Computer Graphics 29, 1 (2023), 940950. Jiang Wu, Dongyu Liu, Ziyang Guo, Qingyang Xu, and Yingcai Wu. 2021.TacticFlow: Visual analytics of ever-changing tactics in racket sports. IEEETransactions on Visualization and Computer Graphics 28, 1 (2021), 835845.",
  "ACOVERING ALGORITHM": "Algorithm 1 shows the process of obtaining the optimal cover given a sequence and patterns in . The core idea is to traverseeach pattern in (line 2) and try to cover by (line 3~7) untilall the values in are marked as covered by a pattern (line 8~9).If there exist values not marked (line 10~12), they will be markedas covered by the corresponding singleton patterns in (line13~15). To ensure that the final cover is optimal, we follow theKrimp algorithm and employ a greedy algorithm. We traversethe patterns in in a fixed order (Cover Order): || ||, ( | ), and lexicographically. This order ensures that thepatterns that have more values and higher frequency, which aremore meaningful, will be used first.",
  "return": "This is a time-consuming algorithm, leading to a high cost forcalculating the description length. The first loop (line 2-9) searcheseach pattern in , which is similar to a string matching problem.We employ the well-known KMP algorithm for searching eachpattern, whose time complexity is (|||| + ||||), where |||| and|||| represent the number of values in and , respectively. Thus,the total time complexity of the first loop is (|| |||| + ||||),where || and |||| indicate the total number of patterns and valuesin , respectively. The second loop (line 10-15) traverses each valuein sequence , with a time complexity of (||||). Thus, the timecomplexity of the covering algorithm is (|| |||| + |||| + ||||).As we need to cover each sequence with to calculate thedescription length, the time complexity of the description lengthcalculation is (|| |||| + |||| || + ||||), where || and ||||indicate the total number of sequences and values in , respectively.",
  "CDEFINITION OF SUBSEQUENCE": "This section introduces the formal definition of subsequence in (each pattern is a subsequence of numerous sequencesin ). We introduces the definition in two steps.First, we define to indicate that event preserves someattributes of event and drops others, i.e., is part of (e.g., in, 1 of 1, which drops the first attribute, is part of 1 of 1).Formally, assume that is the set that includes the indexes of allthe attributes to be preserved (i.e., some integers between 1 and||). For each 1 ||, if , has the same -th value as. Otherwise, the -th value of is empty.Second, we define to indicate that sequence = (1, ...,)is a subsequence of sequence = (1, ...,), if there exist integers1 1 2 ... such that for each 1 .",
  "() ,": "where is the set of all patterns in . Considering that | | and() can be zero, we define (0) = 0. For a non-singletonpattern , we encode the number of events, the number of values,the number of gaps, the number of misses, and the first column (i.e.,each value in the pattern) as () = ( | | ) + ( || || )"
}