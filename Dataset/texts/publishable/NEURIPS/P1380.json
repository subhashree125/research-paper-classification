{
  "Abstract": "Circuits based on sum-product structure have become a ubiquitous representationto compactly encode knowledge, from Boolean functions to probability distribu-tions. By imposing constraints on the structure of such circuits, certain inferencequeries become tractable, such as model counting and most probable congura-tion. Recent works have explored analyzing probabilistic and causal inferencequeries as compositions of basic operators to derive tractability conditions. In thispaper, we take an algebraic perspective for compositional inference, and showthat a large class of queriesincluding marginal MAP, probabilistic answer setprogramming inference, and causal backdoor adjustmentcorrespond to a com-bination of basic operators over semirings: aggregation, product, and element-wise mapping. Using this framework, we uncover simple and general sufcientconditions for tractable composition of these operators, in terms of circuit proper-ties (e.g., marginal determinism, compatibility) and conditions on the elementwisemappings. Applying our analysis, we derive novel tractability conditions for manysuch compositional queries. Our results unify tractability conditions for existingproblems on circuits, while providing a blueprint for analysing novel composi-tional inference queries.",
  "Introduction": "Circuit-based representations, such as Boolean circuits, decision diagrams, and arithmetic circuits,are of central importance in many areas of AI and machine learning. For example, a primary meansof performing inference in many models, from Bayesian networks to probabilistic programs, is to convert them into equivalent circuits; this is commonly known as knowledgecompilation. Inference via knowledge compilation has also been used for many applications inneuro-symbolic AI, such as constrained generation and neural logic programming .Circuits can also be learned as probabilistic generative models directly from data ,in which context they are known as probabilistic circuits . Compared with neural generativemodels, probabilistic circuits enjoy tractable evaluation of inference queries such as marginal prob-abilities, which has been used for tasks such as fair machine learning and causal reasoning. The key feature of circuits is that they enable one to precisely characterize tractability conditionsunder which a given inference query can be computed exactly and efciently, in terms of structuralproperties of the circuit. One can then enforce these circuit properties when compiling or learning amodel to enable tractable inference. For many basic inference queries, such as computing a marginalprobability, tractability conditions are well understood . However, for more complex queries,",
  "the situation is less clear, and the exercise of deriving tractability conditions for a given query hasusually been carried out in an instance-specic manner requiring signicant effort": "In , we illustrate two such queries. The marginal MAP (MMAP) query takes a proba-bilistic circuit p and some evidence e and asks for the most likely assignment of a subset of variables.The success probability inference in probabilistic logic programming takes a circuit repre-sentation of a logic program, a weight function and some query q, and computes the probabilityof the query under the programs semantics (MaxEnt, in the example). At rst glance, these seemlike very different queries, involving different types of input circuits (logical and probabilistic), anddifferent types of computations. However, they share similar algebraic structure: logical and prob-abilistic circuits can be interpreted as circuits dened over different semirings, while maximizationand summation can be viewed as aggregation over different semirings. In this paper, inspired bythe compositional atlas for probabilistic circuits , we take a compositional approach to algebraicinference problems, breaking them down into a series of basic operators: aggregation, product, andelementwise mapping. For example, the MMAP and probabilistic logic programming queries in-volve multiple interleaved aggregations and products, along with one elementwise mapping each.Given a circuit algorithm (and associated tractability condition) for each basic operator, we canreuse these algorithms to construct algorithms for arbitrary compositions. The key challenge is thento check if each intermediate circuit satises the requisite tractability conditions. Our contributions can be summarized as follows. We introduce a compositional inference frame-work for algebraic circuits () over arbitrary semirings, generalizing existing results onlogical and probabilistic circuits. In particular, we provide a language for specifying in-ference queries involving different semirings as a composition of basic operators (.1). Wethen prove sufcient conditions for the tractability of each basic operator (.2) and novelconditions for composing such operators (.3). We apply our compositional framework to anumber of inference problems (), showing how our compositional approach leads to moresystematic derivation of tractability conditions and algorithms, and in some cases improved complex-ity analysis. In particular, we discover a tractability hierarchy for inference queries captured underthe 2AMC framework , and reduce the complexity of causal backdoor/frontdoor adjustment onprobabilistic circuits from quadratic/cubic to linear/quadratic respectively.",
  "Preliminaries": "NotationWe use capital letters (e.g., X, Y ) to denote variables and lowercase for assignments(values) of those variables (e.g., x, y). We use boldface to denote sets of variables/assignments (e.g.,X, y) and write Assign(V ) for the set of all assignments to V . Given a variable assignment v ofV , and a subset of variables W V , we write vW to denote the assignment of W correspondingto v.",
  "SemiringsIn this paper, we consider inference problems over commutative semirings. Semiringsare sets closed w.r.t. operators of addition () and multiplication () that satisfy certain properties:": "Denition 1 (Commutative Semiring). A commutative semiring S is a tuple (S, , , 0S, 1S),where and are associative and commutative binary operators on a set S (called the domain)such that distributes over (i.e., a (b c) = (a b) (a c) for all a, b, c S); 0S S isthe additive identity (i.e., 0S a = a for all a S) and annihilates S through multiplication (i.e.,0S a = 0 for all a S); and 1S S is the multiplicative identity (i.e., 1S a = a for all a S). For example, the probability semiring P= (R0, +, , 0, 1) employs standard addition andmultiplication (=+ and =) over the non-negative reals, the (max, ) semiringM = (R0, max, , 0, 1) replaces addition with maximization, while the Boolean semiring B =({, }, , , , ) employs disjunction and conjunction operators ( = and = ) over truthvalues.",
  "Algebraic CircuitsWe now dene the concept of an algebraic circuit, which are computationalgraph-based representations of functions taking values in an arbitrary semiring": "Denition 2 (Algebraic Circuit). Given a semiring S = (S, , , 0S, 1S), an algebraic circuitC over variables V is a rooted directed acyclic graph (DAG), whose nodes have the followingsyntax: ::= l | +ki=1i | ki=1i , where i C are circuit nodes, k N>0 and l : Assign(W ) S is a function over a (possiblyempty) subset W V of variables, called its scope. That is, each circuit node may be an input (l),sum (+), or a product (). The scope of any internal node is dened to be vars() := ki=1vars(i).Each node represents a function p taking values in S, dened recursively by: p(w) ::= l(w) if = l, p(w) ::= ki=1pi(w) if = +ki=1i, and p(w) ::= ki=1pi(w) if ki=1i, where Wis the scope of . The function pC represented by the circuit is dened to be the function of the rootnode. The size |C| of a circuit is dened to be the number of edges in the DAG. For simplicity, we will restrict to circuits with binary products (i.e. k = 2 for products); this canbe enforced with at most a linear increase in size. Prominent examples of algebraic circuits in-clude negation normal forms (NNF) and binary decision diagrams which are over the Booleansemiring and represent Boolean functionsand probabilistic circuits which are over the prob-abilistic semiring and represent probability distributions.1 By imposing simple restrictions on thecircuit, which we call circuit properties, various inference queries that are computationally hard ingeneral become tractable. In particular, smoothness and decomposability ensure tractable marginalinference: Denition 3 (Smoothness, Decomposability). A circuit is smooth if for every sum node = +ii,its children have the same scope: i, j, vars(i) = vars(j). A circuit is decomposable if for everyproduct node = 1 2, its children have disjoint scopes: vars(1) vars(2) = .",
  "suppX() = {x Assign(X vars()) : y Assign(vars() \\ X) s.t. p(x, y) = 0S}": "Denition 5 (X-Determinism). Given a circuit C and a partition (X, Y ) of V , we say that C isX-deterministic if for all sum nodes = +ki=1i, either: (i) vars() X = ; or (ii) suppX(i) suppX(j) = for all i = j. X-determinism refers to a family of properties indexed by sets X. In particular V -determinism isusually referred to simply as determinism. Note that, as dened, scope and support, and thus thesecircuit properties, apply to any semiring: the scope only depends on the variable decompositionof the circuit, while the support only refers to scope and the semiring additive identity 0S. a shows a simple example of a smooth, decomposable, and deterministic circuit that is not X-deterministic, while b shows a smooth, decomposable, and {X1, X2}-deterministic circuit.",
  ": Examples of Algebraic Circuits": "Although these queries appear to involve four different operators, three of them (, max, ) canviewed as an aggregation operation over different semirings. Thus, we begin this section by con-solidating to a simple set of three operators applicable to functions taking values in some semiring:namely, aggregation, product, and elementwise mapping (.1). Equipped with this language for speciying compositional inference queries, we then move on toanalyzing their tractability when the input functions are given as circuits. The thesis of this pa-per is that algebraic structure is often the right level of abstraction to derive useful sufcient (andsometimes necessary) conditions for tractability. We rstly show tractability conditions of each ofthe basic operators (.2), before deriving composability conditions that show how circuitproperties are maintained through operators (.3). This enables us to systematically deriveconditions for the input circuits that enable efcient computation of a compositional inference query.Algorithms and detailed proofs of all theorems can be found in Appendix A.",
  "AggregationGiven a function f : Assign(V ) S, aggregating f over W V returns thefunction f :Assign(Z) S for Z = V \\ W dened by f (z) := w f(z, w)": "For example, aggregation corresponds to forgetting variables W in the Boolean semiring, marginal-izing out W in the probability semiring, and maximizing over assignments in the (max, ) semiring.Next, some queries, such as divergence measures between probability distributions, take two func-tions as inputs, and many others involve combining two or more intermediate results, as is the case inprobabilistic answer set programming inference and causal backdoor/frontdoor queries. We denethe product operator to encapsulate such combination of functions in general.",
  "ProductGiven two functions f :Assign(W ) S and f :Assign(W ) S, the product of f andf is a function f : Assign(V ) S, where V =W W , dened by f (v) := f(vW )f (vW )": "For example, a product corresponds to the conjoin operator in the Boolean semiring, and standardmultiplication in the probability semiring. Lastly, we introduce the elementwise mapping operator,dened by a mapping from a semiring to a (possibly different) semiring. When applied to afunction f, it returns the function composition f. This is the key piece that distinguishes ourframework from prior analysis of sum-of-product queries over specic semirings, allowing us toexpress queries such as causal inference and probabilistic logic programming inference under thesame framework. Elementwise MappingGiven a function f : Assign(V ) S and a mapping : S S fromsemiring S to S satisfying (0S) = 0S, an elementwise mapping of f by results in a functionf : Assign(V ) S dened by f (v) := (f(v)).2 In practice, we use elementwise mappings as an abstraction predominantly for two purposes. Therst is for switching between semirings, while the second is to map between elements of the samesemiring. For the former, one of the most important elementwise mappings we will consider is thesupport mapping, which maps between any two semirings as follows.",
  "Tractability Conditions for Basic Operators": "We now consider the tractability of applying each basic operation to circuits: that is, computinga circuit whose function corresponds to the result of applying the operation to the functions givenby the input circuit(s). First, it is well known that forgetting and marginalization of any subset ofvariables can be performed in polynomial time if the input circuits in the respective semirings (NNFand PC) are smooth and decomposable . This can be generalized to arbitrary semirings: Theorem 1 (Tractable Aggregation). Let C be a smooth and decomposable circuit representing afunction p : Assign(V ) S. Then for any W V , it is possible to compute the aggregate as asmooth and decomposable circuit C (i.e., pC(Z) = w pC(Z, w)) in O(|C|) time and space. Next, let us consider the product operator. In the Boolean circuits literature, it is well known thatthe conjoin operator can be applied tractably if the circuits both follow a common structure knownas a vtree . In a more general property known as compatibility was introduced that directlyspecies conditions with respect to two (probabilistic) circuits, without reference to a vtree. Wenow dene a generalization of this property (X-compatibility) and also identify a new condition(X-support-compatibility) that enables tractable products.Denition 7 (X-Compatibility). Given two smooth and decomposable circuits C, C over variablesV , V respectively, and a variable set X V V , we say that C, C are X-compatible if forevery product node = 12 C and = 12 C such that vars()X = vars()X,the scope is partitioned in the same way, i.e. vars(1) X = vars(1) X and vars(2) X =vars(2) X. We say that C, C are compatible if they are (V V )-compatible. Intuitively, compatibility states that the scopes of the circuits decompose in the same way at productnodes. Compatibility of two circuits sufces to be able to tractably compute their product:Theorem 2 (Tractable Product - Compatibility). Let C, C be compatible circuits over variablesV , V , respectively, and the same semiring. Then it is possible to compute their product as a circuitC compatible with them (i.e., pC(V V ) = pC(V ) pC(V )) in O(|C||C|) time and space.",
  "We remark that if we are given a fully factorized function f(V ) =": "ViV fi(Vi), this can be ar-ranged as a circuit (series of binary products) compatible with any other decomposable circuit; thus,we say this type of function is omni-compatible. We also say that a circuit is structured decompos-able if it is compatible with itself. Now, our more general denition of X-compatibility states thatthe scopes of the circuits restricted to X decompose in the same way at product nodes. This willbe important when we consider composing products with other operators, such as aggregation. Thefollowing result shows that compatibility w.r.t. a subset is a weaker condition:",
  "Proposition 1 (Properties of X-Compatibility). If two circuits C, C are X-compatible, then theyare X-compatible for any subset X X": "Compatibility is a sufcient but not necessary condition for tractable products.Some non-compatible circuits can be efciently restructured to be compatible . Alternatively, it is alsoknown that some circuits can be multiplied with themselves in linear time, even when they arenot structured decomposable . We formalize this idea with a new property which we callsupport-compatibility.Denition 8 (X-Support Compatibility). Given two smooth and decomposable circuits C, C overvariables V , V respectively, and a set of variables X V V , let C[X], C[X] be the DAGsobtained by restricting to nodes with scope overlapping with X. We say that C, C are X-support-compatible if there is an isomorphism between C[X], C[X] such that: (i) for any node C[X],vars() X = vars(()) X; (ii) for any sum node C[X], suppX(i) suppX((j)) = whenever i = j. We say that C, C are support-compatible if they are (V V )-support-compatible. To unpack this denition, we note that any smooth, decomposable, and X-deterministic circuit isX-support-compatible with itself, with the obvious isomorphism. However, this property is moregeneral in that it allows for circuits over different sets of variables and does not require that the nodesrepresent exactly the same function; merely that the sum nodes have compatible support decom-positions. As we will later see, the signicance of this property is that it can be often maintainedthrough applications of operators, making it useful for compositions.Theorem 3 (Tractable Product - Support Compatibility). Let C, C be support-compatible circuitsover variables V , V , respectively, and the same semiring. Then, given the isomorphism , it ispossible to compute their product as a smooth and decomposable circuit C support-compatiblewith them (i.e., pC(V V ) = pC(V ) pC(V )) in O(max(|C|, |C|)) time and space. We now examine the tractability of general elementwise mappings : S S on a circuit C. It istempting here to simply construct a new circuit C over the semiring S with the same structure as C,and replace each input function l in the circuit with (l). However, the resulting circuit pC(V ) is notguaranteed to correctly compute (pC(V )) in general. For example, consider the support mappingBSwhich maps to 0S and to 1S for the probability semiring S = (R0, +, , 0, 1).Then the transformation of the smooth and decomposable circuit C = X X produces C =1X=1 + 1X=1, which evaluates to pC(X = 1) = 2 whereas (pC(X = 1)) = 1. In order for thissimple algorithm to be correct, we need to impose certain conditions on the elementwise mapping and/or the circuit C it is being applied to.Theorem 4 (Tractable Mapping). Let C be a smooth and decomposable circuit over semiring S,and : S S a mapping such that (0S) = 0S. Then it is possible to compute the mapping ofC by as a smooth and decomposable circuit C (i.e., pC(V ) = (pC(V ))) in O(|C|) time andspace if distributes over sums and",
  "distributes over sums if: either (Additive) is an additive homomorphism, i.e. (a b) =(a) (b); or (Det) C is deterministic": "distributes over products if: either (Multiplicative) is an multiplicative homomorphism, i.e.(ab) = (a)(b); or (Prod 0/1) (1S) = 1S, and for all product nodes = 12 C, andfor every value v Assign(vars()), either p1(vvars(1)) {0S, 1S} or p2(vvars(2)) {0S, 1S}. We can apply Theorem 4 to immediately derive the following property of support mappings:Corollary 1 (Support Mapping). Given a circuit C over a semiring S and any target semiring S,a circuit representing pCSS can be computed tractably if (i) S satises a b = 0S = a =b = 0S and S is idempotent (i.e., 1S 1S = 1S), or (ii) C is deterministic. Proof. First note that SS satises (Multiplicative), and thus distributes over products. If (i)holds, consider abSS. If a = b = 0S, then this is equal to 0SSS = aSS +bSS =0S; otherwise a, b, a b = 0S and a bSS = aSS bSS = 1S (by idempotence ofS). Thus SS satises (Additive). Alternatively, if (ii) holds, then (Det) holds. In either caseSS distributes over sums in the circuit. The following examples illustrate the generality of elementwise mappings and Theorem 4:Example 2 (Partition Function and MPE). Given a probability distribution p(V ), consider thetask of computing the partition function v p(v) and MPE maxv p(v). These can be viewed asaggregations over the probability and (max, ) semirings respectively.",
  "Elem.MappingSm, Dec,(Add/Det),(Mult/Prod01)X-DetX-Cmp w/ CotherX-SCmp w/ CotherO(|C|) (A.3)": "p is often either a probabilistic circuit Cprob, or a combination of a Boolean circuit Cbool and weightsw (in weighted model counting). In the former case, the partition function is tractable because thecircuit is already over the probability semiring, while in the latter case, MPE is tractable because theS = (max, ) semiring is idempotent so CboolBS is tractable. On the other hand, the partitionfunction for Boolean circuits and MPE for PCs require determinism for the conditions of Theorem4 to hold; in fact, these problems are known to be NP-hard without determinism .Example 3 (Power Function in Probability Semiring). For the probability semiring S = S =",
  "mapping satises (Multiplicative), and is tractable if we enforce (Det) on the circuit": "It is worth noting that semiring homomorphisms (i.e.additive and multiplicative) are alwaystractable. In the case when S = S = P, it was shown in that the only such mapping isthe identity function. However this is not the case for other semirings: the power function is anexample in the (max, ) semiring. To summarize, we have shown sufcient tractability conditionsfor aggeregation, products, and elementwise mappings. Notice that the conditions for aggregationand products only depend on variable scopes and supports, and as such apply to any semiring; incontrast, for elementwise mappings, we take advantage of specic properties of the semiring(s) inquestion.",
  "Tractable Composition of Operators": "We now analyze compositions of these basic operators. As such, we need to consider not only circuitproperties that enable tractability, but how these properties are maintained through each operator,so that the output circuit can be used as input to another operator. We call these composabilityconditions. In all cases, the output circuit is smooth and decomposable. Thus, we focus on theproperties of X-determinism, X-compatibility, and X-support-compatibility. We emphasize thatthese are not singular properties, but rather families of properties indexed by a variable set X. Wepresent the intuitive ideas behind our results below, while deferring full proofs to the Appendix.Theorem 5 (Composability Conditions). The results in hold. X-determinismIntuitively, X-determinism is maintained through products because the resultingsum nodes partition the X-support in a \"ner\" way to the original circuits, and through elementwisemappings since they do not expand the support of any node (since (0S) = 0S). For aggregation,the X-support is maintained if aggregation does not occur over any of the variables in X. X-compatibilityHere, we are interested in the following question: if the input circuit(s) to someoperator are X-compatible with some other circuit Cother for any xed X, is the same true of theoutput of the operator? X-compatibility with Cother is maintained through aggregation because itweakens the condition (by Proposition 1) and through elementwise mapping as it does not changevariable scopes. As for taking the product of circuits, the output circuit will maintain similar vari-able partitionings at products, such that it remains X-compatible with Cother. Notably, this resultdoes not hold for compatibility where the scope X may be different for each pair of circuits underconsideration; we show a counterexample in Example 4 in the Appendix.",
  "OtherMFESm, Dec, H-Det, I-Det, (H I)-DetO(|C|)Reverse-MAPSm, Dec, X-DetO(|C|)": "X-support-compatibilityX-support-compatibility is maintained through elementwise map-pings and aggregation (except on X) for similar reasons to X-determinism. For products, the resultretains a similar X-support structure, so X-support compatibility is maintained. We conclude by remarking that, once we determine that a compositional query is tractable, thenone immediately obtains a correct algorithm for computing the query by application of the genericalgorithms for aggregation, product, and elementwise mapping (see Appendix A). An upper boundon the complexity (attained by the algorithm) is also given by considering the complexities of eachindividual operator; in particular, the algorithm is polytime for a bounded number of operators.",
  "Case Studies": "In this section, we apply our compositional framework to analyze the tractability of several differentproblems involving circuits found in the literature (). Some of the results are known, butcan now be cast in a general framework (with often simpler proofs). We also present new results,deriving tractability conditions that are less restrictive than reported in existing literature.",
  "Algebraic Model Counting": "In algebraic model counting (a generalization of weighted model counting), one is given aBoolean function (V ), and a fully-factorized labeling function (V ) = ViV i(Vi) in somesemiring S, and the goal is to aggregate these labels for all satisfying assignments of . This canbe easily cast in our framework as v((v))BS (v). Here, the support mapping BStransfers the Boolean function to the semiring S over which aggregation occurs. Assuming that(V ) is given as a smooth and decomposable Boolean circuit (DNNF), then by Corollary 1 AMCis tractable if S is idempotent or if the circuit is additionally deterministic (note that (V ) is omni-compatible, so the product is tractable); this matches the results of . 2AMCA recent generalization of algebraic model counting is the 2AMC (second-level algebraicmodel counting) problem , which encompasses a number of important bilevel inference prob-lems such as marginal MAP and inference in probabilistic answer set programs. Given a partitionof the variables V = (X, Y ), a Boolean function (X, Y ), outer and inner semirings SX, SY ,labeling functions Y (Y ) = YiY Y ,i(Yi) over SY and X(X) = XiX X,i(Xi) overSX, and an elementwise mapping SY SX : SY SX, the 2AMC problem is given by:",
  "To tackle this type of bilevel inference problem, identied a circuit property called X-rstness": "Denition 9 (X-Firstness). Suppose C is a circuit over variables V and (X, Y ) a partition of V .We say that a node C is X-only if vars() X, Y -only if vars() Y , and mixed otherwise.Then we say that C is X-rst if for all product nodes = 1 2, we have that either: (i) each iis X-only or Y -only; (ii) or exactly one i is mixed, and the other is X-only.",
  ": Failure case of 2AMC algorithm on smooth, decomposable, X-rst circuit": "It was stated in that smoothness, decomposability, determinism, and X-rstness sufce to en-sure tractable computation of 2AMC problems, by simply evaluating the circuit in the given semir-ings (caching values if necessary). We now show that this is neither sufcient nor necessary ingeneral. To build intuition, consider the simple NNF circuit (X, Y ) = (X Y ) (X Y ).Note that trivially satises X-rstness and is smooth, decomposable, and deterministic. Let S bethe probability semiring, S be the (max, )-semiring, labeling functions be (y) = (y) = 1,(x) = (x) = 1, and the mapping function be the identity (a) = a. Then, noting thatthe labels are the multiplicative identity 1, the 2AMC value is maxX (Y (X, Y )BS) =max((x, y)BS + (x, y)BS), ((x, y)BS + (x, y)BS)= max(1 +1), (0)= 2. On the other hand, the algorithm of returns the value 2AMC = 1, as shown in. This is not just a aw in the specic evaluation algorithm, but rather a provable intractabil-ity of the problem given these properties:",
  "Theorem 8 (Tractability Conditions for 2AMC). Every 2AMC instance is tractable in O(|C|) timefor Boolean circuits that are smooth, decomposable, deterministic, X-rst, and X-deterministic": "Proof sketch. The key point to notice is that the elementwise mapping relative to the transformationof inner to outer semiring operates over an aggregation of an X-rst and X-deterministic circuit,obtained by the product of a Boolean function (mapped to the inner semiring by a support mapping)and a weight function of Y . Hence, it satises (Det) and (Prod 0/1): all of the X-only children of aproduct node are 0/1 valued (in the inner semiring). For specic instances of 2AMC, depending on the semirings S, S and mapping function , wealso nd that it is possible to remove the requirement of X-rstness or determinism, as we summa-rize in . One might thus wonder if there is a difference in terms of compactness betweenrequiring X-determinism and X-rstness, as opposed to X-determinism alone. For example, forsentential decision diagrams (SDD) , a popular knowledge compilation target, these notionscoincide: a SDD is X-deterministic iff it is X-rst (in which context this property is known asX-constrainedness ). However, as shown in b, there exist X-deterministic but notX-rst circuits. We now show that X-deterministic circuits can be exponentially more succinctthan X-deterministic circuits that are additionally X-rst, as the size of X grows.3 Theorem 9 (Exponential Separation). Given sets of variables X={X1, ..., Xn}, Y={Y1, ..., Yn}, there exists a smooth, decomposable and X-deterministic circuit C of size poly(n)such that the smallest smooth, decomposable, and X-rst circuit C such that pC pC has size2(n). Thus, to summarize, some instances of 2AMC can be solved efciently when is smooth, decom-posable and X-deterministic. A larger number of instances can be solved when additionally, isdeterministic; and all 2AMC problems are tractable if we also impose X-rstness.",
  "Causal Inference": "In causal inference, one is often interested in computing interventional distributions, denoted usingthe do() operator, as a function of the observed distribution p. This function depends on the causalgraph linking the variables, and can be derived using the do-calculus . For example, the well-known backdoor and frontdoor graphs induce the following formulae:",
  "xp(x)p(y|x, z).(3)": "Assuming that the observed joint distribution p(X, Y , Z) is given as a probabilistic circuit C, weconsider the problem of obtaining a probabilistic circuit C over variables X Y representingp(Y |do(X)). Tractability conditions for the backdoor/frontdoor cases were derived by , withquadratic/cubic complexity respectively. However, we observe that in some cases we can avoidthe requirement of structured decomposability and/or obtain reduced complexity relative to theirndings.",
  "where V = (X, Y , Z), and 1(a) =a1if a = 00if a = 0. Assuming (XZ)-determinism and struc-": "tured decomposability, then 1y p(V )is tractable by (Det) and (Multiplicative), the productp(V ) 1y p(V )by support-compatibility, and the nal product by compatibility. How-ever, if we additionally have Z-determinism, then the nal product becomes tractable by supportcompatibility. This has linear rather than quadratic complexity, and does not require the circuit tobe structured decomposable. In the frontdoor case, showed that X-determinism, (X Z)-determinism, and structured decomposability sufces for cubic complexity. However, we note thatunder such conditions, the inner product p(X) p(Y |X, Z) is tractable by support-compatibility.As such, the complexity of this query is actually quadratic rather than cubic as previously shown.We summarize our ndings in and refer the reader to the Appendix for full proofs.",
  "Related Work": "Our work builds upon the observation that many inference problems can be characterized as a com-position of basic operators. Prior works have considered compositional inference for circuits in theBoolean and probabilistic semirings , deriving tractability conditions for operators spe-cic to these semirings. Aside from generalizing to arbitrary semirings, we also introduce extendedcomposability conditions that enable interleaving of aggregation, products, and mappings. Mean-while, algebraic model counting deals (implicitly) with mappings from the Boolean semiringto an arbitrary semiring, but does not consider compositional queries. Closest to our work, con-sider a generalization of algebraic model counting that allows for an additional semiring translation;however, this still assumes input Boolean circuits and has incomplete tractability characterizations.Our framework resolves these limitations, permitting arbitrary compositional queries over semirings. Many works have considered (unbounded) sums-of-products queries on arbitrary semirings , encompassing many important problems such as constraint satisfaction problems , graphicalmodel inference , and database queries , which are often computationally hard in the worst-case. Algorithms for such queries often utilize compact intermediate representations and/or assumecompact input representations, such as circuits . Our framework focuses on querieswhere the number of operators is bounded, and characterizes conditions under which inference istractable in polynomial time. It also includes elementwise mappings as a key additional abstractionthat can be used to express queries involving more than sums and products.",
  "Conclusion": "In summary, we have introduced a framework for analysing compositional inference problems oncircuits, based on algebraic structure. In doing so, we were able to derive new tractability conditionsand simplied algorithms for a number of existing problems, including 2AMC and causal inference.Our framework focuses on simple and composable sufcient tractability conditions for aggregations,products and elementwise mappings operators; a limitation of this generality is these conditions maynot be necessary for specic queries on specic semirings. Our work motivates the development ofknowledge compilation and learning algorithms that target the requisite circuit properties, such asX-determinism. Finally, while we focus on exact inference, for many problems (e.g. marginalMAP) approximate algorithms exist and are of signicant interest; an interesting direction for futurework is to investigate if these can be also be generalized using the compositional approach.",
  "Acknowledgements": "We thank Antonio Vergari for helpful discussions, and acknowledge him for proposing an early ver-sion of support compatibility and Theorem 3, and for pointing out a potential reduction in complexityfor the causal inference queries. This work was done in part while the authors were visiting the Si-mons Institute for the Theory of Computing. This work was funded in part by the DARPA ANSRprogram under award FA8750-23-2-0004,the DARPA PTG Program under award HR00112220005,and NSF grant #IIS-1943641. DM received generous support from the IBM Corporation, the Centerfor Articial Intelligence at University of So Paulo (C4AI-USP), the So Paulo Research Founda-tion (FAPESP grants #2019/07665-4 and 2022/02937-9), the Brazilian National Research Council(CNPq grant no. 305136/2022-4) and CAPES (Finance Code 001). YC was partially supported bya gift from Cisco University Research Program.",
  "YooJung Choi, Antonio Vergari, and Guy Van den Broeck. Probabilistic circuits: A unifyingframework for tractable probabilistic models. arXiv preprint, 2020": "YooJung Choi, Meihua Dang, and Guy Van den Broeck. Group fairness by probabilistic model-ing with latent fair decisions. In Proceedings of the AAAI Conference on Articial Intelligence,volume 35, pages 1205112059, 2021. YooJung Choi, Tal Friedman, and Guy Van den Broeck. Solving marginal map exactly byprobabilistic circuit transformations. In Proceedings of the 25th International Conference onArticial Intelligence and Statistics (AISTATS), 2022.",
  "Haiying Huang and Adnan Darwiche. Causal unit selection using tractable arithmetic circuits.arXiv preprint arXiv:2404.06681, 2024": "Jiani Huang, Ziyang Li, Binghong Chen, Karan Samel, Mayur Naik, Le Song, and Xujie Si.Scallop: From probabilistic deductive databases to scalable differentiable reasoning. Advancesin Neural Information Processing Systems, 34:2513425145, 2021. Rafael Kiesel, Pietro Totis, and Angelika Kimmig. Efcient knowledge compilation beyondweighted model counting. In Proceedings of the 38th International Conference on Logic Pro-gramming (ICLP 2022), 2022.",
  "Judea Pearl. Causal diagrams for empirical research. Biometrika, 82(4):669688, 1995": "Robert Peharz, Robert Gens, Franz Pernkopf, and Pedro Domingos. On the latent variableinterpretation in sum-product networks. IEEE transactions on pattern analysis and machineintelligence, 39(10):20302044, 2016. Robert Peharz, Antonio Vergari, Karl Stelzner, Alejandro Molina, Xiaoting Shao, MartinTrapp, Kristian Kersting, and Zoubin Ghahramani. Random sum-product networks: A simpleand effective approach to probabilistic deep learning. In Uncertainty in Articial Intelligence,pages 334344. PMLR, 2020. Tahrima Rahman, Prasanna Kothalkar, and Vibhav Gogate.Cutset networks: A simple,tractable, and scalable approach for improving the accuracy of chow-liu trees. In MachineLearning and Knowledge Discovery in Databases: European Conference, ECML PKDD 2014,Nancy, France, September 15-19, 2014. Proceedings, Part II 14, pages 630645. Springer,2014.",
  "Leslie G Valiant. The complexity of enumeration and reliability problems. SIAM Journal onComputing, 8(3):410421, 1979": "Guy Van den Broeck, Anton Lykov, Maximilian Schleich, and Dan Suciu. On the tractabilityof shap explanations. In Proceedings of the 35th AAAI International Conference on ArticialIntelligence and Statistics (AAAI 2021), 2021. Antonio Vergari, YooJung Choi, Anji Liu, Stefano Teso, and Guy den Broeck. A Composi-tional Atlas of Tractable Circuit Operations for Probabilistic Inference. In Advances in NeuralInformation Processing Systems, volume 34, pages 1318913201, 2021. Benjie Wang and Marta Kwiatkowska. Compositional probabilistic and causal inference usingtractable circuit models. In Proceedings of the 26th International Conference on ArticialIntelligence and Statistics (AISTATS), pages 94889498. PMLR, 2023.",
  "Mihalis Yannakakis. Algorithms for acyclic database schemes. In VLDB, volume 81, pages8294, 1981": "Matej Zecevic, Devendra Dhami, Athresh Karanam, Sriraam Natarajan, and Kristian Kersting.Interventional sum-product networks: Causal inference with tractable probabilistic models.Advances in neural information processing systems, 34:1501915031, 2021. Honghua Zhang, Meihua Dang, Nanyun Peng, and Guy Van den Broeck. Tractable control forautoregressive language generation. In Proceedings of the 40th International Conference onMachine Learning (ICML), jul 2023.",
  "A.1Tractable Aggregation": "Theorem 1 (Tractable Aggregation). Let C be a smooth and decomposable circuit representing afunction p : Assign(V ) S. Then for any W V , it is possible to compute the aggregate as asmooth and decomposable circuit C (i.e., pC(Z) = w pC(Z, w)) in O(|C|) time and space. Proof. We prove this inductively, starting from the input nodes of the circuit. Our claim is that foreach node C, AGG(; W ) (Algorithm 1) returns a node with scope vars() = vars() \\ Wsuch that p(vars()) =",
  "= pAGG(1;W vars(1))(vars(1) \\ W ) pAGG(2;W vars(2))(vars(2) \\ W )": "The second equality follows by the partition (and associativity of the addition and multiplication),while the third follows by distributivity of multiplication over addition. In the case where vars() =W (Lines 3-4), then pAGG(i;W vars(i))(vars(i)) is just a scalar for each i, so we can directlyperform this computation, returning a new scalar node . Otherwise (Lines 5-6), we construct anew product node = 1 2 = AGG(1; W vars(1)) AGG(2; W vars(2)). By theinductive hypothesis, i has scope vars(i) = vars(i) \\ W , so is clearly decomposable and hasscope vars() = (vars(1) \\ W ) (vars(2) \\ W ) = vars() \\ W .",
  "i=1pAGG(i;W )(vars(i))": "In the case where vars() = W (Lines 3-4), then pAGG(i;W )(vars(i)) is just a scalar, so wecan directly perform this computation, returning a new scalar node . Otherwise (Lines 5-6), weconstruct a new sum node = +ki=1i = +ki=1AGG(i; W ). By the inductive hypothesis, each ihas scope vars(i) \\ W = vars() \\ W , so is smooth and also has scope vars() \\ W .",
  "A.2.1Tractable Product with Compatibility": "Theorem 2 (Tractable Product - Compatibility). Let C, C be compatible circuits over variablesV , V , respectively, and the same semiring. Then it is possible to compute their product as a circuitC compatible with them (i.e., pC(V V ) = pC(V ) pC(V )) in O(|C||C|) time and space. Proof. We prove this inductively bottom up, for nodes C, C such that vars() (V V ) = vars() (V V ). Our claim is that PROD-SCMP(, ) (Algorithm 2) returns a node such that p = p p, has scope vars() = vars() vars(), and is decomposable (ifproduct) and smooth (if sum). If vars()vars() = (i.e. vars()(V V ) = vars()(V V ) is empty), then the algorithm(Lines 1-2) simply constructs a new product node = . By denition, p = p p, hasscope vars() = vars() vars(), and is decomposable.",
  "vars() vars(), so smoothness is retained": "If = 12, = 12 are product nodes such that vars()(V V ) = vars()(V V ) isnon-empty, then writing X := V V , by compatibility we also have vars(1)X = vars(1)Xand vars(2)X = vars(2)X, so we can apply the inductive hypothesis for PROD-CMP(1, 1)and PROD-CMP(2, 2). Algorithm 2 constructs a new product node = PROD-CMP(1, 1) PROD-CMP(2, 2). To show that this is decomposable, we need the following lemma: Lemma 1 (Decomposability of Product). Suppose C, C are decomposable product nodeswhich decompose in the same way over X, i.e. vars(1) X = vars(1) X and vars(2) X =vars(2) X. Then (vars(1) vars(1)) (vars(2) vars(2)) = .",
  "= (vars(1) vars(2)) (vars(1) vars(2)) (vars(1) vars(2)) (vars(2) vars(1))": "Note that the rst two intersections are empty due to decomposability of , . For the third inter-section (vars(1) vars(2)), any variable in this intersection must be in the common variablesX. But we know that vars(2) X = vars(2) X in both cases above; by decomposability,(vars(2) X) (vars(1) X) = . Thus the third intersection is also empty; a similar argumentapplies for the fourth. Applying this Lemma, we see that is decomposable as vars(PROD-CMP(1, 1)) = (vars(1) vars(1)) and vars(PROD-CMP(2, 2)) = (vars(2) vars(2)). We can also verify that p =pPROD-CMP(1,1) pPROD-CMP(2,2) = p1 p1 p2 p2 = p p by the inductive hypothesis,and associativity of . If = +ki=1i, = +ki=1i are sum nodes, then the algorithm produces a new sum node =+ki=1 +kj=1 PROD-CMP(i, j) (Lines 7-8). This computes the correct function as p = ki=1 kj=1PROD-CMP(i, j) = ki=1 kj=1 pipj = (ki=1pi) (kj=1pj) = p p. It also retainssmoothness.",
  "A.2.2Linear-time Product with Support Comptibility": "Theorem 3 (Tractable Product - Support Compatibility). Let C, C be support-compatible circuitsover variables V , V , respectively, and the same semiring. Then, given the isomorphism , it ispossible to compute their product as a smooth and decomposable circuit C support-compatiblewith them (i.e., pC(V V ) = pC(V ) pC(V )) in O(max(|C|, |C|)) time and space. Proof. We prove this inductively bottom up, for nodes C such that C either satises = () or vars() vars() = . Our claim is that PROD-SCMP(, ) (Algorithm 3) returns anode such that p = p p, has scope vars() = vars() vars(), and is decomposable(if product) and smooth (if sum).",
  "If the , are input nodes, then we can construct a new input node satisfying the requisiteproperties (Lines 3-4)": "If = 1 2, = 1 2 are product nodes and () = , then the Algorithm (Lines 5-6)constructs a product node = PROD-SCMP(1, 1) PROD-SCMP(2, 2). Dene X = V V .By support compatibility (i.e. X-support compatibility), , are part of the restricted circuitsC[X], C[X] respectively and so vars() X = , vars() X = . There are two casesto consider; we rst show that in both of these cases, we can apply the inductive hypothesis toPROD-SCMP(1, 1) and PROD-SCMP(2, 2). Firstly, suppose that both 1 and 2 have scope overlapping with X. Then by the isomor-phism, we have 1 = (1), 2 = (2). By the denition of support compatibility, thisalso means vars(1)X = vars(1)X and vars(2)X = vars(2)X and these areboth non-empty; thus we can apply the inductive hypothesis for PROD-SCMP(1, 1) andPROD-SCMP(2, 2). Second, suppose instead that only 1 has scope overlapping with X, and so vars(2)X =. Then 1 = (1) and vars(1) X = vars(1) X = vars() X = vars() X.Since vars(2) = vars() \\ vars(1), it follows that vars(2) X = (vars() X) \\(vars(1) X) = , i.e. 2 also does not have scope overlapping with X. Since X arethe shared variables V , V , it follows that vars(2) vars(2) = , and so we can applythe inductive hypothesis for PROD-SCMP(2, 2) (and for PROD-SCMP(1, 1)). Bytheinductivehypothesis,PROD-SCMP(1, 1)hasscopevars(1) vars(1)andPROD-SCMP(2, 2) has scope vars(2) vars(2).We can thus apply Lemma 1.ThusPROD-SCMP(1, 1) and PROD-SCMP(2, 2) have disjoint scopes and is decomposable. We",
  "can also verify that p = pPROD-SCMP(1,1) pPROD-SCMP(2,2) = p1 p1 p2 p2 = p pby the inductive hypothesis, and associativity of": "If = +ki=1i, = +ki=1i are sum nodes and () = , then by smoothness, all of the childrenof have the same support and all the children of have the same support; thus all the childrenare in C[X], C[X] respectively, k = k, and (i) = i. By support compatibility, we also that (i)vars(i) X = vars(j) X for all i, j; and (ii) that suppX(i) suppX(j) for i = j.",
  "suppX(j) = {x Assign(X vars(j)) : y Assign(vars(j) \\ X) s.t. pj(x, y) = 0S}": "Since X vars(i) = X vars(j) and is nonempty, by (ii) we know that there is no assignmentof X vars(i) such that pi and pj can be simultaneously not equal to 0S. Thus there is noassignment of X vars(i) such that pi pj is not 0S, since 0S is the multiplicative annihilator.",
  "i=1PROD-SCMP(i, i)": "The second equality follows by the Lemma and the fact that 0S is the additive identity, and thethird equality by the inductive hypothesis. Thus = +ki=1PROD-SCMP(i, i) computes the cor-rect function (Lines 7-8). We conclude by noting that vars() = ki=1(vars(i) vars(i)) =ki=1 vars(i) ki=1 vars(i) = vars() vars(). The complexity of this procedure applied to the root nodes is O(max(|C|, |C|), as we only performrecursive calls for (i) C[X] and its corresponding node = () and (ii) nodes with non-overlapping scope, upon which the recursion ends; so the overall number of recursive calls is linearin the size of the circuits.",
  "A.3Tractable Elementwise Mapping": "Theorem 4 (Tractable Mapping). Let C be a smooth and decomposable circuit over semiring S,and : S S a mapping such that (0S) = 0S. Then it is possible to compute the mapping ofC by as a smooth and decomposable circuit C (i.e., pC(V ) = (pC(V ))) in O(|C|) time andspace if distributes over sums and",
  "X-determinismSuppose that circuit C is X-deterministic; that is, for any sum node =+ki=1i C, either (i) vars() X = , or else (ii) suppX(i) suppX(j) = for all i = j": "(5.1) Consider aggregating with respect to a set of variables W such that W X = . Accordingto Algorithm 1 and the proof of Theorem 1, this produces an output circuit where each node corresponds to some node in the original circuit, such that p = wvars() p and with scopevars() \\ W . In particular, for sum nodes = +ki=1i C, either vars() W , in which case is an input node (and X-determinism is not applicable), or else = +ki=1i is also a sum node,where each i corresponds to i. If (i) vars() X = , then vars() X = also. If (ii) suppX(i) suppX(j) = for all i = j, we claim that suppX(i) suppX(i) forall i. To see this, rst note that by smoothness, vars(i) = vars(j) = vars(). Suppose thatxi Assign(X vars()) satises x suppX(i). Then there exists yi Assign(vars() \\ X)such that pi(xi, yi) = 0S. Since i corresponds to i in the original circuit, we have:",
  "wAssign(W )vars()pi(xi, yi, wi) = pi(x, y) = 0S": "This means that there must be some wi Assign(W ) vars() such that pi(x, yi, wi) = 0S(since 0S is the additive identity); thus x suppX(i). To nish the proof, note that suppX(i) suppX(i) and suppX(l) suppX(l) are disjoint unless i = l (by X-determinism of , i.e.suppX(i) suppX(l) = unless i = l). Thus (ii) holds for . In either case, we have shownthat is also X-deterministic. (5.2) Consider taking the product of two compatible circuits C, C over variables V , V , outputtinga circuit C. According to Algorithm 2 and the proof of Theorem 2, every sum node Ccorresponds to either the product of (a) an input or product node C and a sum node =+kj=1j C, such that = +kj=1j or (b) two sum nodes = +ki=1i C and = +kj=1j C, such that = +ki=1 +kj=1 ij. Further, and have the same scope over the commonvariables V V , i.e. vars() (V V ) = vars() (V V ).",
  "Assume that C and C are both X-deterministic; then X V V . We note that since , havethe same scope over the common variables, they also have the same scope over X, i.e. vars() X = vars() X": "In case (a), X-determinism of means that either (i) vars() X = or (ii) suppX(i) suppX(j) = for all i = j. If (i), then vars()X = (vars()vars())X = also. If (ii),note that suppX(j ) suppX(j) for all j as a 0S = 0S for any semiring S and a S. ThussuppX(i ) suppX(j ) = for all i = j. Thus is X-deterministic.",
  "In case (b), since , have the same scope over X, either (i) holds for both , , or (ii) holds forboth. If (i), then vars()X = (vars()vars())X = also. If (ii), then for any i, j, consider": "the restricted support suppX(ij). Noting that vars(i) X = vars(j) X = vars(ij) X bysmoothness, we claim that suppX(ij) suppX(i) suppX(j). Suppose that x suppX(ij).Then there exists some y vars(ij) \\ X such that pij(x, y) = pi(x, yvars(i))\\X) pj(x, yvars(j)\\X) = 0S. This means that both pi(x, yvars(i))\\X), pj(x, yvars(j)\\X) cannotbe 0S, and so x suppX(i) and x suppX(j) also.To nish the proof, we note thatsuppX(ij) suppX(i) suppX(j) and suppx(lm) suppX(l) suppX(m) are disjointunless i = l, j = m (by X-determinism of and ). Thus is X-deterministic by (ii). (5.3) Consider taking the product of two support-compatible circuits C, C over variables V , V ,outputting a circuit C. According to Algorithm 3 and the proof of Theorem 3, every sum node = +ki=1i C corresponds to some sum nodes = +ki=1i C and = +ki=1i Csuch that = (), pi = pi pi, and has scope vars() vars(). Further, and have thesame scope over the common variables V V , i.e. vars() (V V ) = vars() (V V ). Assume that C and C are both X-deterministic; then X V V . We note that since , havethe same scope over the common variables, they also have the same scope over X, i.e. vars() X = vars()X. Thus, either (i) holds for both , , or (ii) holds for both. If (i), then vars()X = (vars() vars()) X = also. If (ii), then for any i, consider the restricted supportsuppX(ij). Noting that vars(i) X = vars(j) X = vars(i ) X by smoothness, we claimthat suppX(i ) suppX(i)suppX(i). Suppose that x suppX(i ). Then there exists somey vars(i ) \\ X such that pi (x, y) = pi(x, yvars(i))\\X) pi(x, yvars(i)\\X) = 0S. Thismeans that both pi(x, yvars(i))\\X), pi(x, yvars(i)\\X) cannot be 0S, and so x suppX(i) andx suppX(i) also. To nish the proof, we note that suppX(i ) suppX(i) suppX(i) andsuppx(l ) suppX(l) suppX(l) are disjoint unless i = l (by X-determinism of and ).Thus is X-deterministic by (ii). (5.4) Consider applying an elementwise mapping to a circuit C, outputting a circuit C. Accordingto Algorithm 4 and Theorem 4, every sum node = +ki=1i C corresponds to some node = +ki=1i C, such that p = (p), and further pi = (pi) and vars(i) = vars(i) foreach i. Assume that C is X-deterministic. If (i) vars()X = , then vars()X = also. Otherwise, (ii)suppX(i) suppX(j) = for all i = j. We claim that suppX(i) suppX(i) for each i. Tosee this, recall that elementwise mappings satisfy (0S) = 0S. If x suppX(i), then there existsy s.t. pi(x, y) = 0S. Since pi(x, y) = (pi(x, y)), pi(x, y) = 0S. So x suppX(i). Tonish the proof, note that suppx(i) suppX(i) and suppx(l) suppX(l) are disjoint unlessi = l (by X-determinism of ). Thus is X-deterministic by (ii). X-compatibilityRecall that two smooth and decomposable circuits C, Cother over variablesV , Vother are X-compatible for X V Vother if for every product node = 1 2 Cand other = other,1 other,2 Cother such that vars() X = vars(other) X, it holds thatvars(1) X = vars(other,1) X and vars(2) X = vars(other,2) X.",
  "(5.5) Suppose that C, Cother are X-compatible. We wish to show that Cother, C are X-compatiblewhere C is the output circuit from Algorithm 1 that aggregates C over W , where W X =": "Suppose = 1 2 C and other = other,1 other,2 Cother are product nodes such thatvars() X = vars(other) X. Let = 1 2 be the corresponding node in C such thatp = w p. The scope vars() = vars() \\ W ; since W X = , we have vars() X = vars(other) X also. Thus, by X-compatibility of C, Cother, we have that vars(1) X =vars(other,1) X and vars(2) X = vars(other,2) X. Since vars(1) = vars(1) \\ W andvars(2) = vars(2) \\ W , this means that vars(1) X = vars(other,1) X and vars(2) X =vars(other,2) X. Thus C, Cother are X-compatible. (5.6) Suppose that C over V and C over V are both X-compatible with Cother. We wish to showthat Cother, C are X-compatible where C is the output circuit from Algorithm 2 that computes theproduct of the two compatible (i.e. (V V )-compatible) circuits C, C. Suppose = 1 2 C is a product node, and other = other,1 other,2 Cother suchthat vars() X = vars(other) X; we need to show that these decompose in the same wayover X. By Algorithm 2 and the proof of Theorem 2, this was created as the product of nodes = 1 2 C and = 1 2 C such that vars()(V V ) = vars()(V V ) =vars() (V V ) (and similarly for their children). Thus by (V V )-compatibility of C, C, and decompose the same way over (V V ), i.e. vars(1)(V V ) = vars(1)(V V ) andvars(2) (V V ) = vars(2) (V V ). Since X V V (by denition of compatibility),this also holds over X, i.e. vars(1) X = vars(1) X and vars(2) X = vars(2) X.",
  "vars(2) X = (vars(2) X) (vars(2) X) = vars(2) X": "By compatibility of C, Cother, we have that vars(other1)X = vars(1)X and vars(other2)X =vars(2) X. Thus vars(other1) X = vars(1) X and vars(other2) X = vars(2) X.This shows X-compatibility of C, Cother. Example 4 (Counterexample to (5.6) for Compatibility). While X-compatibility is maintainedthrough multiplying compatible circuits, the same is not true for compatibility, due to the differ-ent variable overlaps between the circuits. For example, suppose that C over variable sets A, B, Chas product nodes with scope decomposing as = 1(A) 2(B C), and C over variable setsA, B, D has product nodes with scope decomposing as = 1(A) 2(B D). Then thesecircuits are compatible (i.e. A B-compatible), and their product is a circuit with product nodeswith scope decomposing as = 1(A) 2(B C D). Now consider Cother with productnodes with scope decomposing as other = other(C) other(D). This is compatible with and ,but not with .",
  "For all sum nodes = +ki=1i C[X], we have that suppX(i) suppX((j)) = whenever i = j": "(5.9) Suppose that C, Cother are X-support-compatible; and let Cother,C be the isomorphism fromCother[X] to C[X]. We wish to show that Cother, C are X-support-compatible where C is theoutput circuit from Algorithm 1 that aggregates C over W , where W X = . We dene the isomorphism as follows. Consider the set of nodes C[X]. Since W X = , thesenodes are not scalars and so are not propagated away by Lines 3-4. Moreover, since the algorithmretains the node types and connectivity of the circuit, there is an isomorphism C,C between C[X]and C[X]. There is thus an isomorphism Cother,C := C,C Cother,C between Cother[X] and C[X].It remains to show the two conditions. Given a node other Cother, let us write := Cother,C(other) and := C,C().By X-support compatibility of Cother, C, we have that vars(other) X = vars() X. By the proofof Theorem 1, we know that vars() = vars() \\ W . Since W X = , this implies thatvars(other) X = vars() X as required. For the second part, suppose that these are sum nodes,i.e. other = +ki=1other,i, = +ki=1i and = +ki=1i. We know by X-support-compatibilitythat suppX(other,i) suppX(j) = whenever i = j. By the same argument as in (5.1), we havethat suppX(i) suppX(i) for all i. Thus we can conclude that suppX(other,i)suppX(j) = whenever i = j. So Cother, C are X-support-compatible.",
  "(5.10) Suppose that C over V and C over V are both X-support-compatible with Cother; writeCother,C for the isomorphism from Cother[X] to C, and Cother,C for the isomorphism from Cother[X]": "to C. We wish to show that Cother, C are X-support-compatible where C is the output circuitfrom Algorithm 3 that computes the product of the two support-compatible (i.e. (V V )-support-compatible) circuits C, C. We dene the isomorphism as follows. Consider the set of nodes C[X]. The algorithm for mul-tiplying C, C makes use of the isomorphism C,C between C[V V ] and C[V V ], withC[V V ] retaining the same connectivity and node types; thus there is an isomorphism C,Cfrom C[V V ] to C[V V ], also. Since X (V V ), this isomorphism also holds betweenthe circuits restricted to X. Thus, we dene the isomorphism = C,C Cother,C between Cother[X]and C[X]. It remains to show the two conditions. Given a node other Cother, let us write := Cother,C(other), = C,C() and := C,C().By X-support-compatibility of Cother, C, we have that vars(other)X = vars()X. By support-compatibility of C, C, we have that vars()(V V ) = vars()(V V ) and so vars()X =vars()X, and both are equal to vars()X since vars() = vars()vars() (as in Theorem3). Thus vars(other) X = vars() X as required. For the second part, suppose that these aresum nodes, i.e. other = +ki=1other,i, = +ki=1i, = +ki=1i and = +ki=1i . We knowby X-support-compatibility that suppX(other,i) suppX(j) = whenever i = j. By the sameargument as in (5.3), we have that suppX() suppX() suppX(). Thus we can concludethat suppX(other,i) suppX() = . So Cother, C are X-support-compatible. (5.11) Suppose that C, Cother are X-support-compatible; and let Cother,C be the isomorphism fromCother[X] to C[X]. We wish to show that Cother, C are X-support-compatible where C is theoutput circuit from Algorithm 4 that applies an elementwise mapping to C. Algorithm 4 mapseach node C to another node C, keeping the node type and connectivity; this denes anisomorphism C,C from C[X] to C[X]. Thus we have an isomorphism Cother,C := C,C Cother,C.It remains to show the two conditions. Given a node other Cother, let us write := C0,C(other) and := C,C().By X-support-compatibility of Cother, C, we have that vars(other) X = vars() X. The mappingalgorithm does not change the scope of the nodes, i.e.vars() = vars(), so we have thatvars(other) X = vars() X as required. For the second part, suppose that these are sum nodes,i.e. other = +ki=1other,i, = +ki=1i and = +ki=1i. We know by X-support-compatibilitythat suppX(other,i) suppX(j) = whenever i = j. We know by the same argument as in (5.4)that suppX(i) suppX(i) for all i. Thus we can conclude that suppX(other,i)suppX(j) = whenever i = j. So Cother, C are X-support-compatible.",
  "Theorem 7 (Hardness of 2AMC with X-rstness). 2AMC is #P-hard, even for circuits that aresmooth, decomposable, deterministic, and X-rst, and a constant-time elementwise mapping": "Proof. Take a DNF with terms 1, . . . , m over variables X1, . . . , Xn. Let l = log m + 1. Letus construct another DNF with terms 1, . . . , m over variables X1 . . . , Xn and Y1, . . . , Yl+1such that each i is the conjunction of i, Yl+1 and a term over Y1, . . . , Yl encoding a binary repre-sentation of i. For example:",
  "= 5 Y1 Y2 Y3 Y4 Yl Yl+1": "Now, efciently manipulate to make it smooth . The circuit is thus smooth, decomposable,deterministic and trivially satises X-rstness (since the children to every -gate are literals). Takethe probability semiring as SX, and SY = (N2, +2, 2, (0, 0), (1, 1)) and ((n1, n2)) = n1/n2(dene 0/0 = 0). Also, dene (x) = 1, and (Yl+1 = 0) = (0, 1) and (y) = 1 for all otherliterals. Then 2AMC counts the models of , which is #P-hard :",
  "In line 1, we use the support mapping (Denition 6) from the Boolean to SY semiring; thisis tractable by Corollary 1 due to determinism, and the output CSY (X, Y ) retains all theproperties by": "In line 2, we take the product of CSY (X, Y ) and X(X). X is omni-compatible, sowe can apply PROD-CMP. This results in a circuit CSY ,Y (X, Y ) that is smooth, decom-posable and X-rst. X(X) is both deterministic and X-deterministic as it has no sumnodes, so this output circuit is also deterministic and X-deterministic by (5.2).",
  "In line 3, we aggregate CSY ,Y (X, Y ) over Y . The output circuit CSY ,Y (X) is smoothand decomposable. It is also X-deterministic by (5.1), as Y X =": "Since CSY ,Y (X, Y ) satised X-rstness, each product node = 1 2 in that circuithad at most one child (say 1) with scope overlapping with Y . Then, in the product in theprevious step, 2 must have been produced through Lines 1-2 (otherwise it would containsome variable in Y ); thus it was produced by applying BSY to some node in C. Thus,for any value v Assign(2), p2 {0SY , 1SY }. So (Prod 0/1) is satised. In line 4, we apply the mapping SY SX to CSY ,Y (X). This circuit is over X andis X-deterministic, i.e. deterministic and satises (Additive). As shown in the previousstep, it also satises (Prod 0/1). Thus the mapping algorithm produces the correct result,producing a smooth, decomposable and determinsitic circuit CSX,Y (X) as output.",
  "Finally, we aggregate CSX,Y ,X(X) over X, producing a scalar": "Theorem 9 (Exponential Separation). Given sets of variables X={X1, ..., Xn}, Y={Y1, ..., Yn}, there exists a smooth, decomposable and X-deterministic circuit C of size poly(n)such that the smallest smooth, decomposable, and X-rst circuit C such that pC pC has size2(n). Proof. Consider representing the distribution given by a hidden Markov model (HMM) over (hid-den) variables Xn = {X1, ..., Xn} and (observed) variables Yn = {Y1, ..., Yn}, as depictedin a.b shows a structured decomposable circuit that computes the hiddenMarkov model distribution, where the components Ci(j) have scope {Xi, Yi}. The correspond-ing vtree/scope-decomposition (with nodes notated using their scopes) is shown in c. It caneasily be checked that the circuit is Xn-deterministic, and that the circuit size is linear in n. It remains to show that the smallest Xn-rst and Xn-deterministic circuit computing theHMM distribution is exponential in size.Explicitly, we will choose a HMM such that theemission distribution is given by p(Yi|Xi) = 1Yi=Xi.Then we have that pC(xn, Yn) =pC(xn)pC(Yn|xn) = pC(xn)1Yn=xn, for any circuit C that expresses the distributionof the HMM.",
  "Any spanning set for R2n must contain at least 2n elements. Thus, K 2n, and the circuit C mustbe exponentially sized": "One might attempt to remedy the situation by replacing X-rstness with X-determinism. For thegeneral case, that however is insufcient:Theorem 10 (Hardness of 2AMC with X-determinism). 2AMC is #P-hard even for decomposable,smooth, deterministic and X-deterministic circuits, and a constant-time elementwise transformationfunction. Proof. By reduction from the counting version of number partitioning: Given positive integersk1, . . . , kn, count the number of index sets S {1, . . ., n} such that iS ki = iS ki = c. Thatproblem is known to be #P-hard . Dene = ni=1(Xi Yi). Then is a deterministic, X-deterministic, decomposable and smooth circuit.4 Let the inner labeling function be (yi) = ki/cand (yi) = 1. Then for a xed conguration x of the variables X = {X1, . . . , Xn}, we haveexactly one model for , whose value is i:xi=1ki/c. If we select the inner semiring so that",
  "While this circuit is not X-rst, it does satisfy a property known as X-rstness modulo denability ;thus that property is insufcient for 2AMC even together with X-determinism": "is addition (e.g., the max tropical semiring or log semiring), then the inner AMC problem returnsi:xi=1 ki/c, which equals 1 iff S = {i : xi = 1} is a solution to the number partitioning instance.Now, dene the outer labeling function to be = 1, and let the transformation function be (s) = 1if s = 1 and (s) = 0 otherwise. Then the 2AMC problem with the probability semiring as outersemiring counts the number of solutions of the number partitioning instance.",
  "BCase Studies": "In this section, we provide more details about the compositional inference problems in (re-produced in ) for convenience, and prove the tractability conditions for each (Theorem 6).For all of them, we assume that we are given a Boolean formula represented as a circuit. That wouldusually come from knowledge compilation from some source language such as Bayesian Networks or probabilistic logic programs ; our results thus show what properties the compiled circuitmust have in order a query of interest to be tractable. Note that the problems are generally com-putationally hard on the source language, which means there do not exist compact circuitssatsifying the properties in the worst-case.",
  "B.12AMC Queries": "Firstly, we consider instances of 2AMC queries. Recall the general form of a 2AMC query. Givena partition of the variables V = (X, Y ), a Boolean function (X, Y ), outer and inner semiringsSX, SY , labeling functions Y (Y ) = YiY Y ,i(Yi) over S and X(X) = XiX X,i(Xi)over S, and an elementwise mapping SY SX : SY SX, the 2AMC problem is given by:",
  "ipi(vi)": "To cast it as a 2AMC problem, take the inner semiring SY to be the probability semiring and denethe inner labelling function to assign Y (Yi) = 0 if Yi E and Yi is inconsistent with e andY (Yi) = pi(Yi) otherwise. The outer semiring is the (max, ) semiring with labeling functionX(Xi) = 1. The elementwise mapping function SY SX(a) = a is the identity function. The proof of the tractability conditions follows Theorem 8, except that we note that the mappingfunction SY SX from the outer to inner semiring satisies (Multiplicative). As such, we do notneed the (Prod 0/1) circuit property, which was the reason we needed the X-rstness condition.",
  "y|=(x,Y )qp(y|x)": "The function p(Y |X) depends on the semantics adopted. Let mod(Y |X) := {y : (X, y)} bethe set of assignments of Y such that (X, ) is true. In the Maximum Entropy Semantics (MaxEnt), one distributes the probability mass p(X) uniformly over the models of consistentwith X, i.e. p(y|X) =1 |mod(Y |X)|. On the other hand, in the Credal Semantics (Max-Credal), one places all probability mass p(X) on some assignment y of Y consistent with X andq. To obtain an upper bound on the query probability regardless of which y is chosen, one setsp(y|X) := 1 for all y if there exists an assignment Y |= (X, Y ) q, and p(Y |X) = 0otherwise.",
  "The 2AMC formulation of the problem uses the probability semiring as outer semiring SX, withlabeling function X(Xi) = p(Xi) for Xi X": "In the (MaxEnt) semantics, for the inner semiring, we take as the semiring of pairs ofnaturals SY = (N2, +, , (0, 0), (1, 1)), with coordinatewise addition and multiplication.The inner labeling function sets Y (Q) = (1Q=q, 1), and sets Y (Yi) = (1, 1) for allother variables Yi Y . The mapping function is dened by SY SX((a, b)) = a/b (with0/0 = 0). In the (Max-Credal) semantics, we simply set the inner semiring to be the Boolean semiring",
  "b c": "d = SY SX(a, b)SY SX(c, d) =SY SX(a, b)SY SX(c, d) (this holds also if (a, b) = (0, 0) and/or (c, d) = (0, 0)). Meanwhile,for (Max-Credal) we have SY SX(a b) = SY SX(a b) = a bSY SX = aSY SX bSY SX = SY SX(a) SY SX(b) = SY SX(a) SY SX(b). For the (Max-Credal) semantics, we note additionally since SY is just the Boolean semiring, we donot need determinism in Line 1 of Algorithm 5. So the only conditions required are smoothness,decomposability, and X-determinism.",
  "xp(x|e)1p(Y =y|x,e)T,": "To cast this as a 2AMC instance, we use the inner semiring S = (R20, +, , (0, 0), (1, 1)),with coordinate-wise addition and multiplication. The inner labeling function assigns Y (Y ) =(p(Y )1Y =y, p(Y )). The outer semiring is the probability semiring and the mapping SY SX frominner to outer semirings is SY SX((a, b)) = [[a bT ]]. Last, the outer labeling function assignsX(Xi) = 1Xi|=e if Xi E, and X(Xi) = p(Xi) otherwise.",
  "p(Y |X, Z)": "C3(X, Y , Z) := PROD-SCMP(C(X, Y , Z), C2(X, Z)). C is (X Z)-support-compatible with itself as it is (X Z)-deterministic = C is also (X Z)-support-compatible with C1 by (5.9) = C is also (X Z)-support-compatible with C2by (5.11). As C and C2 share variables (X Z), this means they are support-compatible.Thus this product is tractable in linear time.",
  "p(Z)p(Y |X, Z)": "C5(X, Y , Z) := PROD-CMP(C4, C3). C is V -compatible with itself(structured decomposable) = C is Z-compatible with itself by Proposition 1 = Cis also Z-compatible with C4 by (5.5) = C4 is Z-compatible with C1 by (5.5) =C4 is Z-compatible with C2 by (5.8) = C4 is Z-compatible with C3 by (5.6). Since C4and C3 share variables Z, this means they are compatible and so this product is tractablein quadratic time.",
  "C6(X, Y ) = AGG(C5, Z) is tractable by smoothness and decom-posability": "Thus, we have recovered the tractability conditions derived by , with the same complexity ofO(|C|2) (induced by the compatible product to construct C5). However, we also have an alterna-tive tractability condition. Suppose that C were additionally Z-deterministic, but not necessarilystructured decomposable. Then we could replace the derivation of C5 above with the following:",
  "SS(a) = 1a=1 SS(a) = a": "Suppose we are given a probabilistic circuit representing p(H, I, e). While this query appearsextremely intimidating at rst glance, we note that the only operators we need to consider are themappings and single product. Note that all of these mappings satisfy (Multiplicative) (SSbecause the domain of S is so SS(a b) = 1 iff a = b = 1); thus the mappings aretractable if the input circuits are deterministic. By checking the scopes of the inputs to each mapping,we can see that (H I)-determinism, I-determinism, and H-determinism sufces. This alsoenables tractability of the product in linear time by support compatibility. No tractability conditions for exact inference for this query were previously known. While themotivation behind the MFE query is as a means of approximating marginal MAP, and so this exactalgorithm is not practically useful in this case, this example illustrates the power of the compositionalframework to tackle even very complex queries.",
  "h,e1p(e1, x, e2, h)(13)": "Here, the mapping 1 is tractable if the circuit for p is X-deterministic. Since p is X-deterministic,it is X-support-compatible with itself; chaining this with (5.9) and (5.11) in , the inputs tothe product are X-compatible; since they have scope X, this means the product is tractable bysupport-compatibility. The resulting circuit remains X-deterministic (i.e. deterministic as the scopeis X), which means that the mapping PM from the probability to (max, ) semiring is tractable.Thus, this query is tractable for smooth, decomposable and X-deterministic circuits in linear time(same as derived by the authors)."
}