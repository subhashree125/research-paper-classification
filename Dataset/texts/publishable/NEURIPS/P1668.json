{
  "Abstract": "Our work aims to minimize interaction in secure computation due to the high costand challenges associated with communication rounds, particularly in scenarioswith many clients. In this work, we revisit the problem of secure aggregation in thesingle-server setting where a single evaluation server can securely aggregate client-held individual inputs. Our key contribution is the introduction of One-shot PrivateAggregation (OPA) where clients speak only once (or even choose not to speak) peraggregation evaluation. Since each client communicates only once per aggregation,this simplifies managing dropouts and dynamic participation, contrasting withmulti-round protocols and aligning with plaintext secure aggregation, where clientsinteract only once.We construct OPA based on LWR, LWE, class groups, DCR and demonstrateapplications to privacy-preserving Federated Learning (FL) where clients speakonce. This is a sharp departure from prior multi-round FL protocols whose studywas initiated by Bonawitz et al. (CCS, 2017). Moreover, unlike the YOSO (YouOnly Speak Once) model for general secure computation, OPA eliminates complexcommittee selection protocols to achieve adaptive security. Beyond asymptoticimprovements, OPA is practical, outperforming state-of-the-art solutions. Webenchmark logistic regression classifiers for two datasets, while also building anMLP classifier to train on MNIST, CIFAR-10, and CIFAR-100 datasets.We build two flavors of OPA (1) from (threshold) key homomorphic PRF and(2) from seed homomorphic PRG and secret sharing. The threshold Key homo-morphic PRF addresses shortcomings observed in previous works that relied onDDH and LWR in the work of Boneh et al. (CRYPTO, 2013), marking it as anindependent contribution to our work. Moreover, we also present new thresholdkey homomorphic PRFs based on class groups or DCR or the LWR assumption.",
  "Introduction": "Minimizing interaction in Multiparty Computation (MPC) stands as a highly sought-after objectivein secure computation. This is primarily because each communication round is costly, and ensuringthe liveness of participants, particularly in scenarios involving a large number of parties, posessignificant challenges. Unlike throughput, latency is now primarily constrained by physical limitations,making it exceedingly difficult to substantially reduce the time required for a communication round.Furthermore, non-interactive primitives offer increased versatility and are better suited as foundationalbuilding blocks. However, any non-interactive protocol, which operates with a single communicationround, becomes susceptible to a vulnerability referred to as the residual attack where the servercan collude with some clients and evaluate the function on as many inputs as they wish revealing theinputs of the honest parties.",
  "arXiv:2410.22303v1 [cs.CR] 29 Oct 2024": "This work explores a natural hybrid model that sits between the 2-round and 1-round settings.Specifically, our model allows for private aggregation, aided by a committee of members, wherethe client only speaks once. This approach brings us closer to achieving non-interactive protocolswhile preserving traditional security guarantees. Our specific focus is within the domain of secureaggregation protocols, where a group of n clients Pi for i P rns hold a private value xi, wish to learnthe sum i xi without leaking any information about the individual xi. In this model, clients releaseencoded versions of their confidential inputs xi to a designated committee of ephemeral membersand they go offline, they only speak once. Later, any subset of the ephemeral members can computethese encodings by simply transmitting a single public message to an unchanging, stateless evaluatoror server. This message conveys solely the outcome of the secure aggregation and nothing else. Ofsignificant note, the ephemeral members are stateless, speak only once, and can change (or not) peraggregation session. With that in mind, the committee members can be regarded as another subsetof clients who abstain from contributing input when they are selected to serve on the committeeduring a current aggregation session. Each client/committee member communicates just once peraggregation, eliminating the complexity of handling dropouts commonly encountered in multi-roundsecure aggregation protocols. The security guarantee is that an adversary corrupting a subset of clientsand the committee members learn no information about the private inputs of honest clients, beyondthe sum of the outputs of these honest clients. We present a standard simulation-based security proofagainst both a malicious server and a semi-honest server. We present extensions that offer strongersecurity guarantees. See for a comparison to other models. Our main application is Federated Learning (FL) in which a server trains a model using data frommultiple clients. This process unfolds in iterations where a randomly chosen subset of clients (or aset of clients based on the history of their availability) receives the models current weights. Theseclients update the model using their local data and send back the updated weights. The server thencomputes the average of these weights, repeating this cycle until model convergence is achieved. Thisapproach enhances client privacy by only accessing aggregated results, rather than raw data.",
  "Our Contributions": "We introduce OPA designed to achieve maximal flexibility by granting honest parties the choice tospeak once or remain silent, fostering dynamic participation from one aggregation to the next. Thisdiverges from prior approaches , which necessitate multiple interaction rounds andthe management of dropout parties to handle communication delays or lost connections in federatedlearning.",
  "HSMM assumption where M N where N is an RSA modulus (i.e., the DCR assumption)": "Threat Model: OPA does not require any trusted setup for keys and for M being either a prime oran exponent of prime, or the LWR assumption, we do not require any trusted setup of parameterseither. We allow the server to be maliciously corrupted, maliciously corrupt clients, and corruptup to a certain threshold t of the committee members where t is the corruption threshold for secretreconstruction. Based on the CL framework we additionally strengthen the security to allow for thecompromise of all the committee members (while ensuring the server is not corrupt).",
  "Clients": "(a) The OPA system model operates in iterations. Eachiteration begins with the server sending a message to ini-tiate the process (Message 0). In response, clients trainthe model on their local data, obtain updates, and maskthe input. (Message 1): masked input is sent to the server,while auxiliary information is transmitted (via encryp-tion) to the committee, via the server. Upon receiving theforwarded information, the committee members com-bine these into a single value. Finally, this consolidateddata is sent to the server (Message 2), concluding theiteration.",
  "No Leakage": "(b) Our Key Contributions. Here, n is thenumber of clients, and L is the length of theinput vector. Finally, LR refers to leakage-resilient. Note that the HSM assumption isparametrized by M and covers the case whereM is a prime integer, M pk for some primep and integer k, M 2k, and M N whereN is an RSA modulus (i.e., the DCR assump-tion).",
  "We also extend Shamir Secret Sharing over Integers to a packed version which enablespacking more secrets in one succinct representation": "We also present a malicious variant of OPA that empowers a server to detect a maliciousclient that has inconsistent shares. Meanwhile, we extend OPA1 to the setting where all thecommittee is corrupted but the server is honest. We want to ensure that the honest clientsinput is still hidden, even if the committee member gets the ciphertext.",
  "Of independent interest, we also build a seed homomorphic PRG from the HSMM assumptionfor the most efficient secure aggregation protocol we present in the context of federatedlearning": "Applications: Our motivating application is for Federated Learning (FL). The dynamic participationfeature of OPA, crucial for federated learning, facilitates secure federated learning, where participantsspeak only once, streamlining the process significantly. Learning in the clear involves the clientreceiving the global update from the server and responding with one message corresponding to thenew updates generated after the client has trained the model with its local data. In contrast, priorworks involve 8 rounds, and the work of requires 7 rounds in total, including the setup.Moreover, our protocols offer adaptive security. Our advantages extend beyond just round complexity.See .2 and Tables 1 and 2 for a detailed comparison of asymptotics. Implementation and Benchmarks: Our contributions also extend beyond the theoretical domain.We implement OPA as a secure aggregation protocol and benchmark with several state-of-the-artsolutions . Specifically, we first implement OPA based on the CL framework withM p. Importantly, our server computation time scales the best with a larger number of inputs whereour server takes 1s for computation even for a larger number of clients (n 1000). Meanwhile,our client running time is competitive for a small number of clients but offers significant gains for alarger number of clients. Then we benchmark OPA based on the LWR assumption. OPALWR, which is based on the seedhomomorphic PRG, offers competitive server performance (with significant gains for larger L) whencompared to OPACL. Meanwhile, OPALWR outperforms the client performance of even OPACL. Wealso compare the performance of our LWR construction with a naive solution where each clientsecret-shares their inputs with the committee members. Our experiments show that OPALWR offers thebest numbers for the committee members, for large L. To further demonstrate the feasibility of our protocol, we train a binary classification model usinglogistic regression, in a federated manner, for two datasets. Our protocol carefully handles floatingpoint values (using two different methods of quantization - multiplying by a global multiplier vsrepresenting floating point numbers as a vector of integer values) and the resulting model is shown tooffer performance close to that of simply learning in the clear. We also trained a neural-network-basedMLP classifier that was trained over popular machine learning datasets including MNIST, CIFAR-10,and CIFAR-100. More details can be found in .",
  "While we defer a rigorous exposition on the technical overview of our construction to , wenow present the intuition behind our protocol. The communication flow is described in a": "Every client needs to ensure the privacy of their input, therefore a client has to mask their input. Initeration , if client i has input xi,, then it chooses a mask of the same length to add to the inputs.Let the mask be maski, and the ciphertext is defined as cti, xi, ` maski,. To ensure privacy,we need the mask to be chosen, uniformly at random, from a large distribution. Furthermore, byperforming the addition with respect to a modulus M, we get the property that for a random maski,,cti, is identically distributed to a random element from ZM. The client i sends cti, to the server.This is Message 1a in a.",
  "i maski, to complete the computation. In works on Private Stream Aggregation ,the assumption made is that": "i maski, 0. However, this requires all the clients to participatewhich is a difficult requirement in federated learning. Instead, we enlist the committees help toprovide the server with i maski,, for only the participating clients. Working with the Committee. Each client i, therefore, has to communicate information about itsrespective maski, to the committee members. This is what we refer to as Aux info, and we routeit through the server, to the committee member, and the information is encrypted under the publickey of the respective committee member. This is Message 1b in a. This ensures that theserver cannot recover the auxiliary information. Eventually, each committee member combinesthe aux info it has received to the server (Message 2 in a), with the guarantee that this issufficient to reconstruct i maski,. We rely on Shamirs secret-sharing to distribute a secret sto a committee of m such that as long as r number of them participate, the server can learn the secrets. The security of the secret is guaranteed even if the server colludes with t committee members. Werequire t m 1. We also rely on the homomorphism property which ensures that if a committeemember receives shares of two secrets s1, s2. Then, adding up these shares will help reconstruct thesecret s1 ` s2. Optimizing Committee Performance in Variant 1. The solution laid out above requires theclients to secret-share maski,. However, note that maski, is as long as xi,. Therefore, eachcommittee member will receive communication OpnLq where n is the number of clients and L isthe length of the vector. It also has to perform computations proportional to OpnLq. OPA reducesthe burden of the committee by introducing a succinct communication that is independent of Lto the committee. We do so by relying on a structured pseudorandom generator (PRG) which is : Total asymptotic computation cost for all rounds per aggregation with semi-honest security.n denotes the total number of users, with committee size m and L is the length of the input vector.The Rounds column indicates the number of rounds in the setup phase (on the left, if applicable)and each aggregation iteration (on the right). A round of communication refers to a discrete stepwithin a protocol during which a participant or a group of participants send messages to anotherparticipant or group of participants, and participants from the latter group must receive these messagesbefore they can send their own messages in a subsequent round.fwd means that the server onlyforwards the messages from the users. The second column in the User Aggregation phase refers tothe cost of the committee members.",
  "Detailed Contributions in Federated Learning": "Next, we compare our protocol with all efficient summation protocols listed in , with a specificfocus on those that accommodate dynamic participation, a key feature shared by all federated learningmethodologies. Asymptotically, we look at the performance of OPA. In Tables 1 and 2, we listthe communication complexity, computational complexity, and round complexity per participant.Notably, our protocols are setup-free, eliminating any need for elaborate initialization procedures.Furthermore, they are characterized by a streamlined communication process, demanding just a singleround of interaction from the participants. Asymptotic Comparison. More concretely, based on , our approach stands out by signifi-cantly reducing the round complexity, ensuring that each participants involvement is limited to asingle communication round i.e. each participant speaks only once. That is, users speak once andcommittee members speak once too. On the contrary previous works2 require 8 rounds andthe work of requires 7 rounds in total, including the setup. This reduction in round complexityserves as a significant efficiency advantage. Despite our advantage in the round complexity, our advantages extend beyond just round complexity(see ). Notably, as the number of participants (n) grows larger, our protocol excels in terms ofcomputational complexity. While previous solutions exhibit complexities that are quadratic or linearithmic in n, our approach maintains a logarithmic complexity for the users which isnoteworthy when considering our protocols concurrent reduction in the number of communicationrounds. Furthermore, our committee framework demonstrates a linear relationship with n for thecommittee members, a notable improvement compared to the linearithmic complexity and setuprequirement in the case of which considers a stateful set of decryptors (committee), as opposedto our stateless committee.3 2 offer a weaker security definition from the other works: for some parameter between r0, 1s, honestinputs are guaranteed to be aggregated at most once with at least fraction of other inputs from honest users.3Flamingo employed decryptors which were a random subset of clients chosen by the server to interactwith it to remove masks from masked data that were sent by the larger set of clients. lacks securityguarantees in the event of collusion among all decryptors. : Total received and sent asymptotic communication cost for all rounds per aggregation withsemi-honest security. n denotes the total number of users, m is the size of the committee, k thesecurity parameter, L the length of the input vector, and the bit length of each element.",
  "OPA1-OpkLpn ` mqq-OpkpL ` mLqqOpkpnL ` Lqq": "When it comes to user communication and message sizes, previous solutions entail user complexitiesthat either scale linearly or linearithmically with the number of participants (n) accordingto . However, in our case, user communication complexity is reduced to a logarithmic level.Our communication among committee members exhibits a linear relationship with n. Furthermore,as the number of users n increases, the communication load placed on the server is also effectivelyreduced in comparison to other existing protocols. That said, the above advantages underline thescalability and efficiency of our protocols in the federated learning context which typically requires avery large number of n and L. The works of address an active adversary that can provide false information regardingwhich users are online on behalf of the server, by requiring users to verify the signatures of theclaimed online set. This approach introduces an additional two rounds into each protocol, resultingin 10 rounds in and 5 rounds in with 10 rounds of setup. The setup communicationcomplexity of also increases to Opk log2 nq. In our work, we solve this issue without signatures.Note that prior work often required a two-thirds honest majority for the malicious setting. Onecan leverage this to instead introduce a gap between the reconstruction threshold r and corruptionthreshold t. Specifically, if r pm ` tq{2, then a malicious server can only reconstruct with respectto a unique set and any other information is purely random information, unhelpful to the server. Comparison with LERNA . LERNA requires a fixed, stateful committee (like Flamingo) tosecret share client keys, whereas we support smaller, dynamic stateless committees that can changein every round. Concretely, LERNA works by having each client (in the entire universe of clients, notjust for that iteration) secret-share the keys with the committee. Consequently, LERNAs committeeneeds to be much larger (214 members for 40 due to the number of shares they receive) andtolerate fewer dropouts, compared to our approach. Furthermore, LERNAs benchmarks assume20K+ clients, while real-world deployments have 50-5000 clients per iteration. When the clientcount is low, the committee has to do significantly more work to handle and store the required largenumber of shares. That said, LERNA is not suitable for traditional FL applications. In the table, weuse the same notations, as for LERNA to refer to committee size by utilizing in the committeecalculations. LERNA could work for less than 16K parties but then the computation of committeemembers increases significantly as the number of parties decreases. Even concrete costs requirethe client to send 2GB of data during the setup phase (with 20K clients and L 50, 000). Periteration, the cost is 0.91 MB. For the same parameters, OPACL (the construction based on distributedkey-homomorphic PRF in CL framework), requires the client to send 5.6 MB (across both serverand committee, per iteration). As a result, LERNA only becomes cost-effective after more than 400iterations, during which it requires a fixed, stateful, and large committee to stay alive. Recall thatOPALWR is even more optimal, in terms of communication cost than OPACL. However, LERNAs useof Ring-LWR assumption could provide for improved computation, when compared to both OPACLand OPALWR. Comparison with Willow . The concurrent work, Willow, employs a static, stateful committee ofmembers, with non-committee members (clients) communicating only once, offering improvementsover previous approaches like LERNA. While Willow supports smaller committee sizes and client-to-committee communication that remains independent of committee sizecompared to LERNAthisadvantage comes with trade-offs. Specifically, committee members must:",
  ". Participate in two rounds of communication during the decryption phase: (1) to threshold-decrypt the aggregated ciphertext, and (2) to provide secret key shares for dropout committeemembers": "In both Willow and LERNA, only non-committee members communicate only once; however, OPAdiffers substantially. In our approach, all client parties (including committee members) communicatejust once, with no need for a setup procedure. Additionally, our stateless committee members canfunction as clients, joining or leaving the system at any time, making it more adaptable and closer tothe standard federated learning model Finally, unlike OPA, Willow requires another party (or a set of parties) called verifier(s) to ensuresecurity against a malicious server. In essence, the verifier certifies that the server has not behavedmaliciously. While we refer the reader to their paper for the details of the role of the verifier, it issufficient to note that the role of the verifier is to verify information about the ciphertexts sent by eachclient to the committee members. This involves pnq performance of the verifier. However, by usinga tree-based approach and increasing the number of verifiers, Willow guarantees that, while all theverifiers together perform Opnq work, each verifier only does opnq work.",
  "Related Work": "Multi-Round Private Summation. We begin by revisiting the concept outlined in . The firstmulti-round secure aggregation protocol, designed to enable a single server to learn the sum of inputsx1, . . . , xn while hiding each input xi is based on the following idea. Each user i adds a mask ri totheir private input xi. This mask remains hidden from both the server and all other users it exhibits theproperty of canceling out when combined with all the other masks, i.e., iPrns ri 0. Subsequently,each user forwards Xi xi ` ri to the server. By aggregating all the Xi values, the server is thenable to determine the sum of all xi. More specifically, to generate these masks, a common keykij kji PRGpgsisjq is established by every pair of clients i, j. Here, gsi serves as an ephemeralpublic key associated with each client i P rns. This public key is shared with all other clients duringan initial round, facilitated through the server. Importantly, the value si remains secret by each clienti. Then, each client i P rns computes the mask ri",
  "i Xi": "i xi. In this protocol, users are required to engage in multiplerounds of communication, where each user communicates more than once. Moreover, the protocoldoes not permit users to drop out from an aggregation iteration. Non-Interactive Private Summation with trusted setup. If we were to require users to commu-nicate only once in a protocol iteration, we encounter the challenge of mitigating residual attacks.In a prior study conducted by , a solution based on DDH was proposed to mitigate residualattacks by involving a trusted setup that assumes the generation of the common keys kij kji intothe protocol. However, it is important to highlight that this particular setup lacked the necessarymechanisms to accommodate dropouts and facilitate dynamic participation for multiple aggregationiterations. An additional limitation of this construction is the necessity of establishing a trusted setupthat can be utilized across multiple iterations. Furthermore, to ensure that the server is unable torecover the masking key given a clients masked inputs, the work relies on the DDH Assumption.An unfortunate consequence is that the server has to compute the discrete logarithm to recover theaggregate, a computationally expensive operation, particularly when dealing with large exponents.Numerous other works within this framework have emerged, each relying on distinct assumptions,effectively sidestepping the requirement for laborious discrete logarithm calculations. These includeworks based on the DCR assumption , and lattice-based cryptography . Multi-Round Private Summation without Trusted Setup. A separate line of research endeavors toeliminate the necessity for a trusted setup by introducing multi-round decentralized reusable setupsdesigned to generate masks while adhering to the crucial cancellation property. However, akin to thepreviously mentioned approaches, these protocols come with a caveatthey do not accommodatescenarios involving dropouts or dynamic user participation across multiple iterations. Dipsauce is the first to formally introduce a definition for a distributed setup PSA with a security modelbased on k-regular graph, non-interactive key exchange protocols, and a distributed randomnessbeacon to build their distributed setup PSA. Meanwhile, the work of Nguyen et al. , assuming a PKI (or a bulletin board where all the public keys are listed), computed the required Diffie-Hellman keys on the fly to then build a one-time decentralized sum protocol which allowed the serverto sum up the inputs one-time, with their construction relying on class group-based cryptography. Tofacilitate multiple iterations of such an aggregation, they combined their one-time decentralized sumprotocol with Multi-client Functional Encryption (MCFE) to build a privacy-preservation summationprotocol that can work over multiple rounds, without requiring a trusted setup and merely requiring aPKI. Unfortunately, per iteration, the clients need to be informed of the set of users participating inthat round and unfortunately, they cannot drop out once chosen. Non-Interactive Private Summation with a collector. To circumvent the need for a trusted setupand multi-round decentralized arrangements, an approach is presented in the work of whichintroduces an additional server known as the collector. The fundamental premise here is to ensurethat the collector and the evaluation server do not collude, thus effectively mitigating the risksassociated with residual attacks. This protocol does allow dynamic participation and dropouts periteration. Multi-Round Private Summation with Dynamic Participation (aka Secure Aggregation). Secureaggregation of users private data with the aid of a server has been well-studied in the context offederated learning. Given the iterative nature of federated learning, dynamic participation is crucial.It enables seamless integration of new parties and those chosen to participate in various learningiterations, while also addressing the challenge of accommodating parties that may drop out duringthe aggregation phase due to communication failures or delays. Furthermore, an important problemin federated learning with user-constrained computation and wireless network resources is thecomputation and communication overhead which wastes bandwidth, increases training time, andcan even impact the model accuracy if many users drop out. Seminal contributions by Bonawitz etal. and Bell et al. have successfully proposed secure aggregation protocols designed tocater to a large number of users while addressing the dropout challenge in a federated learning setting.However, its important to note that these protocols come with a notable drawbacksubstantial roundcomplexity and overhead are incurred during each training iteration. Even in the extensive corpusof research based on more complex cryptographic machinery (see for a plethora of previousworks) such as threshold additive homomorphic encryption etc., these persistent drawbacks continueto pose challenges. Notably, all follow up works of require multiplerounds of interaction based on distributed setups. Secure aggregation protocols, with their adaptablenature, hold relevance across a wide array of domains. They are applicable in various scenarios,including ensuring the security of voting processes, safeguarding privacy in browser telemetry asillustrated in , and facilitating data analytics for digital contact tracing, as seen in besidesenabling secure federated learning. It is also important to note that some of these works - ACORN and RoFL build on topof the works of to tackle the problem of input validation using efficient zero-knowledgeproof systems. The goal is for the clients to prove that the inputs being encrypted are well-formedto prevent poisoning attacks.RoFL allows for detection when a malicious client misbehaves, whileACORN presents a non-constant round protocol to identify and remove misbehaving clients. Weleave it as a direction for future research on how to augment our protocol to also support inputvalidation. The above discussion is also summarized in , by looking at four properties (a)whether the aggregate can be efficiently recovered, (b) whether it allows dynamic participation, (c)whether it requires trusted setup or multi-round distributed setup, and (d) the security assumptions.",
  "OPA vs Other Communication/Computation Models": "Shuffle Model. Note that our model bears similarities to the shuffle model, in which clients dispatchinput encodings to a shuffler or a committee of servers responsible for securely shuffling before thedata reaches the server for aggregation as in the recent work of Halevi et al. . Nonetheless, it isimportant to note that such protocols typically entail multiple rounds among the committee servers tofacilitate an efficient and secure shuffle protocol. Multi-Server Secure Aggregation Protocols. Its worth emphasizing that multi-server protocols, asdocumented in , have progressed to a point where their potential standardizationby the IETF, as mentioned in , is indeed noteworthy. In the multi-server scenario, partiescan directly share their inputs securely among a set of servers, which then collaborate to achievesecure aggregation. Some of the works in this domain include two-server solutions Elsa and : Comparison of Various Private Summation Protocols. TD stands for trusted dealer/trustedsetup, DS stands for multi-round distributed setup. Note that DS implies several rounds of interactionwhile our protocol does not require any interaction. Here, efficient aggregate recovery refers towhether the server can recover the aggregate efficiently. For example, require somerestrictions on input sizes to recover the aggregate due to the discrete logarithm bottleneck.",
  "Our WorkNAHSM, LWR, (R)LWE": "SuperFL or the generic multi-server solution Flag . Unfortunately, in the case of federatedlearning, which involves handling exceptionally long inputs, the secret-sharing approach becomesimpractical due to the increase in communication complexity associated with each input. Furthermore,these servers are required to have heavy computation power and be stateful (retaining data/state fromiteration to iteration). Jumping ahead, in our protocol the ephemeral parties are neither stateful norrequire heavy computation. Commmittee-Based MPC. Committee-based MPC is widely used for handling scenarios involvinga large number of parties. However, it faces a security vulnerability known as adaptive security,where an adversary can corrupt parties after committee selection. The YOSO model, introduced byGentry et al. proposes a model that offers adaptive security. In YOSO, committees speak onceand are dynamically changed in each communication round, preventing adversaries from corruptingparties effectively. The key feature of YOSO is that the identity of the next committee is known onlyto its members, who communicate only once and then become obsolete to adversaries. YOSO runsgeneric secure computation calculations and aggregation can be one of them. However, its efficiencyis prohibitive for secure aggregation. In particular, the communication complexity of YOSO inthe computational setting scales quadratic with the number of parties n (or linear in n if the costis amortized over n gates for large circuits). Additionally, to select the committees, an expensiverole assignment protocol is applied. Like LERNA, in YOSO also specific sizes for the committeeneed to be fulfilled to run a protocol execution. Last but not least, our protocol does not rely on anysecure role assignment protocol to choose the committees since even if all committee members arecorrupted, privacy is still preserved. Fluid MPC also considers committee-based generalsecure computation. However, like YOSO, it is not practical. Unlike YOSO, it lacks support foradaptive security. Moreover, SCALES considers ephemeral servers a la YOSO responsible for generic MPCcomputations where the clients only provide their inputs. This approach is of theoretical interest as itis based on heavy machinery such as garbling and oblivious transfer if they were to be considered forthe task of secure aggregation. Moreover, SCALES needs extra effort to hide the identities of theservers which we do not require.",
  "Technical Overview": "In this work, we focus on building a primitive, One-shot Private Aggregation (OPA), that enablesprivacy-preserving aggregation of multiple inputs, across several aggregation iterations whereby aclient only speaks once on his will, per iteration. Seed-Homomorphic PRG (SHPRG). A PRG G : K Y is said to be seed-homomorphic if Gps1s2q Gps1qbGps2q where p, Kq and pb, Yq are groups. We show how to build SHPRG from LWRand LWE Assumption. Note that the former was known but the latter was not. For ease of exposition,we will focus on the LWR construction. For a randomly chosen A $ ZLnq, PRGLWR,Apsq tAsupwhere p q. Unfortunately, this construction is only almost seed-homomorphic in that there is aninduced error. This is formally defined in Construction 1. Secret Sharing over Finite Fields. In standard Shamir secret sharing , one picks a secret s andgenerate a polynomial fpXq r1i0 ai Xi where a0 s and a1, . . . , ar1 are randomly chosenfrom the field. Assuming there are m parties, the share for party i P rms is fpiq, and any subset of atleast r parties can reconstruct s and any subset of r 1 shares are independently random. We canlower the corruption threshold from r 1 to t to obtain additional properties from the scheme. Inpacked secret sharing , one can hide multiple secrets using a single polynomial. One-shot Private Aggregation (based on SHPRG). With the needed background in place, we areready to build the new primitive called One-shot Private Aggregation. Critically, we want to empowera client to speak once, per iteration, and help the server successfully aggregate long vectors (of lengthL, say). To this end, we have the client communicate at the same time with the server and to a set ofcommittee members, via the server. We will assume that there is a PKI or a mechanism to retrieve thepublic key of these committee members so that the communication to the committee can be encrypted.These are m ephemerally chosen clients who are tasked with helping the server aggregate, for thatiteration. Flamingo [69, , Lines 2-7] presents an approach on how to sample these committeemembers using a randomness beacon such as . Observe that the one-shot communication can beleveraged to successfully avoid the complex setup procedures that were reminiscent of prior work.Instead, the client i samples a seed from the seed space of the PRG, i.e., sdi $ PRF.K. Then, thePRG is expanded under this seed sdi and effectively serves as a mask for input xi,. Here is thecurrent iteration number. In other words, it computes cti, xi, ` PRG.Expandpsdiq. Intuitively,the PRF security implies that the evaluation is pseudorandom and is an effective mask for the input.Then, the client secret shares using standard Shamirs Secret Sharing, sdi to get shares!sdpjqi)",
  "jPrms": "Share sdpjqiis sent to committee member j, via the server through an appropriate encryption algorithm.Each committee member simply adds up the shares, using the linear homomorphism property ofShamirs secret sharing. After receiving from the clients for that round, the committee member jsends the added shares, which corresponds to ni1 sdpjqi . The server can successfully reconstructfrom the information sent by the committee to get ni1 sdi. Note that adding up the ciphertext fromthe clients results in ni1 cti, ni1 xi, ` ni1 PRG.Expandpsdiq. Key Homomorphism of thePRF implies that ni1 PRG.Expandpsdiq PRG.Expand pni1 sdiq. Note that the server, with thereconstructed information, can compute PRG.Expand pni1 sdiq and subtract it from ni1 cti, torecover the intended sum. This is the core idea behind our construction. However, there are a fewcaveats. First, the server recovers the sum of the keys ni1 sdi, which constitutes a leakage on theseed of the PRG. In other words, we require a leakage-resilient, seed homomorphic PRG. Second, LWRand the LWE based construction of seed homomorphic PRG are only almost seed homomorphic. Thus,care needs to be taken to encode and decode to ensure that the correct sum is recovered. We showthat the LWR and LWE based schemes are key-homomorphic and leakage-resilient while describing thenecessary encoding and decoding algorithms for the input. A key benefit of this construction is thatthe key shared with the committee is usually independent of the vector length. Our proof of securityis in the simulation-based paradigm against both a semi-honest and an active server. One-shot Private Aggregation against Malicious Clients. Prior work to ensure the detection ofclient misbehavior such as ACORN requires the usage of verifiable secret sharing. Unfortunately,this is an expensive process as the committee member is required to do at r exponentiations, perclient. Instead, we take an alternative route by designing a publicly verifiable secret-sharing scheme.This employs SCRAPE and combines it with a simple -protocol. As a result, the server canverify that given the commitment to shares, the shares are indeed a valid Shamir Secret Sharing. Meanwhile, the committee member simply needs to verify if the commitment to the share matches itsencrypted share with the committee member raising an alarm should the check fail. This is a muchleaner verification process for the committee members. CL Framework. We use the generalized version of the framework, as presented by Bouvier etal. . Broadly, there exists a group pG whose order is M ps where gcdpM, psq 1 and ps is unknownwhile M is a parameter of the scheme. Then, pG admits a cyclic group F, generated by f whose orderis M. Consider the cyclic subgroup H which is generated by h xM, for a random x P pG. Then, onecan consider the cyclic subgroup G generated by g f h with G factoring as F H. The order ofG is also unknown. The HSMM assumption states that an adversary cannot distinguish between anelement in G and H, while a discrete logarithm is easy in F. Meanwhile, s, an upper bound for ps isprovided as input. Note that for M N where N is an RSA modulus, the HSMM assumption reducesto the DCR assumption. Therefore, the HSMM assumption can be viewed as a generalization of the DCRassumption. Secret Sharing over Integers. Braun et al. was the first to identify how to suitably modifyShamirs secret sharing protocol to ensure that the operations can work over a group of unknownorder, such as the ones we use on the CL framework. This stems from two reasons. The first is leakagein that a share fpiq corresponding to some sharing polynomial f always leaks information about thesecret s, modi when the operation is over the set of integers. Meanwhile, the standard approach toreconstruct the polynomial requires the computation of the Lagrange coefficients which involvesdividing by an integer, which again needs to be reinterpreted to work over the set of integers. Thesolution to remedy both these problems is to multiply with an offset m! where m is the totalnumber of shares. (Almost) Key Homomorphic Pseudorandom Functions. The concept of key homomorphic PRFs(KH-PRFs) was introduced by , who demonstrated that Hpxqk is a secure KH-PRF under theDDH assumption in the Random Oracle Model, where H is a hash function, k is the key, and x isthe input. later constructed an almost KH-PRF under the Learning with Rounding assumption, which was formally proven secure by . Our work leverages almost KH-PRF constructionsfrom both LWR and LWE assumptions in the Random Oracle Model. Additionally, we present a novelKH-PRF construction in the CL framework, yielding new constructions under the HSM assumption(including DCR-based constructions). We adapt the DDH-based construction to the CL frameworkand prove that Fpk, xq Hpxqk, where k $ K and H : t0, 1u H is modeled as a random oracle,is a secure KH-PRF under the HSM assumption. This adaptation requires careful consideration ofappropriate groups, input spaces, and key spaces. Distributed Key Homomorphic Pseudorandom Functions (KHPRF). presented genericconstructions of Distributed PRFs from any KH-PRF using secret sharing techniques. However,the CL frameworks use of groups with unknown order necessitates working over integer spaces.While Linear Integer Secret Sharing exists, it can be computationally expensive. Instead, weutilize Shamir Secret Sharing over Integer Space as described by , refining it with appropriateoffsets to construct Distributed PRFs from our HSM-based construction. In other words, rather thanreconstructing the secret, the solution reconstructs a deterministic function of the secret which isaccounted for in the PRF evaluation. This induces complications in reducing the security of ourdistributed key homomorphic PRF to that of the HSM-based KH-PRF. Finally, we demonstratethat our construction maintains the key homomorphism property, allowing combinations of partialevaluations of secret key shares to match the evaluation of the sum of keys at the same input point. Building Distributed Key Homomorphic PRFs. introduced a generic construction of dis-tributed KHPRFs from almost key homomorphic PRFs. They proposed FLWRpk, xq : txHpxq, kyupas an almost key homomorphic PRF, where q p are primes, k $ Zq, and H is a suitably definedhash function. Their reduction to build a distributed PRF utilizes standard Shamirs Secret Sharingover fields, simplifying the process compared to integer secret sharing due to the prime nature of qand p. However, their proposed construction contained shortcomings affecting both correctness andsecurity proofs. We will now provide a brief overview of these issues. An almost KH-PRF satisfiesFpk1 ` k2, xq Fpk1, xq ` Fpk2, xq e for some error e. For the LWR construction, e P 0, 1.However, this implies FpT k, xq T Fpk, xq eT where eT P 0, . . . , T 1 for any integer T,leading to error growth and affecting Lagrange interpolation. The authors proposed multiplying byan offset m! to bound the error and use rounding to mitigate its impact by ensuring that the errorterms are eaten up. However, their security reduction faces challenges when simulating partial evaluations for unknown i. Lagrange interpolation with the \"clearing out the denominator\" techniquecauses further error growth, necessitating additional rounding. Consequently, the challenger can onlyprovideYFpkpiq, xq] u. Thus, their definition of partial evaluation function needs to be updatedto be consistent with what is simulatable. We identified further issues in their rounding choices.Specifically, partial evaluations should be rounded down to u where tp{uu p ` 1q r (rbeing the reconstruction threshold). Moreover, their framework only addressed single-key PRFs, notvector-key cases like LWR. We address these issues in our construction of a distributed, almost keyhomomorphic PRF based on LWR. We formally prove that FLWRpk, xq XX txHpxq, kypuu\\\\",
  "Each share for committee member j is evaluated at . This evaluation is sent to the committeemember": "Finally, the server runs DPRF.Combine to combine the information from the committeemembers to get the PRF evaluation at under the sum of the keys, for each index in.Combine is the algorithm that helps reconstruct the evaluation from partial evaluations. Stronger Security Definitions and Construction. We also present a stronger security guarantee,which was not provided by the committees of Lerna and Flamingo, whereby the committee memberscan all collude and observe all encrypted ciphertexts and all auxiliary information, and cannotmount an IND-CPA-style attack. Unfortunately, our current construction where the inputs are solelyblinded by the PRF evaluation, which is also provided to the committee members in shares, can beunblinded by the committee leaking information about the inputs. We modify the syntax where eachlabel/iteration begins with the server, which has its secret key, advertising a public key for thatiteration (the keys for all iterations can also be published beforehand). The auxiliary information sentby a client to the committee is a function of this public key while the actual ciphertext is independentof this public key. Intuitively, this guarantees that the committee members information is blindedby the secret key of the server and cannot be used to unmask the information sent by the client.We now describe our updated construction. For each label , the server publishes Fpk0, q wherek0 is its public key. Then, the auxiliary information sent by the client is of the form Fpkpjqi , qwhere kpjqiis the j-th share of the i-th clients key. Client i masks its input by doing f xi Fpk0, qki.Committee member j combines the results to then send Fpni1 kpjqi , q to the server. The server usesLagrange interpolation and its own key k0 to compute: Fpk0ni1 ki, q. Meanwhile, the server, uponmultiplying the ciphertexts gets X fni1 xi, Fpk0ni1 ki, q. The recovery is straightforwardafter this point.",
  "Preliminaries and Cryptographic Building Blocks": "Notations. For a distribution X, we use x $ X to denote that x is a random sample drawn fromthe distribution X. We denote by u a vector and by A a matrix. For a set S we use x $ S to denotethat x is chosen uniformly at random from the set S. By rns for some integer n, we denote the sett1, . . . , nu. Cryptographic Preliminaries. This is deferred to Section A. In Section A.1, we discuss the def-inition and construction of secret-sharing schemes over a field and over integers. In Section A.2,we present lattice-based assumptions. This is followed by an exposition on the syntax and securitydefinitions of various types of pseudorandom functions through Sections A.3 and A.4. Finally, weintroduce the CL Framework in Section A.5.",
  "This is almost seed homomorphic in that: PRGps1 ` s2q PRGps1q ` PRGps2q ` e where e Pt1, 0, 1uL": "Theorem 1 (Leakage Resilience of Construction 1). Let PRGLWR be the PRG defined in Construction 1.Then, it is leakage resilient in the following sense:PRGLWRpsdq mod p, sd ` sd1 mod q : sd, sd1 $ Zn1q(cy, sd ` sd1 mod q : y $ ZLp , sd, sd1 $ Zn1q(",
  "Hybrid1pq: In this hybrid, we replace sd ` sd1 mod q with a uniformly random value sd2 $ Zn1q .PRGLWRpsdq mod p, sd2 : sd, sd2 $ Zn1q(": "Note that psd ` sd1q mod q and sd2 are identically distributed. Let us assume that thereexists a leakage function oracle L that can be queried with an input sd, for which it eitheroutputs sd ` sd1 mod q for a randomly sampled sd1 $ Zn1qor outputs s1 $ Zn1q . If onecould distinguish between hybrids Hybrid0, Hybrid1, then one could distinguish betweenthe outputs of the leakage oracle, but the outputs are identically distributed. Therefore, theHybrid0, Hybrid1 are identically distributed. Therefore, the Hybrid0, Hybrid1 are identi-cally distributed.",
  "i1xi": "where e 1 ` ni1 ei. Therefore, to eventually recover ni1 xi mod p from just the value ofni1 si, we will require ||e||8 q2p. Looking ahead, we will rely on the Hint-LWE Assumption 6 toshow that it is leakage resilient when we use it to build our aggregation tool.",
  "Remark 1 (Construction based on Ring-LWE). One can also extend the above LWE construction tothe Ring-LWE setting": "Recall the R-LWE Assumption. Let N be a power of two, and let m 0 be an integer. Let R be acyclotomic ring of degree N, and let Rq be its residue ring modulo q 0. Then, the following holds:pa, a k ` eq : a $ Rmq , k $ Rq, e $ m(cpa, uq : a $ Rmq , u $ Rmq(",
  "One-shot Private Aggregation": "In this section, we begin by introducing the syntax and security of our primitive which we callOne-shot Private Aggregation (OPA). Broadly speaking, the goal of this primitive is to support aserver (aka aggregator) to sum up the clients inputs encrypted to a particular label (which can be atag, timestamp, etc.), without it learning any information about the inputs beyond just the sum.",
  "Simulation-Based Privacy": "Our proof approach is based on the standard simulation-based framework where we demon-strate that any attacker against our protocol can be simulated by an attacker Sim in an ideal worldwhere a trusted party T computes a function F on the clients inputs X. In our case, this function isthat of vector summation. We consider an attacker A, that controls at most n clients and possiblythe server. In our construction, we will consider these n clients to possibly include those belongingto the committee. The ideal world consists of the following steps which are adapted to the simplersetting where only one party, i.e., the server has the output:",
  "Our Construction of One-shot Private Aggregation Scheme": "The key idea behind our construction is that a seed-homomorphic PRG allows us to have a single seed,much shorter than L, to mask all the L inputs. Then, one can simply secret-share the seed, whichreduces computation and communication. Our seed-homomorphic PRGs are in the standard model.However, it is important to note that for the intended application of Federated Learning one mighthave to rely on the random oracle model to thwart attacks such as those pointed out by Pasquini etal. . Though the underpinning idea of OPA is the combination of seed-homomorphic PRG and anappropriate secret-sharing scheme, there are technical issues with presenting a generic construction.We begin by presenting the construction based on the Learning with Rounding Assumption.",
  "Compute X Decodeppp, pX1, . . . , XLqqreturn X": ": Our Construction of OPA built from LWR-based Seed Homomorphic PRG pPRGq andShamirs secret sharing scheme SS. Here, Encodepxi,q : nxi,`1 and DecodepXiq : rXi{ns1.The lines are for security against an active server. The use of the second mask mask1i,, as the outputof a H is for simulation proof, for an active server. We will model H as a programmable random oracle.",
  "X{n xi, ` pn e1q{n 0 e1 n 1 1{n pn e1q{n 1 Therefore, r X{ns xi, ` 1": "Theorem 2. Let s and c be the statistical and computational security parameters. Let L be theinput dimension and n be the number of clients, that are polypcq. Let be the dropout thresholdand be the corruption threshold such that ` 1. Then, there exists an efficient simulator Simsuch that for all K rns such that |K| n, inputs X txi,uiPnzK, and for all adversaries Aagainst Construction 3, that controls the server and the set of corrupted clients K, which behavesemi-honestly (resp. maliciously), the output of Sim is computationally indistinguishable from thejoint view of the server and the corrupted clients. Sim is allowed to query F D,pXq (defined inEquation 1) once, per iteration.",
  "Proof is deferred to Section F": "Remark 2 (Malicious Server and Inconsistent Updates). Recent work by Pasquini et al. describesan attack where the server can send different models to different client updates with the goal that themodel sent to a particular client can negate the training done by other clients on different models.In our case, this attack can be easily remedied with no overhead. Rather than evaluating the PRGwith just the public matrix A, one can first compute a hash Hpmodelq, and multiply it with A. Thiswould ensure that the matrix used by the client is tied to the model update sent. If different clientsuse different A, the seed homomorphism fails. This would make it difficult, for a malicious serverto send different models to different clients, to ensure that a particular clients contributions are notaggregated and therefore can be recovered. We can also simply switch to the key-homomorphic PRFconstructions described in Section E. In Section G, we model security when the entire committee is corrupted and the committee, throughsome attack, recovers the ciphertext of an honest client. The goal is to ensure that the input of thehonest client is still preserved. In this definition, the server is honest.",
  "Theorem 3. Let s and c be the statistical and computational security parameters. Let L be theinput dimension and n be the number of clients, that are polypcq. Let be the dropout threshold": "and be the corruption threshold such that ` 1. Then, there exists an efficient simulator Simsuch that for all K rns such that |K| n, inputs X txi,uiPnzK, and for all adversaries Aagainst Construction 4, that controls the server and the set of corrupted clients K, which behavesemi-honestly (resp. maliciously), the output of Sim is computationally indistinguishable from thejoint view of the server and the corrupted clients. Sim is allowed to query FD,pXq (defined inEquation 1) once, per iteration. Proof. The proof proceeds similar to that of Theorem 2, through a sequence of hybrids. However,there are a few differences. Construction 2 has the error vector e $ . However, we will replacee e1 ` f1 where e1, f1 $ 1, the distribution present in Hint-LWE Assumption (see Definition 6).The hybrid descriptions are similar, so we only specify the differences:",
  "We will argue that Hybrid2, Hybrid3 are indistinguishable under Hint-LWE Assumption.We will sketch the reduction now": "Recall that, from the Hint-LWE Challenge, we get pA, u, s : s ` r, e : e1 ` f1q. As done for the LWR construction, we will set the s1 ` sn s, the leakage on key. For generating ct1, we will use u, while also sampling a separate f1 $ 1. Thisgives us: ct1, u ` f1n, ` x1,",
  "Security Against Malicious Clients": "In this section, we will focus on a misbehaving client. Observe that the client can send inconsistentshares to the committee. A standard approach would be for the client to rely on verifiable secretsharing which would empower each committee member to verify if the share received by thecommittee member is consistent with the commitments to the polynomial that was sent by the client.However, this requires each client to perform nr exponentiations which can be expensive. Instead, wetake the approach of a modified publicly verifiable secret sharing scheme. This approach empowersthe server, which has more computation power, to verify if the sharing is consistent. Our public verifiability will rely on a modification of SCRAPE . SCRAPE test is done to check ifpsdp1qi, , . . . , sdpmqi, q is a Shamir sharing over F of degree d r 1 (namely there exists a polynomial pof degree d such that ppiq si for i 1, . . . , n), one can sample wp1q, . . . , wpmq uniformly fromthe dual code to the Reed-Solomon code formed by the evaluations of polynomials of degree d,and check if mi1 wpiq sdpiqi, 0 in F. If the test passes, then sdp1qi, , . . . , sdpmqi, are Shamir Shares,except with probability 1{|F|.Lemma 4 (SCRAPE Test ). Let F be a finite field and let d r 1, m be parameters of theShamirs Secret Sharing scheme such that 0 d m 2, and inputs sdp1qi, , . . . , sdpmqi, P F. Define",
  "Otherwise, Prrxw, sy 0s 1{|F|": "Typically, we compute the polynomial mpXq by using the Fiat-Shamir transform over public values.Then, the vector w is a public vector. One simply has to hide the vector s. As a result, we have provedthat the shares do lie on the same polynomial. Note that in standard Shamirs Secret Sharing, we setpp0q sdi,, i.e., the secret. Therefore, we will have to perform inner product over a vector of lengthm ` 1.",
  "This results in the following additional steps on the part of the client, the committee member, and theserver. We detail only these additional steps": "Construction 5 (Detecting Malicious Client Behavior). Let H : t0, 1u Fmd2 where d r 1be a hash function which is modeled as a random oracle. Let H1 : t0, 1u F be the hash functionused to generate the challenge. Let G be a group generated by g where Discrete Logarithm and DDHis hard, and is of prime order q, the same as the order of the field for Shamir Secret Sharing.",
  "Decrypt and recover the share sdpjqi, . Verify that this matches the commitment forwardedby the server": "It is easy to verify that an honest prover will satisfy the proof. This follows from the SCRAPE test(Lemma 4) and also the completeness of the generalized -protocol. Meanwhile, if there exists twoaccepting transcripts z1, z2 corresponding to c1, c2, then one can extract a witness for sdp0qi, , . . . , sdpmqi, .This guarantees soundness. The zero-knowledge property follows by simply sampling a random z andthen setting the choice of the Cpjqtby following the verification steps. Further, it can set r xz, wy.",
  "pseudorandomness, even contingent on this leakage. Furthermore, these constructions allowed thegeneration of a new key, in every iteration": "We will now present a construction OPA1 such that: (a) a clients keys can be reused across multipleiterations, and, (b) the server does not get the sum of the keys but rather a function of pseudorandomvalues, which can argued as itself being pseudorandom. The core technique we employ in this workis a distributed, key-homomorphic PRF. We formally present constructions from the CL frameworkin Section C. Specifically, we defer OPACL to the appendix in Section C.2. Similarly, we presentLWR based construction in Section D. Meanwhile, we broadly describe the intuition behind ourconstruction. A distributed-key-homomorphic PRF has two specific algorithms: Eval which allows to evaluation ofthe PRF with key ki at a point. While, P-Eval allows the PRF to be evaluated at a share of the key kpjqito get a partial evaluation. Therefore, in our construction, the clients mask a vector of inputs xi, bycomputing a pseudorandom evaluation of DPRF.Evalpki,1, , . . . , DPRF.Evalpki,L, q. Meanwhile,the auxiliary information send to the committee member will be P-Evalpkpjqi,k, q for k 1, . . . , Land j P rms. Then, the committee members combine by multiplying the auxiliary information. Theserver then reconstructs on its end. Note that the server only computes DPRF.Evalpni1 ki,k, q fork 1, . . . , L. This is a PRF evaluation and therefore the leakage is pseudorandom and can be easilysimulated, replacing it with random.",
  "Experiments": "We benchmark OPACL (Construction 12) and OPALWR (Construction 3). Recall that the former isbased on threshold key-homomorphic PRF and where there is no leakage simulation needed, whilethe latter is based on seed-homomorphic PRG. We run our experiments on an Apple M1 Pro CPUwith 16 GB of unified memory, without any multi-threading or related parallelization. We use theABIDES simulation to simulate real-world network connections. ABIDES supports a latencymodel which is represented as a base delay and a jitter which controls the number of messagesarriving within a specified time. Our base delay is set with the range from 21 microseconds to 100",
  "microseconds), and use the default parameters for the jitter. This framework was used to measure theperformance of other prior work including . More details on the framework can be found in[53, G]": "Parameter Choices for OPALWR: OPALWR is parametrized by , q, p. We use the LWE-estimator to estimate the security level. We follow the parameters similar to .The value of 1{p is the error rate in an LWE instance. Using the LWE estimator, weset : 1024. We set q to match the field used for Shamirs Secret Sharing, which isa 128-bit prime, and set p 285. The hardness estimated is 2129. We do use PackedSecret Sharing, for benchmarking the server and client computation cost. We pack it to64, i.e., each committee member receives 64 shares. For reconstruction to hold we setm 50, r 34. Assuming 0.01, we can estimate that setting m 50, then thePrrC `C 1{3s 5105. This also satisfies the requirements of packed secret sharingwhich will require that m 3{2 1024{64. Recall that, for packed secret sharing, we canset the corruption threshold to be r where is the number of secrets being packed. Here is 16. Note that this construction achieves committee performance independent of thevector length and is the preferred one. Parameter Choices for OPACL: We rely on the BICYCL library and use pybind toconvert the C++ code to Python. Our implementation will assume that the plaintext space isZp for a prime p. Our experiments will assume that m log n. Microbenchmarking Secure Aggregation. Our first series of experiments is to run OPACL, OPALWRto build a secure aggregation protocol for L 1. We also compare with existing work including. We vary the offline rates, and the ability to group clients, along with increasing thenumber of clients to study the performance of related work. Recall that the offline rate (denoted by) controls the number of clients who do not participate, despite being selected. Meanwhile, wedenote by g the size of the neighborhood or group. For , we set the input size to be boundedby 104. Recall that does not have efficient aggregate recovery and requires input bounding.Also, incurs a setup/offline client computation time of nearly 30ms, even for 100 clients. Ourimplementation sets m tlogpnqu. As can be seen from . The key takeaway from ourexperiments is that our client and server performance outperforms all prior works. Performance of OPACL. OPACLs server running time is less than 1 second - owing to a single roundprotocol with support of efficient recovery of the aggregate. This outperforms all existing protocols.Each committee member computes 1ms. OPACL assumes concurrent client communication tocommittee and server. Note that OPACL scales linearly with the size of the input. Performance of OPALWR. It is to be noted that the server performance matches that of OPACLsserver performance. However, when aggregating longer vectors, which is the use-case for OPA,OPALWR significantly outperforms OPACL, with the key savings coming from having to perform noexponentiations. Meanwhile, the clients performance in OPALWR is much better than OPACL, againdue to the lack of exponentiations. The communication cost for OPALWR are as follows:",
  "Total Sent/Received per Committee Member: n k ` k field elements": "In Section B, we describe the naive secret-sharing-based construction and also study the computationcost of OPALWR with respect to this naive construction by micro-benchmarking the running times.Our experiments indicate that the running time of the committee member is the best with OPALWR,when compared to the naive solution. This is in addition to the improvement in the communicationcost. Recall that the motivating use case for avoiding the naive solution is improved performance ofthe committee members, who are often other clients. Benchmarking FL Models. To demonstrate OPACLs viability for federated learning, we train alogistic regression model on two skewed datasets. We show that OPACL performs very close tolearning in the clear, indicating feasibility for machine learning. As our goal was to show feasibility,our experiments use one committee member for all n clients. We vary n and the number of iterationsfor model convergence, measuring accuracy and Matthews Correlation Coefficient (MCC) which better evaluates binary classification with unbalanced classes. Adult Census Dataset: We first run experiments on the adult census income dataset from to predict if an individual earns over $50,000 per year. The preprocessed dataset has105 features and 45,222 records with a 25% positive class. We randomly split into trainingand testing, with further splitting by the clients. First, we train in the clear with weights sentto the server to aggregate. With 100 clients and 50 iterations, we achieve 82.85% accuracyand 0.51 MCC. We repeat with OPACL, one committee member, and 100 clients. With10 iterations, we achieve 82.38% accuracy and 0.48 MCC. With 20 iterations, we achieve82% accuracy and 0.51 MCC. Our quantization technique divides weights into integer anddecimal parts (2 integer and 8 decimal values per weight). Training with 50 clients takesunder 1 minute per client per iteration with no accuracy loss. This quantization yields avector size of 1050 (10 per feature). We use the Kaggle Credit Card Fraud dataset , comprising 26 transformed principalcomponents and amount and time features. We omit time and use the raw amount, adding anintercept. The goal is to predict if a transaction was indeed fraudulent or not. There are 30features and 284,807 rows, with 0.2% fraudulent. Weights are multiplied by 10,000 androunded to an integer, accounted for in aggregation. shows OPACLs MCC versusclear learning for varying clients and iterations. With the accuracy multiplier, OPACLs MCCis very close to clear learning and even outperforms sometimes. The highly unbalanceddataset demonstrates OPACL can achieve strong performance even in challenging real-worldscenarios. We then train a vanilla multi-layer perceptron (MLP) classifier on three datasets: MNIST,CIFAR-10, CIFAR-100. We quantize the weights by multiplying with 216. The MLPaccuracy, as a function of the iteration count, is plotted in . Our experimentsdemonstrate that OPACL preserves accuracy while ensuring the privacy of client data. Notethat vanilla MLP classifiers do not typically offer good performance for CIFAR datasets, butnote that the goal of our experiments was to show that OPACL does not impact accuracy. Disclaimer. This paper was prepared for informational purposes by the Artificial Intelligence Re-search group of JPMorgan Chase & Co and its affiliates (J.P. Morgan) and is not a product ofthe Research Department of J.P. Morgan. J.P. Morgan makes no representation and warranty what-soever and disclaims all liability, for the completeness, accuracy or reliability of the informationcontained herein. This document is not intended as investment research or investment advice, or arecommendation, offer or solicitation for the purchase or sale of any security, financial instrument,financial product or service, or to be used in any way for evaluating the merits of participating inany transaction, and shall not constitute a solicitation under any jurisdiction or to any person, if suchsolicitation under such jurisdiction or to such person would be unlawful. Damiano Abram, Ivan Damgrd, Claudio Orlandi, and Peter Scholl. An algebraic frameworkfor silent preprocessing with trustless setup and active security. In Yevgeniy Dodis and ThomasShrimpton, editors, Advances in Cryptology CRYPTO 2022, Part IV, volume 13510 of LectureNotes in Computer Science, pages 421452. Springer, Cham, August 2022. Anasuya Acharya, Carmit Hazay, Vladimir Kolesnikov, and Manoj Prabhakaran. SCALES -MPC with small clients and larger ephemeral servers. In Eike Kiltz and Vinod Vaikuntanathan,editors, Theory of Cryptography - 20th International Conference, TCC 2022, Chicago, IL,USA, November 7-10, 2022, Proceedings, Part II, volume 13748 of Lecture Notes in ComputerScience, pages 502531. Springer, 2022. Surya Addanki, Kevin Garbe, Eli Jaffe, Rafail Ostrovsky, and Antigoni Polychroniadou. Prio+:Privacy preserving aggregate statistics via boolean shares. In Clemente Galdi and StanislawJarecki, editors, Security and Cryptography for Networks - 13th International Conference, SCN2022, Amalfi, Italy, September 12-14, 2022, Proceedings, volume 13409 of Lecture Notes inComputer Science, pages 516539. Springer, 2022. Shweta Agrawal, Xavier Boyen, Vinod Vaikuntanathan, Panagiotis Voulgaris, and Hoeteck Wee.Functional encryption for threshold functions (or fuzzy ibe) from lattices. In Marc Fischlin,Johannes Buchmann, and Mark Manulis, editors, PKC 2012: 15th International Conference onTheory and Practice of Public Key Cryptography, volume 7293 of Lecture Notes in ComputerScience, pages 280297. Springer, Berlin, Heidelberg, May 2012.",
  "Apple and Google. Exposure notification privacy-preserving analytics (ENPA), 2021": "Arasu Arun, Chaya Ganesh, Satya V. Lokam, Tushar Mopuri, and Sriram Sridhar. Dew:A transparent constant-sized polynomial commitment scheme. In Alexandra Boldyreva andVladimir Kolesnikov, editors, PKC 2023: 26th International Conference on Theory and Practiceof Public Key Cryptography, Part II, volume 13941 of Lecture Notes in Computer Science,pages 542571. Springer, Cham, May 2023.",
  "Thomas Attema, Ignacio Cascudo, Ronald Cramer, Ivan Bjerre Damgrd, and Daniel Escudero.Vector commitments over rings and compressed -protocols. Cryptology ePrint Archive, Report2022/181, 2022": "Abhishek Banerjee, Chris Peikert, and Alon Rosen. Pseudorandom functions and lattices.In David Pointcheval and Thomas Johansson, editors, Advances in Cryptology EURO-CRYPT 2012, volume 7237 of Lecture Notes in Computer Science, pages 719737. Springer,Berlin, Heidelberg, April 2012. Laasya Bangalore, Mohammad Hossein Faghihi Sereshgi, Carmit Hazay, and Muthuramakrish-nan Venkitasubramaniam. Flag: A framework for lightweight robust secure aggregation. InJoseph K. Liu, Yang Xiang, Surya Nepal, and Gene Tsudik, editors, ASIACCS 23: 18th ACMSymposium on Information, Computer and Communications Security, pages 1428. ACM Press,July 2023. Daniela Becker, Jorge Guajardo, and Karl-Heinz Zimmermann. Revisiting private streamaggregation: Lattice-based PSA. In ISOC Network and Distributed System Security Symposium NDSS 2018. The Internet Society, February 2018. James Bell, Adri Gascn, Tancrde Lepoint, Baiyu Li, Sarah Meiklejohn, Mariana Raykova,and Cathie Yun. ACORN: Input validation for secure aggregation. In 32nd USENIX SecuritySymposium (USENIX Security 23), pages 48054822, Anaheim, CA, August 2023. USENIXAssociation. James Henry Bell, Kallista A Bonawitz, Adri Gascn, Tancrde Lepoint, and Mariana Raykova.Secure single-server aggregation with (poly) logarithmic overhead. In Proceedings of the 2020ACM SIGSAC Conference on Computer and Communications Security, pages 12531269, 2020. James Bell-Clark, Adri Gascn, Baiyu Li, Mariyana Raykova, Phillipp Schoppmann, andPierre Tholoniat. Willow: Secure aggregation with one-shot clients. Theory and Practice ofMulti-Party Computation Workshop, 2024.",
  "Fabrice Benhamouda, Marc Joye, and BenoT Libert. A new framework for privacy-preservingaggregation of time-series data. ACM Trans. Inf. Syst. Secur., 18(3), mar 2016": "Alexander Bienstock, Daniel Escudero, and Antigoni Polychroniadou. On linear communicationcomplexity for (maximally) fluid MPC. In Helena Handschuh and Anna Lysyanskaya, editors,Advances in Cryptology CRYPTO 2023, Part I, volume 14081 of Lecture Notes in ComputerScience, pages 263294. Springer, Cham, August 2023. Keith Bonawitz, Vladimir Ivanov, Ben Kreuter, Antonio Marcedone, H. Brendan McMahan,Sarvar Patel, Daniel Ramage, Aaron Segal, and Karn Seth. Practical secure aggregation forprivacy-preserving machine learning. In Bhavani M. Thuraisingham, David Evans, Tal Malkin,and Dongyan Xu, editors, Proceedings of the 2017 ACM SIGSAC Conference on Computer andCommunications Security, CCS 2017, Dallas, TX, USA, October 30 - November 03, 2017, pages11751191. ACM, 2017. Dan Boneh, Benedikt Bnz, and Ben Fisch.Batching techniques for accumulators withapplications to IOPs and stateless blockchains. In Alexandra Boldyreva and Daniele Micciancio,editors, Advances in Cryptology CRYPTO 2019, Part I, volume 11692 of Lecture Notes inComputer Science, pages 561586. Springer, Cham, August 2019. Dan Boneh, Kevin Lewi, Hart William Montgomery, and Ananth Raghunathan. Key homo-morphic PRFs and their applications. In Ran Canetti and Juan A. Garay, editors, Advances inCryptology CRYPTO 2013, Part I, volume 8042 of Lecture Notes in Computer Science, pages410428. Springer, Berlin, Heidelberg, August 2013.",
  "Johannes Buchmann and Hugh C. Williams. A key-exchange system based on imaginaryquadratic fields. Journal of Cryptology, 1(2):107118, June 1988": "Benedikt Bnz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers.In Anne Canteaut and Yuval Ishai, editors, Advances in Cryptology EUROCRYPT 2020, Part I,volume 12105 of Lecture Notes in Computer Science, pages 677706. Springer, Cham, May2020. David Byrd, Maria Hybinette, and Tucker Hybinette Balch. Abides: Towards high-fidelity multi-agent market simulation. In Proceedings of the 2020 ACM SIGSIM Conference on Principles ofAdvanced Discrete Simulation, SIGSIM-PADS 20, page 1122, New York, NY, USA, 2020.Association for Computing Machinery. David Byrd, Vaikkunth Mugunthan, Antigoni Polychroniadou, and Tucker Balch. Collusionresistant federated learning with oblivious distributed differential privacy. In Proceedings of theThird ACM International Conference on AI in Finance, ICAIF 22, page 114122, New York,NY, USA, 2022. Association for Computing Machinery. Ignacio Cascudo and Bernardo David. SCRAPE: Scalable randomness attested by publicentities. In Dieter Gollmann, Atsuko Miyaji, and Hiroaki Kikuchi, editors, ACNS 17: 15thInternational Conference on Applied Cryptography and Network Security, volume 10355 ofLecture Notes in Computer Science, pages 537556. Springer, Cham, July 2017. Ignacio Cascudo and Bernardo David. Publicly verifiable secret sharing over class groupsand applications to DKG and YOSO. In Marc Joye and Gregor Leander, editors, Advances inCryptology EUROCRYPT 2024, Part V, volume 14655 of Lecture Notes in Computer Science,pages 216248. Springer, Cham, May 2024. Guilhem Castagnos, Dario Catalano, Fabien Laguillaumie, Federico Savasta, and Ida Tucker.Two-party ECDSA from hash proof systems and efficient instantiations. In Alexandra Boldyrevaand Daniele Micciancio, editors, Advances in Cryptology CRYPTO 2019, Part III, volume11694 of Lecture Notes in Computer Science, pages 191221. Springer, Cham, August 2019. Guilhem Castagnos, Dario Catalano, Fabien Laguillaumie, Federico Savasta, and Ida Tucker.Bandwidth-efficient threshold EC-DSA.In Aggelos Kiayias, Markulf Kohlweiss, PetrosWallden, and Vassilis Zikas, editors, PKC 2020: 23rd International Conference on Theory andPractice of Public Key Cryptography, Part II, volume 12111 of Lecture Notes in ComputerScience, pages 266296. Springer, Cham, May 2020. Guilhem Castagnos, Laurent Imbert, and Fabien Laguillaumie. Encryption switching protocolsrevisited: Switching modulo p. In Jonathan Katz and Hovav Shacham, editors, Advances inCryptology CRYPTO 2017, Part I, volume 10401 of Lecture Notes in Computer Science, pages255287. Springer, Cham, August 2017. Guilhem Castagnos and Fabien Laguillaumie. Linearly homomorphic encryption from DDH.In Kaisa Nyberg, editor, Topics in Cryptology CT-RSA 2015, volume 9048 of Lecture Notes inComputer Science, pages 487505. Springer, Cham, April 2015. Guilhem Castagnos, Fabien Laguillaumie, and Ida Tucker. Practical fully secure unrestrictedinner product functional encryption modulo p. In Thomas Peyrin and Steven Galbraith, editors,Advances in Cryptology ASIACRYPT 2018, Part II, volume 11273 of Lecture Notes inComputer Science, pages 733764. Springer, Cham, December 2018. Pyrros Chaidos and Geoffroy Couteau.Efficient designated-verifier non-interactive zero-knowledge proofs of knowledge. In Jesper Buus Nielsen and Vincent Rijmen, editors, Advancesin Cryptology EUROCRYPT 2018, Part III, volume 10822 of Lecture Notes in ComputerScience, pages 193221. Springer, Cham, April / May 2018. Jung Hee Cheon, Dongwoo Kim, Duhyeong Kim, Joohee Lee, Junbum Shin, and YongsooSong. Lattice-based secure biometric authentication for hamming distance. In Joonsang Baekand Sushmita Ruj, editors, ACISP 21: 26th Australasian Conference on Information Securityand Privacy, volume 13083 of Lecture Notes in Computer Science, pages 653672. Springer,Cham, December 2021. Jihoon Cho, Jincheol Ha, Seongkwang Kim, ByeongHak Lee, Joohee Lee, Jooyoung Lee,Dukjae Moon, and Hyojin Yoon. Transciphering framework for approximate homomorphicencryption. In Mehdi Tibouchi and Huaxiong Wang, editors, Advances in Cryptology ASI-ACRYPT 2021, Part III, volume 13092 of Lecture Notes in Computer Science, pages 640669.Springer, Cham, December 2021.",
  "Kevin Choi, Aathira Manoj, and Joseph Bonneau. SoK: Distributed randomness beacons. In2023 IEEE Symposium on Security and Privacy, pages 7592. IEEE Computer Society Press,May 2023": "Arka Rai Choudhuri, Aarushi Goel, Matthew Green, Abhishek Jain, and Gabriel Kaptchuk.Fluid MPC: Secure multiparty computation with dynamic participants. In Tal Malkin and ChrisPeikert, editors, Advances in Cryptology CRYPTO 2021, Part II, volume 12826 of LectureNotes in Computer Science, pages 94123, Virtual Event, August 2021. Springer, Cham. Jean-Sbastien Coron. On the exact security of full domain hash. In Mihir Bellare, editor,Advances in Cryptology CRYPTO 2000, volume 1880 of Lecture Notes in Computer Science,pages 229235. Springer, Berlin, Heidelberg, August 2000.",
  "Henry Corrigan-Gibbs. Privacy-preserving firefox telemetry with prio, 2020": "Henry Corrigan-Gibbs and Dan Boneh. Prio: Private, robust, and scalable computation ofaggregate statistics. In Aditya Akella and Jon Howell, editors, 14th USENIX Symposium onNetworked Systems Design and Implementation, NSDI 2017, Boston, MA, USA, March 27-29,2017, pages 259282. USENIX Association, 2017. Geoffroy Couteau, Dahmun Goudarzi, Michael Kloo, and Michael Reichle. Sharp: Shortrelaxed range proofs. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors,ACM CCS 2022: 29th Conference on Computer and Communications Security, pages 609622.ACM Press, November 2022. Geoffroy Couteau, Michael Kloo, Huang Lin, and Michael Reichle. Efficient range proofs withtransparent setup from bounded integer commitments. In Anne Canteaut and Franois-XavierStandaert, editors, Advances in Cryptology EUROCRYPT 2021, Part III, volume 12698 ofLecture Notes in Computer Science, pages 247277. Springer, Cham, October 2021. Ivan Damgrd and Rune Thorbek. Linear integer secret sharing and distributed exponentiation.In Moti Yung, Yevgeniy Dodis, Aggelos Kiayias, and Tal Malkin, editors, PKC 2006: 9thInternational Conference on Theory and Practice of Public Key Cryptography, volume 3958 ofLecture Notes in Computer Science, pages 7590. Springer, Berlin, Heidelberg, April 2006. Yi Deng, Shunli Ma, Xinxuan Zhang, Hailong Wang, Xuyang Song, and Xiang Xie. Promise -protocol: How to construct efficient threshold ECDSA from encryptions based on class groups.In Mehdi Tibouchi and Huaxiong Wang, editors, Advances in Cryptology ASIACRYPT 2021,Part IV, volume 13093 of Lecture Notes in Computer Science, pages 557586. Springer, Cham,December 2021. Nico Dttling, Dimitris Kolonelos, Russell W. F. Lai, Chuanwei Lin, Giulio Malavolta, andAhmadreza Rahimi. Efficient laconic cryptography from learning with errors. In Carmit Hazayand Martijn Stam, editors, Advances in Cryptology EUROCRYPT 2023, Part III, volume14006 of Lecture Notes in Computer Science, pages 417446. Springer, Cham, April 2023. Drand. Drand/drand: a distributed randomness beacon daemon - go implementation. Johannes Ernst and Alexander Koch. Private stream aggregation with labels in the standardmodel. Proc. Priv. Enhancing Technol., 2021(4):117138, 2021.",
  "Matthew K. Franklin and Moti Yung. Communication complexity of secure computation(extended abstract). In 24th Annual ACM Symposium on Theory of Computing, pages 699710.ACM Press, May 1992": "Niv Gilboa and Yuval Ishai. Distributed point functions and their applications. In Phong Q.Nguyen and Elisabeth Oswald, editors, Advances in Cryptology - EUROCRYPT 2014 - 33rdAnnual International Conference on the Theory and Applications of Cryptographic Techniques,Copenhagen, Denmark, May 11-15, 2014. Proceedings, volume 8441 of Lecture Notes inComputer Science, pages 640658. Springer, 2014. Noemi Glaeser, Matteo Maffei, Giulio Malavolta, Pedro Moreno-Sanchez, Erkan Tairi, andSri AravindaKrishnan Thyagarajan. Foundations of coin mixing services. Cryptology ePrintArchive, Report 2022/942, 2022.",
  "Yue Guo, Antigoni Polychroniadou, Elaine Shi, David Byrd, and Tucker Balch. MicroFedML:Privacy preserving federated learning for small weights. Cryptology ePrint Archive, Report2022/714, 2022": "Shai Halevi, Yuval Ishai, Eyal Kushilevitz, and Tal Rabin. Additive randomized encodingsand their applications. In Helena Handschuh and Anna Lysyanskaya, editors, Advances inCryptology - CRYPTO 2023 - 43rd Annual International Cryptology Conference, CRYPTO2023, Santa Barbara, CA, USA, August 20-24, 2023, Proceedings, Part I, volume 14081 ofLecture Notes in Computer Science, pages 203235. Springer, 2023. Shai Halevi, Yehuda Lindell, and Benny Pinkas. Secure computation on the web: Computingwithout simultaneous interaction. In Phillip Rogaway, editor, Advances in Cryptology - CRYPTO2011 - 31st Annual Cryptology Conference, Santa Barbara, CA, USA, August 14-18, 2011.Proceedings, volume 6841 of Lecture Notes in Computer Science, pages 132150. Springer,2011. Bargav Jayaraman, Lingxiao Wang, David Evans, and Quanquan Gu. Distributed learningwithout distress: privacy-preserving empirical risk minimization. In Proceedings of the 32ndInternational Conference on Neural Information Processing Systems, NIPS18, page 63466357,Red Hook, NY, USA, 2018. Curran Associates Inc. Marc Joye and Benot Libert. A scalable scheme for privacy-preserving aggregation of time-series data. In Ahmad-Reza Sadeghi, editor, FC 2013: 17th International Conference onFinancial Cryptography and Data Security, volume 7859 of Lecture Notes in Computer Science,pages 111125. Springer, Berlin, Heidelberg, April 2013. Peter Kairouz, H. Brendan McMahan, Brendan Avent, Aurlien Bellet, Mehdi Bennis, Ar-jun Nitin Bhagoji, Kallista A. Bonawitz, Zachary Charles, Graham Cormode, Rachel Cum-mings, Rafael G. L. DOliveira, Hubert Eichner, Salim El Rouayheb, David Evans, Josh Gardner,Zachary Garrett, Adri Gascn, Badih Ghazi, Phillip B. Gibbons, Marco Gruteser, Zad Har-chaoui, Chaoyang He, Lie He, Zhouyuan Huo, Ben Hutchinson, Justin Hsu, Martin Jaggi, Tara Javidi, Gauri Joshi, Mikhail Khodak, Jakub Konecn, Aleksandra Korolova, Farinaz Koushanfar,Sanmi Koyejo, Tancrde Lepoint, Yang Liu, Prateek Mittal, Mehryar Mohri, Richard Nock,Ayfer zgr, Rasmus Pagh, Hang Qi, Daniel Ramage, Ramesh Raskar, Mariana Raykova, DawnSong, Weikang Song, Sebastian U. Stich, Ziteng Sun, Ananda Theertha Suresh, Florian Tramr,Praneeth Vepakomma, Jianyu Wang, Li Xiong, Zheng Xu, Qiang Yang, Felix X. Yu, Han Yu,and Sen Zhao. Advances and open problems in federated learning. Found. Trends Mach. Learn.,14(1-2):1210, 2021. Aniket Kate, Easwar Vivek Mangipudi, Pratyay Mukherjee, Hamza Saleem, and Sri Aravinda Kr-ishnan Thyagarajan. Non-interactive VSS using class groups and application to DKG. Cryptol-ogy ePrint Archive, Report 2023/451, 2023. Duhyeong Kim, Dongwon Lee, Jinyeong Seo, and Yongsoo Song. Toward practical lattice-based proof of knowledge from hint-MLWE. In Helena Handschuh and Anna Lysyanskaya,editors, Advances in Cryptology CRYPTO 2023, Part V, volume 14085 of Lecture Notes inComputer Science, pages 549580. Springer, Cham, August 2023. Russell W. F. Lai and Giulio Malavolta. Subvector commitments with application to succinctarguments. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology CRYPTO 2019, Part I, volume 11692 of Lecture Notes in Computer Science, pages 530560.Springer, Cham, August 2019. Iraklis Leontiadis, Kaoutar Elkhiyaoui, and Refik Molva. Private and dynamic time-seriesdata aggregation with trust relaxation. In Dimitris Gritzalis, Aggelos Kiayias, and Ioannis G.Askoxylakis, editors, CANS 14: 13th International Conference on Cryptology and NetworkSecurity, volume 8813 of Lecture Notes in Computer Science, pages 305320. Springer, Cham,October 2014. Hanjun Li, Huijia Lin, Antigoni Polychroniadou, and Stefano Tessaro. LERNA: Secure single-server aggregation via key-homomorphic masking. In Jian Guo and Ron Steinfeld, editors,Advances in Cryptology ASIACRYPT 2023, Part I, volume 14438 of Lecture Notes in ComputerScience, pages 302334. Springer, Singapore, December 2023.",
  "Yehuda Lindell. How to Simulate It A Tutorial on the Simulation Proof Technique, pages277346. Springer International Publishing, Cham, 2017": "Helger Lipmaa. Secure accumulators from euclidean rings without trusted setup. In Feng Bao,Pierangela Samarati, and Jianying Zhou, editors, ACNS 12: 10th International Conferenceon Applied Cryptography and Network Security, volume 7341 of Lecture Notes in ComputerScience, pages 224240. Springer, Berlin, Heidelberg, June 2012. Zizhen Liu, Si Chen, Jing Ye, Junfeng Fan, Huawei Li, and Xiaowei Li. SASH: efficientsecure aggregation based on SHPRG for federated learning. In James Cussens and Kun Zhang,editors, Uncertainty in Artificial Intelligence, Proceedings of the Thirty-Eighth Conference onUncertainty in Artificial Intelligence, UAI 2022, 1-5 August 2022, Eindhoven, The Netherlands,volume 180 of Proceedings of Machine Learning Research, pages 12431252. PMLR, 2022. Hidde Lycklama, Lukas Burkhalter, Alexander Viand, Nicolas Kchler, and Anwar Hithnawi.RoFL: Robustness of secure federated learning. In 2023 IEEE Symposium on Security andPrivacy, pages 453476. IEEE Computer Society Press, May 2023. Vadim Lyubashevsky, Chris Peikert, and Oded Regev. On ideal lattices and learning with errorsover rings. In Henri Gilbert, editor, Advances in Cryptology EUROCRYPT 2010, volume 6110of Lecture Notes in Computer Science, pages 123. Springer, Berlin, Heidelberg, May / June2010. Yiping Ma, Jess Woods, Sebastian Angel, Antigoni Polychroniadou, and Tal Rabin. Flamingo:Multi-round single-server secure aggregation with applications to private federated learning. In2023 IEEE Symposium on Security and Privacy, pages 477496. IEEE Computer Society Press,May 2023.",
  "K. MCCURLEY. Cryptographic key distribution and computation in class groups. Proceedingsof NATO ASI Number Theory and applications, pages 459479, 1989": "Moni Naor, Benny Pinkas, and Omer Reingold. Distributed pseudo-random functions andKDCs. In Jacques Stern, editor, Advances in Cryptology EUROCRYPT99, volume 1592 ofLecture Notes in Computer Science, pages 327346. Springer, Berlin, Heidelberg, May 1999. Dinh Duy Nguyen, Duong Hieu Phan, and David Pointcheval. Verifiable decentralized multi-client functional encryption for inner product. In Jian Guo and Ron Steinfeld, editors, Advancesin Cryptology ASIACRYPT 2023, Part V, volume 14442 of Lecture Notes in Computer Science,pages 3365. Springer, Singapore, December 2023. Johannes Ottenhues and Alexander Koch. LaPSuS - A lattice-based private stream aggregationscheme under scrutiny. In Clemente Galdi and Duong Hieu Phan, editors, SCN 24: 14thInternational Conference on Security in Communication Networks, Part II, volume 14974 ofLecture Notes in Computer Science, pages 228248. Springer, Cham, September 2024. Dario Pasquini, Danilo Francati, and Giuseppe Ateniese. Eluding secure aggregation in federatedlearning via model inconsistency. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi,editors, ACM CCS 2022: 29th Conference on Computer and Communications Security, pages24292443. ACM Press, November 2022. Christopher Patton, Richard Barnes, and Phillipp Schoppmann. Verifiable Distributed Aggre-gation Functions. Internet-Draft draft-patton-cfrg-vdaf-01, Internet Engineering Task Force,March 2022. Work in Progress. Andrea Dal Pozzolo, Olivier Caelen, Reid A. Johnson, and Gianluca Bontempi. Calibratingprobability with undersampling for unbalanced classification. In 2015 IEEE Symposium Serieson Computational Intelligence, pages 159166, 2015. Mayank Raikwar and Danilo Gligoroski. SoK: Decentralized randomness beacon protocols.In Khoa Nguyen, Guomin Yang, Fuchun Guo, and Willy Susilo, editors, ACISP 22: 27thAustralasian Conference on Information Security and Privacy, volume 13494 of Lecture Notesin Computer Science, pages 420446. Springer, Cham, November 2022. Mayank Rathee, Conghao Shen, Sameer Wagh, and Raluca Ada Popa. Elsa: Secure aggregationfor federated learning with malicious actors. In 2023 IEEE Symposium on Security and Privacy(SP), pages 19611979, 2023. Mayank Rathee, Conghao Shen, Sameer Wagh, and Raluca Ada Popa. ELSA: Secure aggrega-tion for federated learning with malicious actors. In 2023 IEEE Symposium on Security andPrivacy, pages 19611979. IEEE Computer Society Press, May 2023.",
  "Adi Shamir. How to share a secret. Communications of the Association for ComputingMachinery, 22(11):612613, November 1979": "Elaine Shi, T.-H. Hubert Chan, Eleanor G. Rieffel, Richard Chow, and Dawn Song. Privacy-preserving aggregation of time-series data. In ISOC Network and Distributed System SecuritySymposium NDSS 2011. The Internet Society, February 2011. Victor Shoup. Practical threshold signatures. In Bart Preneel, editor, Advances in Cryptology EUROCRYPT 2000, volume 1807 of Lecture Notes in Computer Science, pages 207220.Springer, Berlin, Heidelberg, May 2000. Jonathan Takeshita, Zachariah Carmichael, Ryan Karl, and Taeho Jung. TERSE: tiny encryp-tions and really speedy execution for post-quantum private stream aggregation. In FengjunLi, Kaitai Liang, Zhiqiang Lin, and Sokratis K. Katsikas, editors, Security and Privacy inCommunication Networks - 18th EAI International Conference, SecureComm 2022, VirtualEvent, October 2022, Proceedings, volume 462 of Lecture Notes of the Institute for ComputerSciences, Social Informatics and Telecommunications Engineering, pages 331352. Springer,2022.",
  "A.1Secret Sharing": "A key component of threshold cryptography is the ability to compute distributed exponentiationby sharing a secret. More formally, the standard approach is to compute gs for some g P Gwhere G is a finite group and s is a secret exponent that has been secret-shared among multipleparties. This problem is much simpler when you assume that the group order is a publicly knownprime p which then requires you to share the secret over the field Zp. This was the observation ofShamir whereby a secret s can be written as a linear combination of iPS isi mod p whereS is a set of servers that is sufficiently large and holds shares of the secret si and i is only afunction of the indices in S. It follows that if each server provides gi gsi, then one can computegs g",
  "jPS: If |S| r, then output jPS j spjq where tju CoeffpSq": "The correctness of the scheme guarantees that the secret s is correctly reconstructed.Construction 7 (Packed Secret Sharing over Fq). Consider the following pt, r, mq Secret SharingScheme where m is the total number of parties, t is the corruption threshold, r is the threshold forreconstruction. Further, let be the number of secrets being packed which are to be embedded atpoints pos1, . . . , pos where posi m ` i. Here, t : r . Then, we have the following scheme:",
  "For security, we require that pr q m C where C is the corruption rate": "Combining, we get m {p1 C Cq. Recall that we need C ` C 1{3, for byzantine faulttolerance. In other words, setting m 3{2 is sufficient.Remark 3 (Optimizations for Packed Secret Sharing). Observe that the polynomial LipXq is onlydependent on points posi, which are the points where the secrets are embedded. This can be pre-processed, and indeed, can be a part of the setup algorithm which distributes it to all the clients.Furthermore, rather than naively reconstructing the Lagrange polynomial, one can also rely on FFTtechniques to achieve speed up. Unfortunately, the above protocols do not extend to settings where the order of the group is not prime,not publicly known, or even possibly unknown to everyone. In this setting, the work of Damgrd andThorbek presents a construction to build Linear Integer Secret Sharing (LISS) schemes. In this work,we rely on the simpler scheme that extends Shamirs secret sharing into the integer setting from thework of Braun et al. . We also extend the Packed Secret Sharing scheme to this integer setting inConstruction 9.Definition 2 (Secret Sharing over Z). A pt, r, mq Linear Integer Secret Sharing Scheme LISS is a tupleof PPT algorithms LISS : pShare, GetCoeff, Reconstructq, with the following public parameters:the statistical security parameter s, the number of parties m, the corruption threshold t, andreconstruction threshold r of secrets needed for reconstruction, the randomness bit length r, the bitlength of the secret s and the offset by which the secret is multiplied, denoted by m!, and thefollowing syntax:",
  "where f is some publicly computable function, usually fpsq 2 s": "Statistical Privacy : We say that a pt, r, mq linear integer secret sharing schemeLISS is statistically private if for any set of corrupted parties C rms with |C| t,and any two secrets s, s1 P r0, 2sq and for independent random coins , 1 such thattsiuiPrms $ Shareps; q, tsiu1iPrms $ Shareps1; 1q we have that the statistical distancebetween: tsi|i P Cu and ts1i|i P Cu is negligible in the statistical security parameter s. Construction 8 (Shamirs Secret Sharing over Z). Consider the following pt, r, mq Integer SecretSharing scheme where m is the number of parties, t is the corruption threshold, and r is the thresholdfor reconstruction. Further, let s be a statistical security parameter. Let s be the bit length of thesecret and let r be the bit length of the randomness. Then, we have the following scheme:",
  "Theorem 5 (). Construction 8 is statistically private provided r s`rlog2phmaxpt1qqs`1where hmax is an upper bound on the coefficients of the sweeping polynomial": "We refer the readers to the proof in [21, B.1]. The key idea behind the proof is first to show that thereexists a sweeping polynomial such that at each of the points that the adversary has a share of, thepolynomial evaluates to 0 while at the point where the secret exists, it contains the offset . Implicitly,one can add the sweeping polynomial to the original polynomial whereby the sweeping polynomial\"sweeps\" away the secret information that the adversary has gained knowledge of. Meanwhile, inthe later section, we present the proof for the generic construction that uses Shamirs Packed SecretSharing over the integer space. This again uses the idea of a sweeping polynomial.Construction 9 (Shamirs Packed Secret Sharing over Z). Let m be the number of parties and be the number of secrets that are packed in one sharing. Further, let t denote the threshold forreconstruction (implies that corruption threshold is t ). Then, consider the following pm, t, qInteger Secret Sharing Scheme with system parameters s as the statistical security parameter, sis the bit length of the a secret, and let r be the bit length of the randomness. Then, we have thefollowing scheme:",
  "mial fpxq": "jPrts ij spjq by correctness of Lagrange Interpolation. Consequently, fpposiq wouldreturn si 2. However, we compute ij instead, by multiplying with to remove need for division.Consequently, the resulting polynomial has multiplied throughout yielding a 3 as the total offset. Definition 3 (Vector of Sweeping Polynomials). Let C rms such that |C| t . Then, wehave a vector of sweeping polynomials, denoted by spCpXq psp1,C, . . . , sp,Cq where spi,CpXq :tj0 spi,j Xj P ZrXst1 is the unique polynomial whose degree is at most t 1 such thatspi,Cpm ` iq 2, spi,Cpm ` jq 0 for j P rs, j i, and spi,Cpjq 0 for all j P C. Further, onecan define spmax as the upper bound for the coefficients for the sweeping polynomials, i.e., spmax :spi,j|i P t1, . . . , u , j P t0, . . . , t 1u(",
  "poskposj . and qpXq is a random polynomial of degree t 1": "Now observe that the adversary see |C| t shares corresponding to fpijq for ij P C. ByLagrange interpolation, this induces a one-to-one map from possible secrets to corresponding sharingpolynomials. Specifically, we can use the vector of sweeping polynomials, as defined in Definition 3to explicitly map any secret vector s to its sharing polynomial defined by fpXq ` xs s, spCpXqy",
  "k1psk skq spk,CpXq": "Now, observe that fpm`1q s1 p2q. Meanwhile, sp1,Cpm`1q 2 while spj,Cpm`1q 0 for1 j . This simplifies to: f pm ` 1q s1 2 ` ps1 s1q 2 s1 2. However, while wehave an efficient mapping, note that f pXq could have coefficients that are not of the prescribed form,i.e., coefficients do not lie in the range r0, 2r`sq. We will call the event good if the coefficients liein the range and bad even if one of the coefficients does not lie in the range.",
  "Now, observe that if f 1pXq was a good polynomial, then f 1pjq fpjq for every j P C. It followsthat if f 1 was good, then an adversary cannot distinguish whether the secret vector was s or s1": "We will now upper bound the probability that f 1 was bad in at least one of the coefficients. Weknow that |s1k sk| P r0, 2sq for k 1, . . . , . Further all coefficients of spk,CpXq are upperbounded by spmax. Therefore, to any coefficient of fpXq, the maximum perturbation in value is:2s spmax . Therefore, one requires that the original coefficients of f be sampled such that theylie in r2s spmax , 2r`s 2s spmax s. In other words, the probability that one coefficient off 1 is bad is:2 2s spmax",
  "A.2.1Learning with Rounding Assumption": "We will begin by defining the learning with rounding (LWR) assumption, which can be viewed asa deterministic version of the learning with errors (LWE) assumption . LWR was introduced byBanerjee et al. . Definition 4 (Learning with Rounding). Let , q, p $ LWRGenp1q with , q, p P N such that q p.Then, the Learning with Rounding assumption states that for all PPT adversaries A, there exists anegligible function negl such that:",
  "where is the security parameter": "Kim et al. demonstrates that the Hint-LWE assumption is computationally equivalent to thestandard LWE assumption. In essence, this assumption posits that y0 maintains its pseudorandomproperties from an adversarys perspective, even when provided with certain randomized informationabout the secret and error vectors. Consider a secure LWE instance defined by parameters p, m, q, q,where represents a discrete Gaussian distribution with standard deviation . The correspondingHint-LWE instance, characterized by p, m, q, 1q, where 1 denotes a discrete Gaussian distributionwith standard deviation 1, remains secure under the condition 1 {?",
  "Definition 9 (Distributed Key Homomorphic PRF (DPRF)). A pt, mq-Distributed PRF is a tuple ofPPT algorithms DPRF : pGen, Share, Eval, P-Eval, Combineq with the following syntax:": "ppPRF $ Genp1, 1t, 1mq: On input of the threshold t and number of parties m, andsecurity parameter , the Gen algorithm produces the system parameter ppPRF which isimpliclty consumed by all the other algorithms. kp1q, . . . , kpmq $ Sharepk, t, r, mq: On input of the number of parties m, corruption thresh-old t, reconstruction threshold r, and a key k $ K, the share algorithm produces the keyshare for each party.",
  "A.5Class Groups Framework": "Class group-based cryptography is a cryptographic technique that originated in the late 1980s, withthe idea that the class group of ideals of maximal orders of imaginary quadratic fields may be moresecure than the multiplicative group of finite fields . The CL framework was first introducedby the work of Castagnos and Laguillaumie . This framework operates on a group wherethere exists a subgroup with support for efficient discrete logarithm construction. Subsequent works have refined the original framework. The framework has been used in variousapplications over the years . Meanwhile, class group cryptographyitself has been employed in numerous applications .",
  "the group exponent of pGp. Then, the order of any x P pGp divides s.5": "Remark 4. The motivations behind these additional distributions are as follows. One can efficientlyrecognize valid encodings of elements in pG but not G. Therefore, a malicious adversary A can run ourconstructions by inputting elements belonging to pGp (rather than in H). Unfortunately, this maliciousbehavior cannot be detected which allows A to obtain information on the sampled exponents modulos (the group exponent of pGp). By requiring the statistical closeness of the induced distribution touniform in the aforementioned groups allows flexibility in proofs. Note that the assumptions donot depend on the choice of these two distributions. Further, the order s of H and group exponents of pGp are unknown and the upper bound s is used to instantiate the aforementioned distribution.Specifically, looking ahead we will set DH to be the uniform distribution over the set of integersrBs where B 2s s. Using Lemma 8, we get that the distribution is less than 2s away fromuniform distribution in H. In our constructions we will set s 40. We will make this samplingmore efficient for our later constructions. We refer the readers to Tucker [90, 3.1.3, 3.7] for morediscussions about this instantiation. Finally, as stated we will also set pD D and pDH DH. We also have the following lemma from Castagnos, Imbert, and Laguillaumie which defineshow to sample from a discrete Gaussian distribution.Lemma 8. Let G be a cyclic group of order n, generated by g. Consider the random variable Xsampled uniformly from G; as such it satisfies PrrX hs 1",
  "pX, Y q 2": "Remark 5. By definition, the distribution tgx : x $ Du is statistically indistinguishable fromtgy : y $ t0, . . . , p s 1uu. Therefore, it follows that tx mod p s : x $ Du is statistically in-distinguishable from tx : x $ t0, . . . , p s 1uu. Similarly, tx mod s : x $ Dpu is statisticallyindistinguishable from tx : x $ t0, . . . , s 1uu. Furthermore, sampling a value x corresponding toD is statistically indistinguishable from the uniform distribution in t0, . . . , s 1u because s dividesp s.Definition 10 (Class Group Framework). The framework is defined by two algorithmspCLGen, CLSolveq such that:",
  "` neglpq": "When dealing with groups of known order, one can sample elements in a group G easily by merelysampling exponents modulo the group order and then raising the generator of the group to thatexponent. Unfortunately, note that here neither the order of G (i.e., ps) nor that of H (i.e. s) is known.Therefore, we instead use the knowledge of the upper-bound s of s to instantiate the distributions Dand Dp respectively. This choice of choosing from the distributions D and Dp respectively allows forflexibility of various proofs.",
  ": Our Naive Construction of OPA using just a secret sharing scheme": "Remark 6. It is important to make a few observations. This solution resembles a multi-serversolution where the clients simply secret-share the inputs with each server, and the servers collaborateto recover the sum. However, this observation also implies that the role of the committee members,while running a deterministic procedure, is proportional to the length of the input. This is undesirableas these committee members are simply other clients and such a heavy computation is undesirable. It is also to be noted that even a simple solution such as using a one-time pad to mask the input, andthen secret share the mask suffers from the same bottleneck as the mask has to be at least the lengthof the input. Computation Performance of OPALWR vs Naive Solution.We now list the computation costs thatwere measured. Note that these experiments were done for L 1. The motivation behind theseexperiments was to study how the two constructions fared across the computation time incurred bythe Naive Solution and OPALWR, without any optimizations including packed secret sharing. Our experiments indicate that, in addition to the significant savings in communication cost, OPALWRoutperforms the Naive Solution when it comes to the performance of the committee. While thethe role of the committee is the same in both constructions, the cost of the committee for OPALWRdoes not scale linearly with the input, while the naive solution incurs a linear growth cost. Further,note that currently, OPALWR requires the committee to add shares of 211 elements. It is clear whenaggregating vectors of length 211, OPALWR will outperform the naive solution. Meanwhile, it seemsclear that OPALWRs client cost which involves secret sharing the seed and then masking a vector oflength L will be slower than simply secret sharing a vector of length L. Similarly, the cost of simply",
  ": Comparison of Running Times between OPALWR and the Naive Solution. Values that scalelinearly with n are marked with a slash on the entries": "reconstructing the summed up vectors of length for the server in the naive solution will be better thanthe multi-step process of OPALWR which includes reconstructing the seed, then evaluating the saidseed, before finally unmasking. For completeness, we plot the server and client costs comparisonin . Note that we have scaled the costs, in the case of the naive solution, by 100 (i.e., if theactual cost was 1 unit, we plotted it as 100 units).",
  "CConstructions in CL Framework": "Construction 10 (PRF in CL Framework). Let pCLGen, CLSolveq be the class group framework asdefined in Definition 10. Then, let ppCL $ CLGenp1c, 1sq. Further, let H : X H, H1 : X Kbe a hash function. Then, consider the following definition of K DH, X t0, 1u, Y H,FCLpk, xq HpxqkH1px,1q.Remark 7. Note that the order of H is unknown. Therefore, one has to rely on DH to hash intoH. Most recently, showed how to hash into groups of unknown order to ensure that discretelogarithm is unknown. However, for our applications, this is not a concern. Indeed, one can simplycompute the hash function as hH1pxq where H1pxq hashed in DH.",
  "C.1Distributed PRF in CL Framework": "We build our construction of Distributed PRF from the Linear Secret Sharing Scheme LISS :pShare, GetCoeff, Reconstructq with ppSS denoting the public parameters of the LISS scheme. Wespecifically employ the Shamir Secret Sharing scheme over the Integers, as defined in .Construction 11 (Distributed PRF in CL Framework). A pr, mq-Distributed PRF is a tuple of PPTalgorithms DPRF : pGen, Share, Eval, P-Eval, Combineq with the algorithms as defined in .For simplicity, in the construction below we will set the corruption threshold t r 1. Though, theconstruction also holds for a lower t. Theorem 10. In the Random Oracle Model, if Construction 10 is a secure pseudorandom function ifInteger Secret Sharing is statistically private, then Construction 11 is pseudorandom in the staticcorruptions setting.",
  "D.1Distributed PRF from LWR": "Let us revisit Construction 14. First, observe that the key space is from Zq which implies that theorder of K is known. Further, the computation occurs over a group whose structure and order isknown. This is a departure from the construction based on the HSMM assumption. Consequently,by assuming that both p and q are primes, one can avoid integer secret sharing but instead rely ontraditional Shamirs Secret Sharing over a field, which we defined earlier (see Construction 6).",
  "T Fpk1, xq FpT k0, xq eT": "where eT P 0, . . . , T. This becomes a cause for concern as, in the threshold construction usingthe Shamir Secret Sharing over the field as shown in Construction 6, one often recombines bymultiplying with a Lagrange coefficient ij. Unfortunately, multiplying the result by ij impliesthat the error term eij P t0, . . . , iju. The requirement is that this error term should not becometoo large. However, interpreting Lagrange coefficients as elements in Zp results in the error termfailing to be low-norm leading to error propagation. To mitigate this, we use techniques quite similarto Construction 8 by essentially clearing the denominator by multiplying with : m!. This is atechnique made popular by the work of Shoup and later used in several other works including inthe context of lattice-based cryptography by Agrawal et al. and later to construct a distributedkey homomorphic PRF from any almost key homomorphic PRF by Boneh et al. . 6 Then, thecombine algorithm will simply multiply all partial evaluations with as well.",
  "Construction 13 (Distributed Almost Key Homomorphic PRF from LWR). A pt, mq-Distributed PRFis a tuple of PPT algorithms DPRF : pGen, Share, Eval, P-Eval, Combineq with the algorithms asdefined in": "Issues with the Construction from Boneh et al. [19, 7.1.1]. As remarked earlier, their genericconstruction suffers from issues stemming from their security reduction. Specifically, their securityreduction proceeds similarly to the proof of Theorem 10 and requires B to answer honest evaluationqueries for key indices for which it does not know the actual key share. Their explanation suggeststhat we again use the clearing out the denominator trick by multiplying with . However, the issueis that the resulting response will be of the form Fpki, xq for i, unknown to B. Consequently,",
  ": In this figure, we present the modified steps for OPA1. For simplicity, we present only thesemi-honest construction. For malicious security, we augment similarly with a second mask": "one has to change the partial evaluation response to also include this offset to ensure the correctnessof reduction. This would imply that the Combine algorithm will multiply with again, which wouldthus result in the actual Eval algorithm having an offset of 2. Furthermore, the partial evaluationalgorithm should also have to round down to the elements in r0, u 1s for the same reason that theCombine algorithm required this fix.",
  "ffiffiffifl": "uThe last step follows provided the error term is small. Recall that et P t0, . . . , tu and eij P0, . . . , ij(. Now observe that we multiply with and ij has a maximum value . Therefore, eij 2. Therefore, the size of the error term is t ` t 2. Therefore, provided u ischosen such that tp{uu p ` 1q t , then the last step is correct. Now, we have:",
  "provided tu{vu t": "Pseudorandomness. The proof of pseudorandomness follows the outline of the proof of Theorem 10but with some important differences. First, we do not rely on integer secret sharing but rather plainsecret sharing over the field. Therefore, the Lagrange coefficients correspond to ij. Or moreformally, to respond to a partial evaluation query at point xj with target key index i, the adversary Bdoes the following: Use its oracle to get partial evaluation on xj at it, which we call as hj,t. Then, use Lagrange coefficients but with suitably multiplying with to compute the correctdistribution by rounding down to u. The choice of u guarantees that the response is correct.",
  "D.2One-shot Private Aggregation Construction based on LWR Assumption": "We build OPA based on the LWR Assumption, building it based on the Key Homomorphic, DistributedPRF as presented in Construction 14. However, our construction is largely different from thetemplate followed to build OPA from the HSMM assumption. This is primarily because of the growthin error when combining partial evaluations. Specifically, will get that P-Evalpni1 kpjqi , xq ni1 P-Evalpkpji , xq ` e where e P t0, . . . , n 1u where n is the number of clients participatingfor that label. This would require us to round down to a new value u1 such that tu{u1u n 1.Therefore, while we still employ the underlying functions of the distributed, key-homomorphic PRFbased on LWR, we have to open up the generic reduction. For simplicity, we detail the constructionfor L 1. Then, these are the differences:",
  "E.2Learning with Errors Assumption": "Construction 16 (Key Homomorphic PRF from LWE). Let HA : X ZLq. Then, define theefficiently computable function FLWE : pZq Lq X ZLq as FLWEppk, eq, xq : HApxqk ` e.FLWE is an almost key homomorphic PRF. Remark 8. We note that it has been shown that one can also sample x from the same distribution ase. This is known as the short-secret LWE assumption and was employed in the encryption schemeof Lyubashevsky et al. . An immediate consequence of this assumption is that one can set Asdimension m to be much smaller than what is required for the LWE assumption. Similar to the LWR construction, we need to show that the PRF based on LWE assumption is alsoleakage resilient. Unfortunately, a similar proof technique does not work because the constructionalso suffers from leakage on the error vector which are usually Gaussian secrets. Instead, we rely onthe following assumption:",
  "FDeferred Proofs": "Theorem 2. Let s and c be the statistical and computational security parameters. Let L be theinput dimension and n be the number of clients, that are polypcq. Let be the dropout thresholdand be the corruption threshold such that ` 1. Then, there exists an efficient simulator Simsuch that for all K rns such that |K| n, inputs X txi,uiPnzK, and for all adversaries Aagainst Construction 3, that controls the server and the set of corrupted clients K, which behavesemi-honestly (resp. maliciously), the output of Sim is computationally indistinguishable from thejoint view of the server and the corrupted clients. Sim is allowed to query F D,pXq (defined inEquation 1) once, per iteration. Proof. We will prove the theorem statement by defining a simulator Sim, through a sequence ofhybrids such that the view of the adversary A between any two subsequent hybrids are computationallyindistinguishable. Let H rnszK, which are the set of honest clients. Further, let C rnszD whereD is the set of dropout clients. It is important to note that the server is semi-honest. Therefore, it is expected to compute the setintersection of online clients C, as expected. In other words, all committee members (and specificallythe honest committee members) receive the same C. This is an important contrast from activeadversaries as a corrupt and active server could deviate from expected behavior and send differentCpjq, for different committee members. This could help it glean some information about the honestclients.",
  "Hybrid1pq: In this hybrid, we will rely on the security of the secret sharing scheme to do two things:": "On the one-hand, all corrupt committee members receive a random share from thehonest clients seed. Note that there can be only a maximum of t corrupt committeemembers. By appropriately choosing m, conditioned on , we can guarantee that thisholds with overwhelming probability. Then, for an honest client i, these are the sharesdenoted by!sdpjqi)",
  "jPrmsXK and are generated randomly": "On the other hand, all the honest committee members receive a valid share of the honestclients seeds. However, each honest client i need to generate this from a polynomialppXq that satisfies pp0q sdi, while also ensuring ppjq sdpjqifor j P rms X K. Notethat this is a polynomial time operation and is similar to the way packed secret sharingis done where multiple secrets are embedded at distinct points of the polynomial. SeeConstruction 7 for how to build such a polynomial.",
  "Hybrid3pq: Again, without loss of generality, let client 1 be the first honest client in C X H. We willmodify the way ct1, is generated. We will set it as ct1, : x1, ` u where u $ PRG.Y": "Hybrid2, Hybrid3 are indistinguishable, provided Theorem 1 holds. In the reduction, wewill implicitly set sd1 ` sdn to be the leakage obtained from the Theorem 1s challenger. Inthis hybrid, Sim still continues to know all the inputs. If it was a real PRG output, then wecan simulate Hybrid2, while simulating Hybrid3 in the random case.",
  "Hybrid4pq: In this hybrid, we will replace ct1,: u1 for u1 $ PRG.Y.It is clear thatHybrid3, Hybrid4 are identically distributed": "At this point, observe that we have successfully replace the first honest clients ciphertext, with auniformly random value that is independent of its input. Sim will continue to do this modification forevery non-dropout honest client i P C X H. This leaves the clients with all-but-the-last honest clientsciphertext to be independent of the input, while leaving the last honest clients ciphertext to be only afunction of the sum of the inputs, which can be obtained by Sims query to the functionality. Simbeings its interaction with the functionality. After all the honest clients have provided inputs to thetrusted party T , in Step (b), Sim does not instruct any corrupted client to abort but rather set theirinputs to be 0. Then in Step (c), Sim does not abort the server. Therefore, in Step (d), Sim will learnthe sum of the honest parties inputs. Denote it as x, which is also the sum of the inputs of the honest,surviving clients. With this information, Sim uses the last hybrid to interact with the adversary A,whos expecting the real world interaction. This will enable Sim to run A internally. This is crucial toensure that Sim can get the output of A, in the real world, which might depend on its view (includingthe output) of the server. This view will, in turn, depend on the the honest clients inputs. Since Simsets the honest inputs, in this internal execution, to match the sum of inputs in the real world, we canguarantee that the output of A in the internal simulation is indistinguishable from As interaction inthe real world by the aforementioned hybrid arguments. Proof of Security against Active Server. Our constructions so far have relied on providing securityagainst a semi-honest server. Note that, as shown in the proof of security for Theorems 2, we can usethe functionality query to obtain the sum of all the honest non-drop out clients, as before. In the semi-honest setting, it is easy to see that the set C, with respect to which aggregation isperformed, includes all the honest, non-dropout clients inputs. Therefore, querying the functionality,Sim does indeed get the sum of all the honest clients inputs that are also included in the summationin the real world. This is imperative to ensure that Sim, when internally invoking A, can get theoutput of A which should be indistinguishable from As output in the real world. Specifically, thisoutput of A (in either the internal invocation or the actual execution) will depend on the view whichconsists of the output of the server. Therefore, if the output of the server in the real world does notinclude any of these honest clients inputs, then the output produced by the internal invocation of Acan be different from that in the real world. Let us look at the case when the server is corrupted. Such a server can mount an attack whereby thereal-world execution of the protocol may exclude inputs of some of those honest parties but actuallyincluded in the output of the ideal functionality. The proof of malicious security is tricky in thissetting. Specifically, a malicious server can drop clients after seeing the honest input. This is an issuein the simulation as the simulator has to generate the masked inputs for the honest clients withoutknowing which of them would be dropped later. Prior works, beginning with that of Bonawitz et al. have relied on using signatures to ensure thata malicious server does not compromise the privacy of an honest user. Fortunately, for OPA, we canrely on the one-shot nature of communication flow to secure messages and avoid using signatures. As before, let K denote the corrupted clients. Then, HCli : rnszK is the set of honest clients,HCom : rmszK is the set of honest committee members. Let KCli : rns X K denote the corruptedclients and KCom : rms X K denotes the corrupted committee members. Note that we do not rely on signatures. To achieve a protocol with signatures, there needs to bean additional round of communication between the committee members and the server. First, theserver forwards the message to the committee members. Then, the committee members respondswith their set Cpjq, which is also duly signed. Then, the server performs the intersection and contactsthe committee member with this intersection along with signatures. A committee member then onlyaggregates if there are pm ` tq{2 valid signatures. Our focus is to ensure that the committee members only speaks once. In other words, our constructioncurrently has the server identify Cpjq, for each j P rms, based on the information it has received fromthe client. Then, the server forwards the message to the committee member along with its computedintersection. This setting allows the server to selectively forward shares to committee member andalso choose different sets for different committee members. We will show that if r pm ` tq{2where r is the reconstruction threshold in the committee and t is the corruption threshold, then the",
  "server doing so will receive meaningless information. Formally, we will show that there does notexist two sets of users C C1 such that the server can reconstruct the shares over these two sets": "Observe that the server controls t committee members. We require each honest committee member toparticipate once, per iteration. This is easily enforced as the share from the honest client encrypts,along with the share for the honest committee member, also the identity of the honest client andthe iteration count. Therefore, a server cannot replay the same share, in another iteration. With thisguarantee, a malicious server, in order to reconstruct the shares of two distinct sets C, C1, will requirethe cooperation of at least r t honest users, while there are r t honest users present. We willtherefore need 2pr tq m t. Or, r pm ` tq{2. This ensures that the server can only effectivelyreconstruct with respect to a unique set C and H is the set of honest users in this set. Note that theabove inequality holds for r 2 m{3, t m{3. Indeed, prior works such as Bonawitz et al. and most recently LERNA also tolerated only upto a m{3 corruption threshold. While we have shown that there is a unique set H of honest users, H is only revealed after all thehonest clients have sent their inputs. Therefore, the simulator, during its internal execution of A,needs to be able to generate the masked inputs for the honest users and it only knows the sum of allthe honest clients that have not dropped out. This set may be distinct from H. Therefore, we needa way for the simulator to generate masked inputs, independent of the sum of the inputs, and thenensure that the correct sum is computed during reconstruction.",
  "Sets cti, : maski, ` mask1i,": "Like shown in proof of Theorem 2, the shares of sdpjqi, , digpjqi, for corrupt committeemembers j P KCom are chosen at random. Meanwhile, the shares for the honestcommittee members are to be sampled in the second phase, with a specific purpose.However, the server still expects an encryption of shares from honest client to honestcommittee members. Therefore, it simply encrypts some random shares for the honestcommittee members too and sends it to the server.",
  "This concludes the client phase of the operation. Then, comes the interaction with thecommittee. Note that the simulator is also required to simulate the honest committeemember j": "The simulator, which has received Cpjq for each honest committee member j does the checkto make sure that there exists at least r t such committee members with the same Cpjq.We will call this client set as C, while calling the set of these committee members to beCgood. Meanwhile, it records those committee members with a different Cpjq. We will callthis as some set Cbad. Looking ahead, for those honest committee members in Cbad, theshares of the honest clients that are to be added up is going to be random values. Note that|Cbad| m r.",
  "If j P Cbad, then for honest client i P Cpjq X HCli, set sdpjqi, , digpjqi, to be random values": "Now, the simulator computes the shares for all honest clients i to j P Cgood. These arevalid shares of sdi,, digi, subject to the constraint that random values were fixed forthose j P Cbad where i P Cpjq, and for those j P KCom. The honest committee member j receives from A, sdpjqi, and digpjqi, for i P Cpjq. Notethat the maximum number of prefixed values is m r ` t, and by our constraintr m r ` t which guarantees that these prefixed values cannot uniquely determine apolynomial of degree r.",
  "Hybrid0pq: This is the real world execution": "Hybrid1pq: In this execution, we replace the shares sent by the honest client i to honest committeemember j, which are encrypted under pkj with a random value. Under the semanticsecurity of this encryption scheme, we can guarantee that this is indistinguishable fromthe previous hybrid. Meanwhile, these honest committee members (which the simulatorcontrols) will receive the shares directly from the simulator. The view of A, in this hybrid,is indistinguishable from the real world execution, under the semantic security of theencryption scheme. Hybrid2pq: We will rely on the security of the secret sharing scheme to sample the shares for thehonest clients, similar to Hybrid1 of semi-honest security. For those j P KCom, the sharesare randomly chosen. Furthermore, for those j P Cbad also the shares are randomly chosen.Finally, for those j P Cgood it gets a valid share subject to those previously chosen randomvalues. This is similar to Hybrid1 in the proof of semi-honest security. Hybrid3pq: In this hybrid, for all those honest clients i that are not in C, we will set cti, maski, ` mask1i,, effectively setting the input to be 0. Observe that the view of A remainsunchanged as these honest clients inputs were never incorporated in the final sum anyway.Furthermore, if any of these i P Cpjq for j P Cbad, the shares from these honest clients i tothese j are completely random and independent of maski, and mask1i,. Hybrid4pq: In this hybrid, we pick an honest surviving client i P H. It sets the inputs for alli i P H to be 0. Then sets xi, to be the sum of all the i P H. Call this sum as xH.Observe that the values are still correlated and pseudorandom. Hybrid5pq: In this hybrid, we will program Hpdigi,q xH mask1i,, while setting cti, maski,lab ` mask1i,. Note that because digi, is chosen uniformly at random from qvalues where q is a large prime. The probability of collision is negligible. There is onlynegligible difference in the view of A.",
  "Theorem 9. Construction 10 is a secure PRF where H is modeled as a random oracle under theHSMM assumption": "Proof. We denote the challenger by B. Let Sj be the event that the adversary wins in Hybridj foreach j P t0, . . . , 2u. Let qe (resp. qh) denote the number of evaluation queries (resp. hash oraclequeries) that the adversary makes. We use an analysis similar to the technique by Coron .",
  "| PrrS2s PrrS1s| HSMM": "where HSMM is the advantage that an adversary has in the HSMM game. Note that Hybrid2corresponds to the case where the outputs are all random elements in G. Therefore, theinputs are sufficiently masked and leak no information about the key. Therefore, PrrS2s 0Then,AdvPRFA pe pqe ` 1q HSMM Remark 9. Note that the above scheme is simply an adaptation of the famous DDH-based construc-tion of a key-homomorphic PRF that was shown to be secure by Naor et al. . It is easy to verifythat our construction is also key homomorphic as Hpxqpk1`k2q Hpxqk1 Hpxqk2.",
  "F.2Distributed Pseudorandom Function": "Construction 11 (Distributed PRF in CL Framework). A pr, mq-Distributed PRF is a tuple of PPTalgorithms DPRF : pGen, Share, Eval, P-Eval, Combineq with the algorithms as defined in .For simplicity, in the construction below we will set the corruption threshold t r 1. Though, theconstruction also holds for a lower t. Correctness. For a polynomial f P ZrXs, every fpiq leaks information about the secret s mod ileading to a choice of polynomial f such that fp0q s. For our use case, the secret is the PRF keyk. Let us consider a set S ti1, . . . , itu of indices and corresponding evaluations of the polynomialf at i1, . . . , it giving us key shares: kpi1q, . . . , kpitq. To begin with, one can compute the Lagrangecoefficients corresponding to the set S as: @ i P S, ipXq :",
  "resulting polynomial is fpXq : tj1 ijpXq kpijq": "However, ipXq requires one to perform a division xj xi which is undefined as H hashes to Gwhose order is unknown. To avoid this issue, a standard technique is to instead compute coefficientipXq : ipxq. Thereby, the resulting polynomial that is reconstructed if f 1pXq fpXq tj1 ijpXq kpijq. Consequently,",
  "Pseudrandomness. Next, we consider the pseudorandomness property of our construction": "Theorem 10. In the Random Oracle Model, if Construction 10 is a secure pseudorandom function ifInteger Secret Sharing is statistically private, then Construction 11 is pseudorandom in the staticcorruptions setting. Boneh et al. showed that from any Key Homomorphic PRF (which Construction 10), one canbuild a Distributed PRF. The proof of the following theorem follows the template of this scheme withcertain important adaptations as our secret sharing scheme is over integers. The proof technique is toshow that if there exists an adversary A that can break the DPRF security, one can then use it to buildan adversary B to break the pseudorandomness of our original PRF, as defined in Construction 10.The idea behind the proof is for B, upon receiving choice of t 1 corruptions as indices i1, . . . , it1,to then choose a random index it and implicitly set kpitq to be the PRF key chosen by its challenger.Therefore, the B now has knowledge of t indices, with which it can sample the Lagrange coefficientsas before:",
  "Proof. Let A be a PPT attacker against the pseudorandomness property of DPRF, having advantage": "A first chooses t 1 indices K ti1, . . . , it1u where each index is a subset of t1, . . . , mu. Areceives the shares of the keys kpi1q fpi1q, . . . , kpit1q fpit1q (for unknown polynomial fof degree t such that fp0q k with : . Further, A has access to OEvalpi, xq receivingP-Evalpki, xq ins response. Additionally, A expects to have oracle access to the random oracle H. Using this attacker A, we now define a PPT attacker B which will break the pseudorandomnessproperty of Construction 10. Note that B is given access to the oracle that either outputs the realevaluation of the PRF on key k or a random value. Additionally, B expects to have oracle access tothe random oracle H.",
  "Hpxq2 t1i1 ij p0qkpij q Hpxqkpitq2itp0q": "This shows that the returned value y is consistent when b 0. Meanwhile, when b 1, h is arandom element in the group and then y is a truly random value which means that B has produced avalid random output for A. Similarly, when b 0, every response to partial evaluation is also doneconsistently by correctness of the underlying secret sharing scheme. Meanwhile, when b 1, we canrely on the statistical privacy preserving guarantee of the underlying secret sharing scheme to arguethat the difference that the adversary can notice is statistically negligible. This concludes the proofwhere B can only succeed with advantage .",
  "GStronger Security Definition": "Hitherto, we have only considered the indistinguishability of information from the perspective ofthe server. However, one can consider the requirement to hold for even corrupt committee members.Specifically, should their entire committee collude (or at least t of them), then the clients input remainshidden. It is easy to observe that does not satisfy the stronger security definition. Specifically,if we had a single committee member, then the auxiliary information (which is available to thecommittee member) simply masks the input and therefore can be unmasked. Thus, to accommodatesecurity against collusion of all committee members we modify OPA syntax and construction toinclude a key from the server to keep client privacy. Informally, we do the following:",
  "The committee indistinguishability game proceeds in phases": "Setup Phase: The challenger begins by running the setup algorithm to generate the systemparameters. The adversary is then provided with the system parameters pp and is asked tooutput an adversarial choice of n, which is the number of users that will be registered. Inresponse, the challenger runs the KeyGen algorithm n ` 1 times, once each for the n usersand once for the servers secret key. This phase ends with the adversary being provided withthe servers secret key denoted by k0. Learning Phase: The adversary issues queries to the various oracles defined by OCorr, OEncto learn any information it could. OCorr proceeds where the adversary can corrupt any userand receive its key. These corruptions are tracked. Meanwhile, OEnc allows the adversaryto issue any arbitrary encryption queries on behalf of any of the users, with the restrictionthat it can only do so once per user per label. in response, it receives both the ciphertextencrypting the input and all the auxiliary information.",
  "This phase ends with the adversary committing to a target label": "Challenge Phase: In this phase, the challenger begins by identifying eligible users U whoare honest, which is defined by rnszK. Without loss of generality, we assume that there havebeen no queries to OEnc with as the label. Should there be such queries, those users i suchthat pi, , q P E are also removed from the set U and these inputs are later used to computethe challenge. Upon receiving, U, the adversary commits to two sets: H U is the set ofhonest users that the adversary is targeting, and S that is the set of committee members forwhom the adversary receives!auxpjqi,)",
  "NeurIPS Paper Checklist": "The checklist is designed to encourage best practices for responsible machine learning research,addressing issues of reproducibility, transparency, research ethics, and societal impact. Do not removethe checklist: The papers not including the checklist will be desk rejected. The checklist shouldfollow the references and follow the (optional) supplemental material. The checklist does NOT counttowards the page limit.",
  "Please provide a short (12 sentence) justification right after your answer (even for NA)": "The checklist answers are an integral part of your paper submission. They are visible to thereviewers, area chairs, senior area chairs, and ethics reviewers. You will be asked to also include it(after eventual revisions) with the final version of your paper, and its final version will be publishedwith the paper. The reviewers of your paper will be asked to use the checklist as one of the factors in their evaluation.While \"[Yes] \" is generally preferable to \"[No] \", it is perfectly acceptable to answer \"[No] \" provided aproper justification is given (e.g., \"error bars are not reported because it would be too computationallyexpensive\" or \"we were unable to find the license for the dataset we used\"). In general, answering\"[No] \" or \"[NA] \" is not grounds for rejection. While the questions are phrased in a binary way, weacknowledge that the true answer is often more nuanced, so please just use your best judgment andwrite a justification to elaborate. All supporting evidence can appear either in the main paper or thesupplemental material, provided in appendix. If you answer [Yes] to a question, in the justificationplease point to the section(s) where related material for the question can be found.",
  "Answer: [Yes]": "Justification: The paper sets out to solve a critical problem in prior work on secure aggrega-tion. In this work, we demonstrate how to reduce the synchronization by employing oneadditional party. We demonstrate experiments to show competitive performance over priorwork. In addition, we also train machine learning models to justify that our protocol can beused for its intended purpose.",
  "The answer NA means that the paper has no limitation while the answer No means thatthe paper has limitations, but those are not discussed in the paper": "The authors are encouraged to create a separate \"Limitations\" section in their paper. The paper should point out any strong assumptions and how robust the results are toviolations of these assumptions (e.g., independence assumptions, noiseless settings,model well-specification, asymptotic approximations only holding locally). The authorsshould reflect on how these assumptions might be violated in practice and what theimplications would be. The authors should reflect on the scope of the claims made, e.g., if the approach wasonly tested on a few datasets or with a few runs. In general, empirical results oftendepend on implicit assumptions, which should be articulated. The authors should reflect on the factors that influence the performance of the approach.For example, a facial recognition algorithm may perform poorly when image resolutionis low or images are taken in low lighting. Or a speech-to-text system might not beused reliably to provide closed captions for online lectures because it fails to handletechnical jargon.",
  "If applicable, the authors should discuss possible limitations of their approach toaddress problems of privacy and fairness": "While the authors might fear that complete honesty about limitations might be used byreviewers as grounds for rejection, a worse outcome might be that reviewers discoverlimitations that arent acknowledged in the paper. The authors should use their bestjudgment and recognize that individual actions in favor of transparency play an impor-tant role in developing norms that preserve the integrity of the community. Reviewerswill be specifically instructed to not penalize honesty concerning limitations.",
  "If the contribution is a dataset and/or model, the authors should describe the steps takento make their results reproducible or verifiable": "Depending on the contribution, reproducibility can be accomplished in various ways.For example, if the contribution is a novel architecture, describing the architecture fullymight suffice, or if the contribution is a specific model and empirical evaluation, it maybe necessary to either make it possible for others to replicate the model with the samedataset, or provide access to the model. In general. releasing code and data is oftenone good way to accomplish this, but reproducibility can also be provided via detailedinstructions for how to replicate the results, access to a hosted model (e.g., in the caseof a large language model), releasing of a model checkpoint, or other means that areappropriate to the research performed. While NeurIPS does not require releasing code, the conference does require all submis-sions to provide some reasonable avenue for reproducibility, which may depend on thenature of the contribution. For example(a) If the contribution is primarily a new algorithm, the paper should make it clear howto reproduce that algorithm.",
  "(b) If the contribution is primarily a new model architecture, the paper should describethe architecture clearly and fully": "(c) If the contribution is a new model (e.g., a large language model), then there shouldeither be a way to access this model for reproducing the results or a way to reproducethe model (e.g., with an open-source dataset or instructions for how to constructthe dataset). (d) We recognize that reproducibility may be tricky in some cases, in which caseauthors are welcome to describe the particular way they provide for reproducibility.In the case of closed-source models, it may be that access to the model is limited insome way (e.g., to registered users), but it should be possible for other researchersto have some path to reproducing or verifying the results.",
  "Guidelines:": "The answer NA means that the paper does not use existing assets. The authors should cite the original paper that produced the code package or dataset. The authors should state which version of the asset is used and, if possible, include aURL. The name of the license (e.g., CC-BY 4.0) should be included for each asset. For scraped data from a particular source (e.g., website), the copyright and terms ofservice of that source should be provided. If assets are released, the license, copyright information, and terms of use in thepackage should be provided. For popular datasets, paperswithcode.com/datasetshas curated licenses for some datasets. Their licensing guide can help determine thelicense of a dataset.",
  ". Broader Impacts": "Question: Does the paper discuss both potential positive societal impacts and negativesocietal impacts of the work performed?Answer: [Yes]Justification: We focus on privacy-preserving federated learning which guarantees privacyof client-held data.Guidelines: The answer NA means that there is no societal impact of the work performed. If the authors answer NA or No, they should explain why their work has no societalimpact or why the paper does not address societal impact. Examples of negative societal impacts include potential malicious or unintended uses(e.g., disinformation, generating fake profiles, surveillance), fairness considerations(e.g., deployment of technologies that could make decisions that unfairly impact specificgroups), privacy considerations, and security considerations. The conference expects that many papers will be foundational research and not tiedto particular applications, let alone deployments. However, if there is a direct path toany negative applications, the authors should point it out. For example, it is legitimateto point out that an improvement in the quality of generative models could be used togenerate deepfakes for disinformation. On the other hand, it is not needed to point outthat a generic algorithm for optimizing neural networks could enable people to trainmodels that generate Deepfakes faster. The authors should consider possible harms that could arise when the technology isbeing used as intended and functioning correctly, harms that could arise when thetechnology is being used as intended but gives incorrect results, and harms followingfrom (intentional or unintentional) misuse of the technology. If there are negative societal impacts, the authors could also discuss possible mitigationstrategies (e.g., gated release of models, providing defenses in addition to attacks,mechanisms for monitoring misuse, mechanisms to monitor how a system learns fromfeedback over time, improving the efficiency and accessibility of ML).",
  "According to the NeurIPS Code of Ethics, workers involved in data collection, curation,or other labor should be paid at least the minimum wage in the country of the datacollector": "15. Institutional Review Board (IRB) Approvals or Equivalent for Research with HumanSubjectsQuestion: Does the paper describe potential risks incurred by study participants, whethersuch risks were disclosed to the subjects, and whether Institutional Review Board (IRB)approvals (or an equivalent approval/review based on the requirements of your country orinstitution) were obtained?Answer: [NA]",
  "The answer NA means that the paper does not involve crowdsourcing nor research withhuman subjects": "Depending on the country in which research is conducted, IRB approval (or equivalent)may be required for any human subjects research. If you obtained IRB approval, youshould clearly state this in the paper. We recognize that the procedures for this may vary significantly between institutionsand locations, and we expect authors to adhere to the NeurIPS Code of Ethics and theguidelines for their institution."
}