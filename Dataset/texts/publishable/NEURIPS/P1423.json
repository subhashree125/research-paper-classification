{
  "Abstract": "We study learning problems on correlated stochastic block models with two balanced com-munities. Our main result gives the first efficient algorithm for graph matching in this setting.In the most interesting regime where the average degree is logarithmic in the number of vertices,this algorithm correctly matches all but a vanishing fraction of vertices with high probability,whenever the edge correlation parameter s satisfies s2 > 0.338, where is Otters tree-counting constant. Moreover, we extend this to an efficient algorithm for exact graph match-ing whenever this is information-theoretically possible, positively resolving an open problem ofRacz and Sridhar (NeurIPS 2021). Our algorithm generalizes the recent breakthrough work ofMao, Wu, Xu, and Yu (STOC 2023), which is based on centered subgraph counts of a largefamily of trees termed chandeliers. A major technical challenge that we overcome is dealing withthe additional estimation errors that are necessarily present due to the fact that, in relevantparameter regimes, the latent community partition cannot be exactly recovered from a singlegraph. As an application of our results, we give an efficient algorithm for exact community recov-ery using multiple correlated graphs in parameter regimes where it is information-theoreticallyimpossible to do so using just a single graph.",
  "Introduction": "The proliferation of network data has highlighted the ubiquity and importance of graph matching inmachine learning, with applications in a variety of domains, including social networks ,computational biology , and computer vision.While the graph matching taskrecovering the latent node alignment between two networksis known to be NP-hard to solve oreven approximate in general , in practice it is often possible to solve it well, such as in theworks cited above. This has motivated an exciting recent line of work studying average-case graphmatching , focusing on correlatedErdosRenyi random graphs . These papers culminated in recent breakthrough works whichdeveloped efficient graph matching algorithms in the constant noise regime .However, real-world networks are not modeled well by ErdosRenyi random graphs, which inturn has motivated a growing line of recent work studying graph matching beyond ErdosRenyi . In particular, an important problem in thisvein is to study graph matching in correlated stochastic block models (correlated SBMs) (see .1 for definitions), since community structure is prevalent in many networks and thecommunity recovery problem is a fundamental inference task that is often a starting point for",
  "arXiv:2412.02661v1 [cs.DS] 3 Dec 2024": "deeper analyses. Recent work of Racz and Sridhar determined the fundamental information-theoretic limits for exact graph matching in correlated SBMs; however, the underlying algorithmused to achieve this limit is inefficient (that is, not polynomial time). Racz and Sridhar posedthe open problem of finding an efficient algorithm for (exact) graph matching whenever this isinformation-theoretically feasible.Our main contribution positively resolves this open problem of Racz and Sridhar , giving thefirst efficient algorithm for graph matching for correlated SBMs with two balanced communities,under a condition on the correlation strength that is conjectured to be necessary. Specifically, wegive an efficient algorithm that, in the most interesting regime where the average degree is loga-rithmic in the number of vertices, achieves almost exact recovery of the latent matching, wheneverthe edge correlation parameter s satisfies s2 > 0.338, where is Otters tree-counting con-stant. Moreover, we extend this to an efficient algorithm for exact graph matching whenever thisis information-theoretically possible. See .2 and Theorem 1.1 for details.In addition, our results on graph matching directly imply novel efficient algorithms and resultsfor community recovery. Specifically, combiningin a black-box fashionour (exact) graph match-ing algorithm with existing community recovery algorithms, we give an efficient algorithm for exactcommunity recovery using multiple correlated graphs in parameter regimes where it is information-theoretically impossible to do so using just a single graph. See .3 and Theorem 1.2 fordetails.Our algorithm generalizes the recent breakthrough work of Mao, Wu, Xu, and Yu , whichis based on centered subgraph counts of a large family of trees termed chandeliers, to the settingof correlated SBMs. A major technical challenge that we overcome is dealing with the additionalestimation errors that are necessarily present due to the fact that, in relevant parameter regimes,the latent community partition cannot be exactly recovered from a single graph, and thus the edge-indicator variables in the centered subgraph counts cannot be precisely centered. Our technicalcontributions highlight the interplay between graph matching and community recovery in ways thatare complementary to the recent work of Gaudio, Racz, and Sridhar .",
  "Models and problems": "In this section we describe the setting of the paper by introducing the stochastic block model(SBM), correlated SBMs, and the community recovery and graph matching tasks.The stochastic block model (SBM) is the canonical probabilistic generative model for anetwork with latent community structure. The SBM was first introduced by Holland, Laskey, andLeinhardt and has been widely studied over the past decades . In general, a SBM mayconsist of a number of communities, with distinct vertices connected randomly with a probabilitythat depends on their community memberships.In this work, we focus on the simplest setting of the balanced two-community SBM. Givenn Z+ and p, q , we construct G SBM(n, p, q) as follows. The graph G has n vertices, withvertex labels given by V = [n] := {1, 2, . . . , n}. Let = {(i)}ni=1 be the vector of communitylabels, where each entry (i) {1, +1} is drawn independently and uniformly at random. Then,given the community labels , for any pair of vertices i = j [n], edge (i, j) is in G with probabilityp1{(i)=(j)} + q1{(i)=(j)}. That is, two different vertices are connected with probability p ifthey are from the same community and connected with probability q otherwise.Correlated SBMs are multiple SBMs where the corresponding edge variables are corre-lated .Specifically, we construct two correlated SBMs (G1, G2) CSBM(n, p, q, s)using a natural subsampling procedure as follows. Let G SBM(n, p, q) be a parent graph withcommunity labels . Next, given G, we construct G1 by random sampling of the edges: each",
  ": Schematic illustrating two-community correlated SBMs; see the text for details. (Figurereproduced from with permission.)": "edge of G is included in G1 with probability s, independently of everything else, and non-edges ofG remain non-edges of G1. We then do the edge sampling independently again to obtain G2 inthe same way. The child graphs G1 and G2 inherit both the vertex labels (given by [n]) and thecommunity labels from the parent graph G. Finally, let be a uniformly random permutationof [n] := {1, 2, . . . , n} and generate G2 by relabeling the vertices of G2 according to (e.g., vertexi in G2 is relabeled as (i) in G2). This last step reflects the fact that in practice often the corre-spondence between the two vertex sets is unknown. We denote the adjacency matrices of G1 andG2 as A and B, respectively, and note that the community labels of the two graphs are A := and B := 1 , respectively. See for an illustration.Marginally, G1 and G2 are identically distributed SBMs: we have G1, G2 SBM(n, ps, qs).Moreover, G1 and G2 are correlated. Specifically, for every pair of distinct vertices {i, j}, the edge-indicator random variables Ai,j and B(i),(j) are correlated Bernoulli random variables. A simplecalculation shows that if (i) = (j), then the correlation coefficient of Ai,j and B(i),(j) isequal to + := s 1p",
  "1ps, whereas if (i) = (j), then this correlation coefficient is := s 1q": "1qs.Our focus will be on the sparse setting where p, q = o(1) (as n ), in which case both + and are asymptotically (1 o(1))s, and hence we can regard s as the edge correlation parameter.Community recovery. The goal of community recovery is to recover the latent communitylabels given some (graph) data, such as a SBM G or correlated SBMs (G1, G2). There are variousnotions of community recovery, depending on how close an estimate is to the ground truth . Inthis work, we focus on exact community recovery, defined as follows: an estimator achieves exactcommunity recovery if limn P(| 1 nni=1 (i)(i)| = 1) = 1. The absolute value is present inthe previous expression since we can only hope to recover the community labels up to a globalsign flip; in other words, our goal is to recover the partition of the graph into two communities.A slightly weaker notion, which also appears throughout our work, is almost exact communityrecovery, which holds if limn P(| 1 nni=1 (i)(i)| = 1 o(1)) = 1; in other words, this notiontolerates a vanishing fraction of errors. Further weaker notions include partial recovery and weakrecovery; since these are not the focus here, we refer to for details.Different parameter regimes give rise to different challenges and different notions of recoverybecome most relevant. In the constant average degree regime, that is, when p = a",
  "n and q = b": "n forsome constants a and b, it is impossible to recovery the communities exactly. Prior works have characterized the information-theoretic threshold and developed efficient algorithms for partialrecovery in this regime. On the other hand, if the vertices have polynomially growing degrees, that is, when p = na+o(1) and q = nb+o(1) for some constants a, b [0, 1), then community recoveryis easy as long as lim infn |pn/qn 1| > 0 (see ).In this work, we focus on the bottleneck regime of logarithmic average degree, which is thebare minimum for the graph to be connected, and which is when exact community recovery ismost interesting. In most of the paper we assume that p = a log n",
  "nand q = b log n": "nfor some positiveconstants a, b. For an SBM with two balanced communities and these parameters, there is a sharpinformation-theoretic threshold for exact community recovery, which is given by D+(a, b) = 1, whereD+(a, b) := (a b)2/2 (see ). This quantity is known as the ChernoffHellingerdivergence in the general k-community SBM setting with linear size communities and simplifiesto the above form in our setting. In other words, when D+(a, b) > 1, there exists an estimator that is computable in polynomial-time and which achieves exact community recovery with highprobability. On the other hand, when D+(a, b) < 1, exact community recovery is impossible, inthe sense that for all estimators we have that limn P(| 1 nni=1 (i)(i)| = 1) = 0. Moreover,when it is possible to achieve exact community recovery on a single graph, several polynomial-timealgorithms have been studied by previous works (e.g., ).Community recovery and graph matching. What are the information-theoretic limits forexact community recovery given two correlated SBMs (G1, G2) CSBM(n, a log n",
  "n , blog n": "n , s),a = b, if s2 + for some > 0 then there we can match (1 o(1))n vertices correctly andefficiently with high probability.Take the returned from Algorithm 4 as input of Algorithm 2, then Theorem 2.7 guaranteesthat the final output = with probability 1o(1). This completes the proof of Theorem 1.1.",
  "(b) (Exact matching) If, in addition, s2(a + b)/2 > 1, then there exists a polynomial-time algo-rithm that ouputs a mapping such that limn P( = ) = 1": "Several remarks are now in order about the tightness of the main result, an overview of thechandelier counting algorithm when a = b, and the main challenge of our analysis.Tightness. This result is tight whenever s2 > , because s2(a + b)/2 = 1 is the information-theoretic threshold of exact graph matching given two correlated SBMs (G1, G2) . When s2 <, it is conjectured that an information-computation gap exists for the correlated ErdosRenyigraphs . Specifically, by assuming that a = b, it is information-theoretically possible to matchcorrelated ErdosRenyi graphs exactly if s2a > 1 . However, it is believed hard to finda polynomial-time algorithm to do this. In our model with SBMs, which is an extension fromErdosRenyi graphs, it is also likely hard to find a polynomial-time algorithm when s2 < .Signed chandelier counts. Our theorem extends from the main theorem in Mao et al. ,which proposed a polynomial-time algorithm that matches the correlated ErdosRenyi graphs ex-actly. The algorithm has two main steps: First, construct signature vectors si and tj for verticesi [n] in G1 and j [n] in G2 by the signed subgraph counts of a specially designed graph classtermed Chandeliersand calculate the weighted inner product of pairs of signature vectors si, tjand match vertices if the inner product value is large enough; Second, use a seeded graph matchingalgorithm to boost the almost exact graph matching algorithm to exact graph matching. It isnatural to adapt this algorithm from correlated ErdosRenyi graphs to correlated SBMs but thedetails present non-trivial challenges, as we explain below.Main challenge.The main challenge on correlated SBMs is that signed subgraph countsis no longer a free lunch.Signed subgraph counts is counting the subgraphs on a centralizedadjacency matrix, which is first proposed by Bubeck et al. and later commonly used to controlthe variance of counting statistics. The success of the chandelier counting method relies on thesufficient separation of the two inner product distributions of true and false vertex correspondence.We want to find a way that keeps doing the adjacency matrices centralization possible. Recall thatwe explore the graph matching motivated by community recovery. Interestingly, the solution to thiscentralization problem is now the other way aroundusing a rough community label estimate to",
  "n, b log n": "n, s). The reddiagonal line depicts a = b, which is an ErdosRenyi graph. Black regions: exact graph matching ispossible and can be done efficiently for each community separately by applying the graph matchingalgorithm for correlated ErdosRenyi graphs; Green regions: exact graph matching is possibleand can be done efficiently; Light green regions: exact graph matching is impossible, but almostexact graph matching is possible and can be done efficiently; Cyan regions: exact graph matchingis possible and can be done efficiently by first recovering the community labels almost exactly;Yellow regions: exact graph matching is impossible but almost exact graph matching can be doneefficiently by first recovering the community labels almost exactly. help the graph matching. Our main technical contributions are first showing that when there are noerror occurs in the community label estimate, the signed chandelier counting can be generalized tocorrelated SBMs and then show that when the exact community recovery is not possible, the errorsintroduced in the community label estimation, which is polynomial in n, are actually tolerable forthe whole algorithm.The analysis falls in two cases. If sD+(a, b) > 1, then we can achieve exact community recoveryon each of the graphs by applying the community recovery algorithm from . In addition, ifs2 a",
  "> 1, 2 then it suffices to look at each community individually. This is easy and follows ina black-box fashion from (See .5). However, on the other side, s2 a": "2 < 1, one stillneeds to use information the community information. Therefore, we need to go through the wholealgorithm analysis again in this case. Note that the analysis would work for both regimes with noconstraint on s2 a 2 < 1. We plot the black-box regime in black and the non-black-box regime ingreen in .The second case is even trickier. If sD+(a, b) < 1, by the same algorithm, we can only obtainalmost exact correct community labels A and B on graph G1 and G2, respectively. We performadjacency matrix centralization based on A and B and show that the error introduced in this stepis negligible in the sense that the inner-product scores remains sufficiently distinguishable betweentrue pairs (j = (i)) and fake pairs (j = (i)).",
  "(c) s=0.8": ": Phase diagram for exact community recovery with fixed s on correlated SBMs. Greenregions: exact community recovery is possible from G1 alone and can be done efficiently; Light-green regions: exact community recovery is possible from (G1, G2) but impossible from G1 alone,exact graph matching can be done efficiently and therefore exact community recovery can be doneefficiently; Violet regions: exact community recovery is impossible from G1 alone, impossible from(G1, G2) if s2( a+b",
  "nni=1 (i)(i)| = 1) = 1": "Theorem 1.2 is a direct application of our Theorem 1.1. The proof mainly follows the Theo-rem 3.3 in , which gives exact community recovery on the union graph of G1 and G2 regardingto the permutation , G1 G2. The key difference is that we substitute the maximum a posteriorestimator used in the first step with the (G1, G2) output by the algorithm used to prove Theo-rem 1.1. is a summary of the phase diagram for community recovery determined by thiswork along with previous works , focusing on the exact community recovery and efficiency.",
  "(log log n) and constant": "noise. This algorithm only requires a constant edge correlation (sufficiently close to 1) rather thanconverging to 1, which represents a perfect correlation. Mao et al. followed up with an improvedefficient algorithm that achieves exact graph matching for any correlation satisfying 2 > whennq(q + (1 q)) (1 + ) log n. It is conjectured that for random graphs of logarithmic averagedegree, 2 = is the computational threshold . Muratori and Semerjian added a smallconstant constraint on the maximum vertex degree of a chandelier to improve the runtime, at theexpense of having a slightly larger constant as the minimum squared correlation requirement.In the denser regime where p = na+o(1), a (0, 1], Ding and Du established a sharpinformation-theoretic threshold for matching a positive fraction of vertices. Ding and Li alsodeveloped an efficient algorithm for exact graph matching whenever the edge correlation is non-vanishing, which goes beyond the Otters tree counting constant.Several recent works also go beyond correlated ErdosRenyi graphs. Wang et al. studiedthe exact graph matching with additional attribute information on vanishing edge correlation.Closely related to our work, Yang et al. adopted the binary tree counting algorithm to give an efficient graph matching algorithm for correlated SBMs. However, makes severalsignificant assumptions (which we do not). For one, the algorithm in assumes that the commu-nity labels are known. This is a strong assumption which may be unrealistic in practice; moreover,this precludes using graph matching as a tool for improved community recovery. In contrast, wedo not assume that community labels are known; in fact, a significant part of our technical workis devoted to dealing with the errors arising from estimating the community labels. Moreover, ourgraph matching algorithm can be directly applied to improve community recovery, as discussedin Theorem 1.2 and .3. In addition, makes strong assumptions on the parameters,assuming that (1) the average degree is at least (log n)1.1, (2) the SBM has at least 3 communities,and (3) the correlation parameter satisfies s > 1 0 for some unspecified (small) 0. In contrast,our results hold in the most interesting regime of logarithmic average degree and the most naturalsetting of two balanced communities; moreover, our assumption on s is also weaker. Community recovery with side informationBeyond correlated SBMs, there are some othermodels utilizing side information, from multiple networks , additional covari-ates , or both . Multi-layer SBM is first mentioned in , which is generated as following:first, generate the community labels for all vertices and fix them for all layers; second, form edgeson each layer based on the community labels. Typically, different layers in a multi-layer SBM areconditionally independent given the shared community labels. In addition, several works also encode community membership correlated covariates onto each node. Aside from the multi-layer SBM, Braun and Sugiyama recently studied community detection on a novel variation ofSBM whose edges are attached with vectorial covariates.",
  "Discussion and future work": "Our main contribution in this paper is to give the first efficient algorithm for exact graph matchingfor correlated SBMs with two balanced communities, as well as a rigorous proof of its correctness(Theorem 1.1). We also discuss novel applications to community recovery (Theorem 1.2). At thesame time, our work raises many interesting questions for future research, which we discuss here.Optimal runtime. While our graph matching algorithm is efficient, it would be desirable tounderstand the optimal running time that can be achieved. Mao, Rudelson, and Tikhomirov gave an efficient algorithm for matching correlated ErdosRenyi graphs with runtime n2+o(1); themain drawback is that this algorithm requires the correlation parameter to satisfy s > 1 0 forsome unspecified (small) 0 > 0. Nonetheless, it would be interesting to generalize this algorithm to correlated SBMs and the techniques developed in our work may be useful to do so. In very recent(and concurrent) work, Muratori and Semerjian gave faster algorithms for matching correlatedErdosRenyi graphs by introducing a constraint on the maximum degree of a chandelier, at theexpense of strengthening the condition s2 > to s2 > for some > . Exploring the connectionsbetween our work and theirs, and generalizing their ideas to correlated SBMs, are of interest.Information-computation gap. An important assumption throughout this work is that thecorrelation parameter satisfies s2 > . We believe that this is inherently necessary and that thereis no efficient algorithm (in the logarithmic average degree regime) when s2 < . At the same time,exact graph matching is information-theoretically possible whenever s2(a + b)/2 > 1, so there isa conjectured information-computation gap. This mirrors the conjecture in for ErdosRenyigraphs; see also for the low-degree hardness results on the correlation detection and forthe very recent low-degree hardness results on testing a pair of correlated stochastic block modelsagainst a pair of independent ErdosRenyi graphs.Efficient exact community recovery when exact graph matching is not possible.Gaudio, Racz, and Sridhar determined the information-theoretic threshold for exact communityrecovery on correlated SBMs, in particular showing that there is a regime when this is possible eventhough (1) this is impossible with a single graph and also (2) exact graph matching is impossible.It remains unknown whether this can be done efficiently in this regime. We believe that this ispossible, and our work is an important starting point for this question, yet additional ideas areneeded to understand the subtle interplay between graph matching and community recovery in thisregime.Sparser and denser regimes. Our work focuses on the most interesting regime where theaverage degree is logarithmic in n; it is worth understanding other regimes too. In particular,the chandelier counting algorithm by Mao et al. gives almost exact graph matching wheneverthe average degree diverges.In our Theorem 1.1 we require that the average degree divergeslogarithmically for the corresponding result, so that the error rate for community recovery estimateis polynomially small in n. It would be interesting to overcome this technical barrier and extendthe analysis to this sparser regime. Denser regimes are easier to understand. A close inspection ofour analysis shows that it also works when the average degree diverges as a (small) polynomial in n;in even denser regimes, the community partition can be recovered exactly and efficiently wheneverlim infn |pn/qn 1| > 0 (see ) and then the graph matching algorithm in can be appliedin a black-box fashion.General block models. We focused here on the simplest case of SBMs with two balancedcommunities.It is of great interest to develop efficient graph matching algorithms in the gen-eral block model with k communities, whenever this is possible. Recently, Yang and Chung determined the information-theoretic threshold for exact graph matching in the k-community sym-metric SBM, extending the results of Racz and Sridhar . We conjecture that substituting thecommunity recovery algorithm used in our work with the degree-profiling algorithm by Abbe andSandon gives an efficient algorithm for graph matching in this more general setting, assumingagain that s2 > .",
  "Organization": "The rest of this paper is organized as follows. In .7, we give some notations used through-out. In , we define the similarity score of a pair of vertices and give the formal proofof Theorem 1.1 based on Theorem 2.5 (Almost exact graph matching), Theorem 2.6 (Efficientalgorithm for almost exact graph matching), and Theorem 2.7 (Exact graph matching by seededgraph matching). In , we talk about some preliminaries: tail bounds, nice events, a tree node assigning sub-problem, an automorphism inequality for trees, and the calculation for cross-moments. These results will be repeatedly used in the following sections. In , ,and , we present the proofs for Theorem 2.5, Theorem 2.6, and Theorem 2.7, respectively. and are self-contained, while contains several propositions whoseproofs are deferred and which make up the remainder of the paper.In , we introduce six additional Propositions to show that under two different casesnamely, sD+(a, b) 1 and sD+(a.b) < 1the mean and variance of the similarity score are properlycontrolled. Specifically, if sD+(a, b) 1, then Proposition 4.1 gives the mean calculation of thesimilarity score, while Proposition 4.2 and Proposition 4.3 are about the variance calculation ofthe similarity score for true pairs and fake pairs of vertices. If sD+(a, b) < 1, then Proposition 4.4gives the mean calculation of the similarity score, while Proposition 4.5 and Proposition 4.6 areabout the variance calculation of the similarity score for true pairs and fake pairs of vertices.The proofs of Proposition 4.1, Proposition 4.2, Proposition 4.3, Proposition 4.4, Proposition 4.5,and Proposition 4.6 are presented in , , , , , and, respectively.",
  "Notation": "For any graph G = (V, E), we denote E(G) as the edge set and V (G) as the vertex set. We lete(G) := |E(G)| denote the number of edges of graph G and v(G) := |V (G)| denote the number ofvertices in graph G. We define the excess of graph G as e(G) v(G), the difference between thenumber of edges and the number of vertices of G.Consider an arbitrary graph where vertices are equipped with two possible community labels{+1, 1}, we denote V + as the set of vertices with community label +1, V as the set of verticeswith community label 1, N(v) as the set vertices that are neighbors of v.Let be a permutation on [n], (G1, G2) CSBM(n, p, q, s). Let A (resp. B) be the adjacencymatrix of G1 (resp. G2). Let A := A E[A] (resp. B) be the centralized adjacency matrix. Wefurther define the approximately centralized adjacency matrix with respect to community labelestimate as AA := AEA, where EA is an nn matrix whose (i, j)-th entry is p if (i) = (j)and q otherwise.3 We denote G1 G2 as the union graph with respect to , such that (i, j) E(G1 G2) if andonly if (i, j) E(G1) or ((i), (j)) E(G2). We denote G1 G2 as the intersection graph withrespect to , such that (i, j) E(G1 G2) if and only if (i, j) E(G1) and ((i), (j)) E(G2).We denote the variance of in-community edges 2+ := sp(1 sp) and the variance of cross-community edges as 2 := sq(1 sq). Denote the correlation for in-community edges and cross-community edges as + and , respectively. In addition, we define := ++",
  "n ))s.4": "Throughout the paper, we use standard asymptotic notation O(), (), (), o(), ().Anylimitation is for n without special explanations. For real numbers x, y, we define x y :=max{x, y} and x y := min{x, y}. In this paper, log is natural logarithmic function (with base e).Further notation is introduced in the following section which details the algorithms.",
  "Chandelier": "A line of works convert the graph matching problem from quadratic assumption to linear assignmentby creating a signature vector si for each vertex i [n], followed by calculating the similarity scoreij = s(1)i , s(2)j of all possible pairs of signatures on two graphs. Recently, Mao et al. proposeda special tree family T , chandelier, that shows a result of efficient graph matching under constantcorrelation. Definition 2.1 ((L, M, K, R)chandelier). An (L, M, K, R)-chandelier is a rooted tree with Lbranches, each of which consists of a path with M edges (M-wire), followed by a rooted tree withK edges (K-bulb); the K-bulbs are non-isomorphic to each other and each of them has at most Rautomorphisms. In this paper, we give an alternative definition of chandelier with five tuple. The first fourparameters remain the same as (L, M, K, R)chandelier.The last parameter D stands for themaximum degree of vertices on this chandelier. We explain the necessity of controlling D in theproof challenge. Definition 2.2 ((L, M, K, R, D)chandelier). An (L, M, K, R, D)-chandelier is a rooted tree withL branches, each of which consists of a path with M edges (M-wire), followed by a rooted treewith K edges (K-bulb); the K-bulbs are non-isomorphic to each other, each of them has at most Rautomorphisms, and the degree of each vertex is at most D. For each chandelier H, let K(H) denote the set of bulbs of H. For a rooted tree T, let aut(H)denote the number of rooted automorphisms of T throughout this paper. We abbreviate rootedautomorphism as automorphism when it is clear that we are applying it to a chandelier.Thenumber of automorphisms of H is determined by the automorphisms of its bulbs. Because all bulbsare non-isomorphic to each other,",
  "BK(H)aut(B).(2.1)": "Let T denote the family of non-isomorphic (L, M, K, R, D)chandelier.The family size ofchandelier is |T | =|J |L, where J J (K, R, D) denotes the collection of unlabeled rooted treeswith K edges, at most R automorphisms, and maximum degree D.Otter showed that the number of unlabeled rooted trees with K edges (and no constrainton the automorphisms and vertex degrees) is |J (K, , )| = ( + o(1))K, where 0.338. Weshow that under proper choices of R and D, we have |J (K, R, D)| = ( + o(1))K through thefollowing two Lemmas.",
  "Proof. Olsson and Wagner (Theorem 2) showed a central limit theorem result for the numberof automorphism on unlabeled rooted trees:1": "K (log aut(HK)K) N(0, 2) as K , whereHK is a uniform random unlabeled rooted tree with K edges and 0.137, 2 0.197. Thisimplies that for some constant C > and R = exp(CK), aut(HK) < R with high probability. Putting together Lemma 2.3 and Lemma 2.4, and choosing R and D as specified, we have that|J (K, R, D)| = (1 o(1))|J (K, , )| = ( + o(1))K. Let denote a universal constant suchthat |J | K. We take take = 1.",
  "Algorithm overview": "Given (G1, G2) CSBM(n, p, q, s). Our algorithm contains mainly three steps. Firstly, we applythe algorithm by Mossel, Neeman, and Sly to obtain almost exact community label estimatesfor each single graph. Secondly, we calculate the signed chandelier counting based similarityscore to give an almost exact graph matching. Lastly, we boost the almost exact matching toexact matching by extending the seeded graph matching algorithm on ErdosRenyi graphs tostochastic block models.Almost exact community recovery. Obtaining community label estimates for both graphG1 and G2 is the first step of our algorithm.This is necessary for centralizing the adjacencymatrices for the signed subgraph counts afterwards. We expect the following properties from thecommunity recovery algorithm:",
  "(c) gives error rates on different vertices that are approximately independent": "The community recovery algorithm in (described as Algorithm 3) has been shown withproperty (a) by and property (b) by with an error rate of nsD+(a,b). In this paper, weshow that property (c) is satisfied (See Lemma 3.6).Subgraph counts. For an arbitrary weighted adjacency matrix M of some adjacency matrixA, vertex i [n], and a rooted graph H, we define the weighted subgraph counts on M as",
  "eE(S)Me,(2.4)": "and S(i) enumerates subgraphs of the complete graph Kn, rooted at i, that are isomorphic to H.When M is the adjacency matrix itself, Wi,H(M) is the usual subgraph count, representing thenumber of subgraphs rooted at i in M that are isomorphic to H. When M is the centralized adja-cency matrix A := A E[A], we call Wi,H(M) a signed subgraph count following . However, wedo not have access to E[A] in many cases. Specifically for SBM, we can estimate E[A] through esti-mating the community labels. We define the approximately centralized adjacency matrix regardingto community label estimate , denoted as A, entry-wise as Ai,j = Ai,j p1[i]=[j] q1[i]=[j]. Using A in (2.4) yields the weighted subgraph counts for approximately centralized adjacencymatrix. We also refer to this as a signed subgraph count, though errors may exist.Given a family H of non-isomorphic rooted graphs, we define the subgraph count signature ofvertex i asW Hi (M) := (Wi,H(M))HH.(2.5) Similarity score. Given a pair of correlated SBMs (G1, G2), we define the similarity scorebetween vertex i on graph G1 and vertex j on graph G2 as a weighted inner product between twosignatures:ij := W Ti (A), W Tj (B) :=",
  "HTaut(H)Wi,H(AA)Wj,H(BB).(2.7)": "Almost exact graph matching. The first part in the analysis is to show that by calculatingthis similarity score, with an appropriate thresholding strategy, we can match up (1o(1))n verticescorrectly (Theorem 2.5). The high-level idea is to show that the similarity score distributions arewell-separated between true pairs and fake pairs. We expect the similarity score having the followingproperties, under event H:",
  ".(2.9)": "Precisely forming bounds for these moments constitutes the main bulk of the paper. Asidefrom proving the desired properties of the first and second order moments, we follow the colorcoding-based similarity score estimation idea from to analyze an efficient algorithm. The basicidea is to color the vertices of SBMs using N + 1 colors uniformly at random. Then, we only dosigned counts on vertex sets that are colorful with N + 1 colors. We show that this is an unbiasedestimator and only potentially increase the variance by an additional constant factor in .The result is stated formally as in Theorem 2.6.",
  ": Let = c, output I := {i|i [n], j [n], s.t. Tij , and k [n] \\ {j}, Tik < }": "Proof challenge. In regime sD+(a, b) > 1, the probability of existing one vertex being clas-sified incorrectly is vanishing. Therefore, with high probability, AA = A. If sD+(a, b) < 1, thenthe recovered contains errors (polynomial in n), which will cause some edges being centralizedincorrectly and thereby affect the moments calculation. For example, let i, j [n] be two verticeson G1 who has the same community label (i) = (j). If only one of i, j is labeled incorrectlyby Algorithm 3, then the expectation of AAi,j conditioned on and is p q.This phenomenon poses a challenge to the algorithm analysis. We highlight some key points inthe context of second moment calculation.",
  "Let us define the union graph U := S1 S2 T1 T15. If sD+(a, b) > 1, we view A and B": "as A and B, respectively. E[AS1BS2AT1AT2 | ] = 0 only if there exists no edge e E(U) suchthat it occurs only once among (S1, S2, T1, T2). This is because different edges are independent andcentralized conditioned on . Without loss of generality, we assume there exists an edge e E(A)occur only on S1, thus E[Ae | ] = 0 and also E[AS1BS2AT1AT2 | ] = 0.However, in regime sD+(a, b) < 1, E[AAS1 BBS2 AAT1 BBT2| ] = 0 even when edges are not",
  "Note that S1 and T1 are rooted at i, while S2 and T2 are rooted at j. For e = (u, v) E(S1), we say it occurs inT1 if e E(T1) and it occurs in S2 (resp. T2) if ((u), (v)) E(S2) (resp. T2)": "and an estimate A that disagrees with on the edge type (i.e., for e = (u, v), (u)(v) =A(u)A(v)). This not only causes this cross-moments calculation being more complicated, butsignificantly increasing the possibility of the combinations between S1, S2, T1,and T2. The maximumvertex in the union graph grows from 2N to 4N, squaring up the trivial bound on the number ofsubgraphs on the complete graph Kn that is isomorphic to U.The most important high-level idea to properly bound the moments is: the cross-momentconditioning on a specific = (A, B) would be non-trivial if and only if all edges occurring onlyonce are centralized incorrectly. This is because, conditioning on satisfying the above property,the expectation of Ae takes either p q or q p for all e E(U) that occurs only once. Assumingthere are z edges occurring once, we show that the probability that satisfying this property is",
  "Theorem 2.6. Theorem 2.5 continues to hold with ij in place of ij. Moreover, {ij}i,j[n] canbe computed in O(nC) for some constant C C() depending only on , where is from (2.11)": "Exact graph matching. The final step of the algorithm is boosting the almost exact matchingto a exact matching. The key idea is exploring the number of common neighbors for two unmatchedvertices with regard to the current matching.Denote N(i, j) as the number of common neighbors of i and j under correspondence . Inanother word, N(i, j) is the number of vertex v I such that v is a neighbor of i in A and (v) isa neighbor of j in B. The high-level idea is that if i and j form a true correspondence, then for acorrect partial matching on (1o(1))n vertices, with high probability, N(i, j) p2+q2 2s2(n+2n34 )under the nice event H. Therefore, we match up i and j if they have more common neighbors thanthis threshold. In addition, we can show that all the remaining vertices will be matched up withhigh probability. Formally, define h(x) = x log xx+1, we summarize the algorithm as Algorithm 2and the guarantee as Theorem 2.7.",
  "Community recovery": "We make a slight change on the choice of the partition number of the community detection algo-rithm proposed by Mossel, Neeman, and Sly . This algorithm gives almost exact recovery withn1sD+(a,b)+| log(a/b)| vertices labeled incorrectly. After community recovery, we need to match thetwo communities in G1 and G2 by applying the community matching Algorithm 3.Consider G SBM(n, a log n",
  "I(G) := {v [n] : majG(v) log n or |N(v)| log3 n}": "Previous results (Lemma 5.1 , Proposition 4.3 ) have shown that Algorithm 3s correctnesson [n] \\ I(G) with a different choice of m and the lower bound of |N(v)| in the bad vertices setI(G). In our work, we first demonstrates that Algorithm 3 on input (G, a, b, ) correctly classifiesall vertices in [n] \\ I(G).",
  "Lemma 3.5. Algorithm 3 on input (n, a, b, s) classifies all vertices in [n]\\I(G) correctly with highprobability": "The proof directly follows from the proof of Proposition 5.1 in , with two remarks. First,although the maximum size of neighbors |N(i)| we consider here is enlarged from 100 max{1, } log nto log3 n, we adjust the condition of m accordingly such that the tail bound holds. Secondly, weneed to justify that with high probability, all partitions done by the spectral method are stillalmost exactly correct under the new choice of m, which is no longer a constant independentof n. Theorem 3.2 of showed that the vanilla spectral method achieved optimal error rate,in the sense that E[ 1 nni=1 1{(i)=(i)}] n(1+o(1))D+(a,b). This implies that with probability1 n(1+o(1))D+(a,b), the spectral method labels all but o(n) vertices correctly. Furthermore, forall i [n], Ui,+ matches with V + \\ Ui and Ui, matches with V \\ Ui on all but o(n) vertices afterstep (5) with high probability.In this work, we further determine the probability of a set of vertices being in the set I(G),which is a generalization of the result on the P(v I) for an arbitrary v [n] (Lemma 5.3 of ).",
  "where the second line holds by Lemma 3.3 and the last line holds for sufficiently large n. Weconclude with by Lemma 3.4, Inequality (3.2), and Inequality (3.3) into Inequality (3.1)": "Remark 2. For arbitrary > 0, we can find > 0 and > 0 such that (1 + ) = . For the sakeof convenience, we also denote D+(a, b, s, ) as sD+(a, b) | log(a/b)| and this is equivalent as the(, )-parameterization in Lemma 3.6. We mainly use the sD+(a, b, s, ) notation in the analysisthroughout this paper.",
  "Tree node assigning": "Before getting to the first moment calculation of the similarity score, we introduce a sub-problem,named in-community edge counting for node assignment on trees.Assume that we have a random graph G with n vertices, which are labeled by a communitylabel vector . We are also given a rooted tree T(i) with N vertices other than the root, wherei specifies the root node of T on G. Planting T(i) onto G has at least nNpossible positions. IfG is a stochastic block model, different planted positions of T would contain different numbers ofin-community edges. We are interested in the distribution of the number of in-community edgeswhen planting T(i) onto G uniformly at random. Lemma 3.7. Let Kn be the complete graph of a stochastic block model G on n vertices.Let = {(i)}ni=1, (i) {1, +1} drawn independently and uniformly at random as the vector ofcommunity labels. Let v [n] be an arbitrary node of Kn. Let T be an arbitrary rooted tree with N vertices other than the root. Consider a uniformly random injective function : V (T) V (Kn)such that root r(T) is mapped to v in V (Kn). Define X as the random variable representing thenumber of in-community edges in the tree T under random . Then,",
  ")t(1 + 4n 1": "4 )Nt. The first inequalityholds because of the stochastic dominance in Lemma 3.7.The second inequality holds because NNtf(n, N, N t) =Ntf(n, N, t) and thus cancels out every term in the summation indexedfrom t = N1 + 1 to t = N (N1 + 1). For t (N N1) (N1 + 1), we know thatNt< NN1.",
  ")N": "Lemma 3.8. Let Kn be the complete graph of a stochastic block model G on n vertices.Let = {(i)}ni=1, (i) {1, +1} drawn independently and uniformly at random as the vector ofcommunity labels. Let v [n] be an arbitrary node of G. Let {T}ti=1 be a sequence of arbitraryrooted tree with N vertices other than the root. Consider a uniformly random injective function : V (T) V (Kn) such that root r(T1) of the first tree is mapped to v in V (Kn). Also, the root ofi-th tree is mapped to (r(Ti)) = (u) for a fixed vertex on previous trees u i1t=1V (Tt) or a fixedvertex on Kn. Define X as the random variable representing the number of in-community edges inall the trees under random . Then,",
  ")": "To present the following Lemma 3.9, we need to introduce a few more definitions: decoratedunion graph and decorated edges, which will be explained in more details in the context of chandelierin .Decorated Union Graph. Let S1, S2, T1, T2 be four rooted graphs. The union graph is definedas U := S1 S2 T1 T2. We define the decorated union graph as a two-tuple U := (U, DU), whichis U associating with a decoration set. For each edge,",
  "The subset of {S1, S2, T1, T2} where eoccurs,if e E(U),,otherwise": "We call an edge e E(U) is t-decorated if |DU(e)| = t for t {0, 1, 2, 3, 4}. Decorated uniongraph U has one-to-one correspondence with (S1, S2, T1, T2) as we can uniquely determine U given(S1, S2, T1, T2) and uniquely recover (S1, S2, T1, T2) given U. Lemma 3.9 (Asymptotic independence of the counts of i-decorated in-community edges). Let Knbe the complete graph of a stochastic block model G on n vertices. Consider a connected decoratedunion graph UP with d1 1-decorated edges, d2 2-decorated edges, d3 3-decorated edges, and d4 4-decorated edges, rooted at v on the complete graph Kn. Consider a uniformly random injectivefunction : V (T) V (Kn) such that root r(T) is mapped to v in V (Kn). Define X(i) as therandom variable representing the number of i-decorated in-community edges in UP . Assume that|V ( UP )| = O(log n) and UP has excess k. If k = 1, then,",
  "2d1+d2+d3+d4": "Proof. From the assumption k = 1 we have UP is a tree. We can decompose UP to a sequence oftrees as follows: Traverse UP in BFS order and include each maximal connected component withall edges i-decorated as a subtree.In addition, we break this sequence of tree into four sequences based on the decoration number:{T (1)j}cj=1, {T (2)j}dj=1, {T (3)j}ej=1, {T (4)j}fj=1. In the random mapping, the root of each tree should",
  "r(T (2)3 )": ": Decomposition of a decorated tree into three sequences of trees. Edges that are 2, 3,4-decorated are painted as red, green, and blue color correspondingly. Roots of each subtree ismarked by larger node and annotated as r(T (i)j ), where i is the decoration counts and j is the orderin its sequence.",
  "Lemma 3.9 discusses the case of k = 1. We do not expect the same property holds for k 0but we have an auxiliary result as in the following Corollary 3.10": "Corollary 3.10. (If k 0, then UP contains cycles.) By definition, UP can be decomposed intoa tree TP with vP vertices other than the root and additional k+1 distinct edges Ek+1 = {(uj, vj)}k+1i=jfixed. By edges decorations, Ek+1 = E(1) E(2) E(3) E(4). Let X(i) still be the random variablerepresenting the number of i-decorated in-community edges on UN. If k 0, let X(i,a) be the countsof i-decorated in-community edges on TN and X(i,b) be the counts of i-decorated in-communityedges on {ei}k+1i=1 . From construction, we know X(i) = X(i,a) + X(i,b). Correspondingly, there areAi i-decorated edges on tree, Bi = |E(i)|, and di = Ai + Bi, which are all fixed from UP .Then, P(X(1,a) = a1, X(2,a) = a2, X(3,a) = a3, X(4,a) = a4, X(2,b) = b2, X(1,b) = b1, X(3,b) =b3, X(4,b) = b4 | H) (1 + o(1))A1a1A2a2A3a3A4a41",
  "Inequalities concerning automorphisms": "In this subsection, we study how adding edges can change the number of rooted automorphismsof a rooted tree.With a slight abuse of notation, we denote by aut(T) the number of rootedautomorphisms (i.e., automorphisms which fix the root) of a rooted tree T. We start by quantifyingthe effect of adding an additional edge. Lemma 3.11. Let T = (V, E, r) be a rooted tree with root r. Let T := (V {u}, E {(u, v)}, r)be the rooted tree obtained from T by adding a vertex u and the edge (u, v), where v V . Thefollowing bounds hold:",
  "where |V | is the number of vertices in T": "Proof. Since T is a rooted tree, there is a natural notion of a parent vertex for every vertex otherthan the root. Namely, the parent of a vertex v = r is the neighbor of v which is closest to theroot r. We also define the subtree rooted at v to be the subtree of T induced by all vertices whoseshortest path to r goes through v, rooted at v.We partition V into equivalence classes according to the following rule: v1 and v2 are in thesame equivalence class if and only if they share the same parent and the subtrees rooted at v1 andv2 are isomorphic. We denote the resulting partition as {Vi}iI and refer to the equivalence classesas orbits. Note that the root r is always in a single-element orbit and thus the size of each orbit isat most |V | 1.Observe that a permutation of the vertices is a rooted automorphism precisely when it mapseach vertex to a vertex in its orbit. Thus we have that",
  "iI|Vi|!.(3.5)": "Now consider T , which adds a new vertex u to T with an edge connecting u to a vertex in T.By (3.5), in order to understand aut(T ), we need to understand how the orbits and their sizeschange due to the addition of the new vertex and edge.The new vertex u will either join anexisting orbit or form its own one. The parent of u may change orbits, so might the parent of itsparent, etc. In other words, the vertices on the path from u to the root r might change their orbit,but vertices not on this path will not. In the following, we argue iteratively based on the depth ofu in T (i.e., its distance from the root). When considering the upper bound, we will ignore thepossible size decrease of orbits. When considering the lower bound, we will ignore the possible sizeincrease of orbits.Assume first that the new vertex u is attached to the root r. If there are no leaves except for uconnecting to r, then u forms a new orbit V|I|+1 whose size is 1, which does not change the numberof rooted automorphisms. Otherwise, without loss of generality, assume that orbit V1 is the setthat contains all leaves connected to r. Then u will join this orbit, so the set of orbits of T is givenby V1 {u} and {Vi}|I|i=2. Thus, we have that aut(T ) = aut(T)(|V1| + 1), so in particular",
  "Now suppose that u has depth 2 in T , and let v(1) denote the parent of u in T . Without lossof generality, assume that v(1) V1. There are again two cases depending on whether or not there": "are leaves attached to v(1) in T. Suppose first that there are not any leaves attached to v(1) in T.Then u has its own orbit (of size 1) in T . The orbit of v(1) changes from V1 in T to either a neworbit or some existing orbit Vj1 in T (for some 2 j1 |I|). In the former case we have thataut(T ) = aut(T)/|V1|, while in the latter case we have that",
  "|V1|": "The lower bound follows since |V1| |V | 1. For the upper bound in the latter case, note thatby the definition of orbits, in T there are |Vj1| + 1 nodes at depth 1 who each have |V2| + 1children that are leaves. This implies that T has at least (|V2| + 1)(|Vj1| + 1) non-root vertices, so(|V2| + 1)(|Vj1| + 1) (|V | + 1) 1 = |V |.The general case when u has depth in T is analogous. Let v(1) denote the parent of u inT , let v(2) denote the parent of v(1), etc. Without loss of generality, let Vi denote the orbit ofv(i) in T, for i . Suppose that v(1) has children that are leaves in T (the other case, whenit does not, is similar and simpler), and let V denote the equivalence class of these vertices. Then,using similar observations as above, we obtain the following upper and lower bounds on aut(T ):",
  "i=1(|Vji| + 1)": "Here, for every i , either ji [ + 1, |I|] (which corresponds to v(i) changing from Vi in Tto some existing orbit Vji in T ) or |Vji| = 0 (which corresponds to v(i) changing from Vi in T toa new orbit in T ). To conclude the lower bound, observe (using the definition of orbits) that Tcontains a subtree consisting of the root and 1i=1 |Vi| additional vertices, so 1i=1 |Vi| |V | 1.For the upper bound, observe similarly that T contains a subtree consisting of the root and(|V| + 1) 1i=1 (|Vji| + 1) additional vertices, so (|V| + 1) 1i=1 (|Vji| + 1) |V |. Lemma 3.11 is tight. Let T be a star rooted at its center (i.e., a tree where all vertices exceptthe root are connected to the root). Then all permutations of the vertices that fix the root arerooted automorphisms, so aut(T) = (|V (T)| 1)!. Now let T be a tree obtained from T by addingan additional child to the root (see , tree in the middle). Then aut(T ) = (|V (T)|)! =aut(T) |V (T)|. This shows that the upper bound in Lemma 3.11 is tight. Now let T be atree obtained from T by adding a child to one of the leaves of T (see , tree on the right).The rooted automorphisms of T are precisely the permutations of the vertices that permute theneighbors of the root which are leaves, so aut(T ) = (|V (T)| 2)! = aut(T)/(|V (T)| 1). Thisshows that the lower bound in Lemma 3.11 is tight.From Lemma 3.11, we can derive the following corollary by an iterative argument.",
  ": Left: The simplest example of two rooted trees T1 and T2 satisfying": "aut(T1)aut(T2) >aut(T1 T2); here T1 is induced by the blue and green edges, T2 is induced by the blue and rededges, and both trees are rooted at the vertex at the top. Middle: Example that shows that theupper bound in Lemma 3.11 is tight, where blue lines and black vertices represent T, and the redvertex is additionally added with an edge attaching it to the root. Right: Example that shows thatthe lower bound in Lemma 3.11 is tight. Corollary 3.12. Let T1 = (V1, E1, r) and T2 = (V2, E2, r) be two trees rooted at the same vertex r.Define the union T1 T2 := (V1 V2, E1 E2, r) by taking the union of the two vertex sets (bothof which contain r) and the union of the two edge sets, with multiple edges ignored (i.e., if an edgeappears in both E1 and E2, then it appears in E1 E2 exactly once). Suppose that T1 T2 is alsoa tree. Let d := |E1E2| denote the size of the symmetric difference of the edge sets. Then",
  "aut(T1)aut(T2) aut(T1 T2) (2 max{|V1|, |V2|})d.(3.6)": "Proof. By the assumptions on T1 and T2, the union T1T2 has (|V1|+|V2|+d)/21 edges. There aretwo natural ways that we can think of T1T2. First, we can start from T1 and add (|V2||V1|+d)/2new verticesthose that are in V2 but not in V1one at a time, together with a new edge for eachnew added vertex, connecting it to an existing vertex, to obtain T1 T2. With this perspective,applying the lower bound in (3.4) from Lemma 3.11 across each of the (|V2| |V1| + d)/2 steps, weobtain that",
  "k=|V1|1k.(3.7)": "On the other hand, we can equally well start from T2 and add (|V1| |V2| + d)/2 new edges andvertices to obtain T1 T2. Thus, analogously, (3.7) also holds with aut(T1) on the left hand sidereplaced with aut(T2), and |V1| 1 on the right hand side (the minimum value of k in the product)replaced with |V2| 1.Combining these two inequalities, we obtain that",
  "k=min{|V1|,|V2|}1k": "Since d 2(max{|V1, V2|}1), it follows that (|V1|+|V2|+d)/22 2 max{|V1|, |V2|}, so all factorsin the product above are at most 2 max{|V1|, |V2|}. Note also that d max{|V1, V2|}min{|V1, V2|},so the number of factors in the product above is (max{|V1, V2|}min{|V1, V2|}+d)/2 d. Puttingthese observations together we see that (3.6) holds.",
  "Auxiliary result: bounds on the cross-moments": "In this section, we summarize the upper bound on cross-moments. In Lemma 3.13, we work on theregime sD+(a, b) > 1 where we can recover the community label exactly first. In Lemma 3.14, wework on the regime sD+(a, b) < 1 where we we have a inverse polynomial fraction of vertices beinglabeled incorrectly.",
  "n, q = b log n": "n. Denote AA, BB as theapproximately centralized adjacency matrices of G1 and G2 correspondingly.Let e := (u, v) [n] [n] be an arbitrary edge. Define the edge type indicator c(e) = + if e is an in-community edgeand c(e) = if e is a cross-community edge under . Define := |sp sq|. The following holdsfor 0 , m 2, 1 + m 4, and any , = (A, B),",
  "s(pq)(, m) = (2, 2)": "Proof. Conditioning on a specific true community label vector that satisfies the balanced communityevent H, we can apply Lemma 5 from for each case of c(e) = + and c(e) = . Then, the upperbound are different in terms of p, q and +, . When (, m) = (1, 1), ,m max{|+|, ||} (1 + ( log n",
  "When E[AA,1e| , ] is non-zero, 1c(e)E[AA,1e| , ] = (": ").(b) + m = 2. We first consider the case of = 2 or m = 2.We explicitly calculate the expectation on the following two cases. If (u)(v) = (u)(v),then E[AA,2e| , ] = p(1 p) = 2c(e). If (u)(v) = (u)(v), then E[AA,2e| , ] =p 2pq + q2 = 2c(e) + 2.",
  "Regime II: Exact community recovery is impossible for a single graph": "Before getting into the details of proof, let us first give more intuition on the approximately cen-tralized adjacency matrix.In this regime, for each element in the adjacency matrix, there are four cases: (1) Correctcentralization for in-community edges; (2) Incorrect centralization for in-community edges; (3)Correct centralization for cross-community edges; (4) Incorrect centralization for cross-communityedges. gives an example of how the graphon for balanced 2-community SBM changesunder community label misclassifications.",
  "E[i(i)1H]2 = o( 1": "n2 ) when sD+(a, b) < 1.Next, we claim that almost exact recovery is achievable by counting chandeliers. Let = c, for arbitrary c (0, 1), where = E[i(i)1H]. By Chebyshevs inequality, the probabilitythat the similarity score of a fake pair (j = (i)) of vertices exceeding , is upper bounded as",
  "n2 )": "Applying union bound over all i = j [n], we have P{i = j, ij } = o(1). Thus, for allpossible pairs of vertices (i, j) [n] [n], ij < with high probability.We next study the probability that the similarity score of a true pair of vertices falling belowthe threshold . We even consider a larger set containing F := {i [n] : i(i) < },",
  "AlgorithmColor coding based similarity score estimation": "In this section, we re-state and modify the efficient graph matching algorithm for correlated ErdosRenyi graphs discussed in of , and then analyze it for correlated SBMs.Let (G1, G2) be a pair of correlated SBMs with adjacency matrices A and B. Let H be a rootedconnected graph with N + 1 vertices. We now want to approximately count the signed subgraphsrooted at i [n] on the centralized adjacency matrices. In general, we do not have access to thecentralized adjacency matrices A and B, we would use community label estimates A and B fromAlgorithm 3 to approximately centralize the adjacency matrices as AA and BB.First, we generate a random coloring : [n] [N + 1], which is assigning every node on Ato one of N + 1the same as the number of vertices on a chandeliercolors independently anduniformly at random. For any vertex set V [n], we define (V ) = 1{x,yV,x=y:(x)=(y)}. We",
  "Observe that E[Xi,H(AA, )] = rWi,H(AA), where Wi,H(AA) is the ground truth of signed counts": "as defined in . In another word, Xi,H(AA, )/r is an unbiased estimator of Wi,H(AA).Let t := 1/r, we repeat the random coloring for t times and then average over the estimatesbefore taking the inner product of two signed counts vectors. Formally, we generate 2t independentcolorings independently and uniformly at random, denoted as {a}ta=1 and {b}tb=1. For vertex iin G1 and vertex j in G2, we define the approximate similarity score as follows",
  ": (Maximum degree constraint) Compute maximum degree of vertices": "4: (Chandelier class) Return J as the subset of rooted trees whose number of automorphisms isat most R and maximum degree is at most D. Construct (K, L, M, R, D)-Chandelier class T .Step 2 - Estimation of similarity score (Random Coloring) Generate i.i.d. uniformly random colorings {a}ta=1 and {b}tb=1, each mapsfrom [n] to [N + 1].(Community recovery) Obtaining A and B for A and B independently by Algorithm 3.for all (i, j) [n] [n] do",
  "{S1=S2 or T1=T2 or V (S1)V (T1)={i}}1{S1T1S2T2,S2T2S1T1} =: ij.(5.2)": "If 1{S1T1S2T2,S2T2S1T1} = 0, then there exists some edge occurring only once among S1, S2,T1, and T2, and so |E[AS1BS2AT1BT21H]| = 0. Therefore, we only look at the cases where every edgeoccurs at least two times among these four chandeliers. If 1{S1=S2 or T1=T2 or V (S1)V (T1)={i}} = 0,then S1 = S2, T1 = T2, and S1 has no common vertex with T1 except for the root. In this case, S1and T1, and S2 and T2 have no common edges, so the covariance between AS1BT1 and AS2BT2 isalways zero.For Regime II (sD+(a, b) < 1), where we cannot recover the correct centralized adjacencymatrices with high probability. Alternatively, we define ij as:",
  "= ij(r2+1{d=f}+1{c=e} r4),": "and this completes the proof for Regime II.In Regime I, E[AS1BS2AT1BT21H] = 0 only if {S1 T1 S2 T2, S2 T2 S1 T1} happens.In addition, if S1 = S2, T1 = T2, and V (S1) V (T1) = {i}, then E[c(V (S1))e(V (T1))] =E[d(V (S2))f (V (T2))] = r2, because S1 (resp. S2) shares no common edges with T1 (resp. T2)Therefore,",
  "nand q =b log n": "n,Algorithm 4 efficiently matches (1 o(1))n vertices correctly with high probability. Our next stepis to finish the matching on those remaining vertices.To do this, we use the seeded graph matching algorithm6 (Algorithm 2): Starting with an initialpartial matching on at least (1 /16)n vertices which is correct on whatever it matches, we formnew matches between vertex i in G1 and vertex j in G2 if the common neighbors of those twovertices under the current partial matching sufficiently large. We then update the partial matchingand repeat this rule until we get a complete matching, which will be shown happens with high",
  "2s2(n + 2n34 ), where (1, ) such that h() =3 log n": "(n2)pqs2 .Denote N(i, j) as the number of common neighbors of i and j under correspondence . Inanother word, N(i, j) is the number of vertex v I such that v is a neighbor of i in A and (v)is a neighbor of j in B. If = , we also write it as N(i, j).The following lemma for SBM is an analogy to Lemma 13 in , which studied the propertyof ErdosRenyi graph.",
  "Proof. If I = , eG(I, Ic) |I||Ic| p+q": "2holds trivially. Let I be an non-empty set with 1 |I| 16n. We denote k as |I|. The number of edges between I and Ic is the summation of k(n k)independent Bernoulli trails. For arbitrary vertex i I and vertex j Ic, if they have the samecommunity label, then the Bernoulli trail between them has mean p. Otherwise,t he Bernoulli trailhas mean q. We assume that there are N1 trails with mean p and N2 trails with mean q, whereN1 +N2 = k(nk). We can write out the distribution as eG(I, Ic) Binom(N1, p)+Binom(N2, q).Under the balanced community event H, n",
  "Now, we are ready to prove Theorem 2.7": "Proof of Theorem 2.7. Firstly, we study the size of common neighbors. For an arbitraryvertex u [n] in G1 and v [n] in G2 such that v is not the true correspondence of u, westudy the number of common neighbors N(u, v) in the intersection graph corresponding to the truepermutation.Case a: These two vertices come from different communities. If v = (u), (u)(v) = 1,then we have N(u, v) Binom(n 2, pqs2). By the multiplicative Chernoff bound (Lemma 3.2) forBinomial distributions, for (1, ), we have",
  "n)": "Case b: These two vertices come from the same community. If v = (u), (u)(v) = 1, thenwe have N(u, v) Binom(|V (v)| 2, p2s2) + Binom(|V (v)|, q2s2) because there are |V (v)| 2vertices left from the same community as u, v and |V (v)| vertices from the different community.Denote n1 as |V (v)| 2 and n2 as |V (v)|, n1 + n2 = n 2.",
  "Secondly, we show that the algorithm is working properly. From (6.4), we assumethat for all v = (u), N(u, v) < p2+q2": "2s2(n + 2n34 ). We want to show = |J in every step ofAlgorithm 2 by induction. This is true for the initialization of as a base case, from our assumptionfor Theorem 2.7. Suppose that this is true for t-th round of the algorithm, then at the (t + 1)-thround, we have that for all v = (u),",
  "2s2(n + 2n34 )": "Therefore, as the (t + 1)-th round, the algorithm will still not add an fake correspondence. Eitherthe algorithm terminates, or a new vertex i is added to J such that (i) = i, which preserves theproperty = |J.Next, we show that Algorithm 2 always ends with J = [n] by contradiction. Assume that thealgorithm terminates with |J| < n, then Jc = . Then, by definition, for al i Jc, N(i, (i)) < p2+q2",
  "log n). Therefore (6.7) holds for": "sufficiently large n.Finally, we analyze the time complexity of Algorithm 2. For each u [n] to be addedinto the seeded set I, we update the number of common neighbors N(i, j) for all i, j I. This steptakes O(degG1(u) degG2(u)), where degG(u) denotes the degree of u in graph G. With probability1 o( 1",
  "Decorated union graph and union graph partition": "The analysis of the first moment involves two chandeliers, while the second moment analysis requiresfour chandeliers. Before delving into the analysis, we introduce the notation for the decorated uniongraph and establish a rule for union graph partition. We adopt some notations and definitionsfrom and further introduce concepts that are particularly useful for correlated stochastic blockmodels. (Decorated Graph) For any graph G, define G as a decorated graph G := (G, DG), whereDG is a decoration mapping from the edge set to a decoration set. Define the edge set ofdecorated graph E( G) := E(G) and the vertex set of decorated graph V ( G) := V (G).",
  "Difference. U \\ U := (U \\ U , DU : DU(e) = DU(e) \\ DU(e))": "(Union Graph Partition) Assume that i is the root of union graph. Consider the graphU with edge (i, a) removed for all neighbors a of i. Let C(i, a) be the connected componenttherein that contains a. Let G(i, a) be the graph union of C(i, a) and the edge (i, a). Then, we divide the set of root neighbors N(i) into the following sets depending on whetherG(i, a) is a tree: NT = {a : (i, a) E(U), G(i, a) is a tree}, NN = {a : (i, a) E( U)} \\ NT .Furthermore, we breakdown NT into two sets depending on whether there are at least Medges 3-decorated: NM = {a NT , |{e E( G(i, a)) : |DU(e)| 3}| M}, NL = NT \\ NM, .",
  "G(i, a),UN := U \\ ( UL UM).(8.2)": "If any of these become an empty set, we define it as the graph consisting of the single vertexi. To provide an intuitive understanding:UN contains those chandelier branches that formcycles in the union graph, while UL and UM are the collection of those chandelier branchesthat do not tangle with other branches from bottom and remain a part of tree rooted at i (orj) in the union graph. As a characteristic of trees, the decorations on edges within UM andUN are monotonically decreasing, meaning that the decoration set of an edge at depth d 1is always a subset of the decoration set of the preceding edge at depth d 1 that connectsto it. For each node v UM that is connected to the root, the connected component G(i, a)should have at list M vertices that are at least 3-decorated. UL is the union of all connectedcomponents remained that are trees. The definition of UL implies that the branches cannotbe fully 3-decorated, otherwise this branch would fall in UM. For every union graph, we can decompose the decorated union graph based on its decorationsets. Specifically, we want to keep track of how many times each vertex appears on the chandeliersthat are rooted at i and the chandeliers that are rooted at j. We present the definition as follows.",
  "where 2eL (resp. 2eM, 2eN) is the counts of 3-decorated edges and two times the 4-decorated edgeson UL (resp. UM, UN)": "We use UL(vL, eL, ) to denote the collection of all possible UL with vL vertices except for i andj, eL counts of special edges as defined, and edges in K11 UL. UM(vM, eM) denotes the familyof all possible UM with vM vertices except for i and j and eL counts of special edges as defined.UN(vN, eN, k) denotes the family of all possible UN with vN vertices except for i and j, eN countsof special edges as defined, and excess k.We further define the weights for of decorated graphs UL, UM, and UN.",
  "We have the following observation with regard to the concepts introduced above:": "(Counting edges) 2(vL + vM + vN + k + 1 + 1{i=j}) + 2(eL + eM + eN) = 4N. This holdsbecause 2(vL + vM + vN + k + 1 + 1{i=j}) counts all the edges on union graph twice and2(eL + eM + eN) makes up for an additional count for 3-decorated edges and two counts for4-decorated edges.",
  "S1,S2=H,T1,T2=IE[AS1BS2AT1BT21H]": "E[AS1BS2AT1BT2] is non-zero if and only if each edge e U is at least 2-decorated.Let Wijdenote the collection of decorated union graph UD, where S1(i), S2(j) = H, T1(i), T2(j) = I forsome H, I T , such that each edge is at least 2-decorated and satisfies S1 = S2 or T1 = T2 orV (S1) V (T1) = {i}.",
  "E[AS1BS2AT1BT21H] = (1 + o(1))e(K11)(sp sq)2N+e(U)Eg U(+, ) | H.(8.14)": "It remains to compute Eg U(+, ) | H. Here, U is fixed and we assume that there are d2 2-decorated edges, d3 3-decorated edges, and d4 4-decorated edges without loss of generality. LetX(2), X(3), and X(4) be the number of in-community edges for 2, 3, and 4-decorated edges on thecomplete graph respectively. In U is a tree, we can apply Lemma 3.8 to determine the distributionof X(2), X(3), and X(4).Generally, U contains cycles. U can be decomposed into a tree with an additional set of edgesconnecting vertices on the tree. We assume that there are Ai i-decorated edges on the tree andBi i-decorated edges in the additional edge set of size e( U) v( U) + 1, for i {2, 3, 4}. We applythe Corollary 3.10 and have that P(X(2,a) = a2, X(3,a) = a3, X(4,a) = a4, X(2,b) = b2, X(3,b) =b3, X(4,b) = b4 | H) (1 + o(1))A2a2A3a3A4a41 2A2+A3+A4 , where X(i,a) is the number of i-decoratedin-community edges on the tree-part of U and X(i,b) is the number of i-decorated in-communityedges among the additional edge set.Ai and Bi are fixed but summed up to di for each U. ai (bi) takes possible values from 0 toAi (Bi), for i . The number of i-decorated in-community edges is ai + bi, and the number ofi-decorated cross-community edges is di ai bi = (Ai ai) + (Bi bi).",
  "Eg U(+, ) | H 2d2+3d3+4d4effd31 d42 2k+1 4Neff 2(eL+eM+eN)22k+1.(8.16)": "The last inequality holds because 1 < 2 and d3+d4 = e(K12)+e(K21)+e(K22) 2(eL+eM +eN).Denote Wij(v, k) as the subset of Wij that contains all the elements that have exactly v verticesexcept for i and j and excess k. By applying the definition of union graph partitions, decoratedgraph weights, and (8.11),",
  "w( UL) aut( UL). This is true because every bulbs are exactly 2-decorated so for the union graph,": "the automorphism number coming from the orbits in this bulb is the same as the weights of thisbulb. However, there can be other orbits outside the bulbs, for example, some bulbs are isomorphicso the vertices on the wires can be in the same orbit, thereby increasing the automorphism number.From Lemma 7 in , we know that",
  "PN(vN, eN, k) nvN (11)vN (11R4(vN + 1)2)k+11{vN2(K+M)(2k+2)}": "Proof. From Lemma 2 in , we know that |NN| 2k + 2 and thus w( UN) R|NN| R4(K+1).Briefly, this is because the excess is k and whenever two branches tangle with each other, theexcess of this graph increases by one.To maximally involving branches in this k + 1 times ofbranch tangles, we never re-tangle a branch after it has tangled with the other branch. In this way,we see that there are at most 2(k + 1) branches in UN. This immediately gives the condition ofvN (2k + 2)(M + K). Define UN(vN, eN, k) as the unlabeled union graph class and H( UN) asthe set of labeled UN for UN UN(vN, eN, k).",
  "Proof of the Proposition": "Proof of Proposition 4.6. Recall that S1 and T1 are rooted on i, S2 and T2 are rooted on j. Theminimum value of k is 2 when the union graph consists of two disconnected trees, S1 T1 andS2 T2. We use the same notation for different parts of the variance as in .",
  "v=0(sp sq)2N+v+k+24Neff 2k+2Pij(v, k)": "Case a: k = 2.We first consider the special case when k = 2. When k = 2, there are twodisjoint trees in the decorated union graph. Then, it must be the case of S1 = T1, S2 = T2, v = 2N,and H = I. Therefore, e(K12) = e(K21) = e(K22) = 0. We have,",
  "M }": "Proof. Define UN(vM, eM) as the collection of unlabeled decorated union graphs and |H( UM)| bethe set of labeled isomorphic members for each UM UN(vM, eM).In UM, there are 2eM edges that are 3 or 4-decorated. Since for each branch connecting to theroot, there are at least M edges on it being at least 3-decorated, |NM(i)| + |NM(j)| 2eM",
  "UM UM(vM,eM)|H( UM)|": "Since UM(i) and UM(j) are two vertex-disjoint trees with vM edges. There are at most vMvMunlabeled non-decorated because we can allocate vM edges to 2 trees in at most vM ways andunder each way the number of rooted unlabeled trees are bounded by vM . There are at most 11vMways of decorating each edge. Therefore, | UM(vM, eM)| vM(11)vM . In addition, the number oflabeled isomorphic members |H( UM)| nvM and the number of 3-decorated edges plus two timesof 4-decorated edges, eM, is upper bounded by 4N 2(v + k + 2). Putting things together,",
  "M nvM (11)vM 1{eM2N(v+k+2)}": "Lastly, because each connected component C(i, a) contains at most 2(K + M) 1 edges, for alla NT (i) (same holds for a NT (j)). This is because there are at most four wires, each fromS1, T1, S2, T2 go through vertex a and every edge is at least 2-decorated. Therefore, vM (K +M) 2eM",
  "PN(vN, k) nvN (11)vN (11R4(vN + 2)2)k+21{vN4(K+M)(k+2)}": "Proof. From the Lemma 9 in we know that |NN(i)|+|NN(j)| 4(k +2). The intuition behindthis bound is that UN can be viewed as a bunch of branches (wires plus bulbs) coming from twodifferent roots i, j tangled together. Whenever two branches intersect with each other, the excessgrow by one. Since the excess of decorated union graph is k and the starting point is two separate trees (with excess 2), there must be k + 2 times of intersection between different branches. Eachtime of intersection involves at most four branches.Thus w( UN) R|NN(i)|+|NN(j)| R4(k+2). As usual, we define UN(vN, k) as the collection ofunlabeled decorated union graphs and |H( UL)| be the set of labeled isomorphic members for eachUL UN(vN, k).",
  "In this part, the total number of unlabeled non-decorated graphs UN with vN +2 vertices and excess": "k is bounded by vN+1(vN +22 )k+1 vN+1(vN + 2)2(k+1). This is because for a unlabeled connectedgraph with vN + 2 vertices, we can construct a spanning tree with vN + 1 vertices first and thanadd additional k + 1 edges connecting some of the vN + 2 vertices. We can also bound the number of unlabeled UN as vNvN (vN +22 )k+2, which is constructing two trees rooted at i and j, with a totalof vN ways of vertex number allocation, and then adding an additional k + 2 edges. The latterbound is looser. Also, there are at most 11vN+k+2 ways of decoration. Thus,",
  "We perform case studies for E[ij1H] based on the structure of S, T as a union graph and thenlater sum each case up": "(a) S = T, that is, all edges appear in pairs (this case is only possible for i = j).Thereare (1 + o(1))nN/aut(H) labeled union graphs of S1 and T1 satisfying this condition. In this case,every edge is 2-decorated and it no longer matters whether gives a correct output or not, as wecan show the following upper bound.",
  "= (1 + o(1))|T |nN(2eff + 2)N,": "where is the number of in-community edges out of the N edges in S, c+ is the number of in-community edges that are centralized incorrectly, c is the number of cross-community edges thatare centralized incorrectly, and := |p q|. (i) The first equality holds by definition and countingcases.(ii) The second inequality holds because there are Nc+(Nc) in(cross)-community edgescentralized correctly, each of which contributes the same as E[AeBe | ] = (1 + o(1))+2+(2) (Lemma 3.13). For the remaining edges, N+ Nc+ (N N+ Nc) of them has E[AAe BBe|, ] = (1 + o(1))(+2+) + E[AAe| , ]E[BBe| , ] (1 + o(1))(+2+ + 2). (iii) The thirdinequality holds because 2 > 0, Lemma 3.7 gives the distribution of , and = (1+( log n",
  "aut(H)P(E)2N,(10.1)": "where E denotes the event { : eE(S) E[AAe ] eE(T) E[BBe ] = (e(S)+e(T))} H, that is,every edge is centralized correctly and H happens. This inequality is true because conditioned onH and being correct, E[AAe| , ]1H = o(nD+(a,b,s,)), the upper bound of the probabilitythat one vertex on this edge being labeled incorrectly.We further denote E as {A : eE(S) E[AAe ] = (e(S))} H. It is obvious that P(E) P(E). Then, we need to upper bound the probability of A giving incorrect centralization for alledges in S T.We observe that there are only two situations, that is, no vertices in S that has a neighbor withthe same label correctness as itself. See for an illustration. We denote those two possibleoutcomes constraint on S T as 1 and 2. P(E) = P({A = 1} H) + P({A = 2} H).",
  "ssss": ": Left: One possible labeling such that all edges are centralized incorrectly, with the coloredvertices indicating those that are labeled incorrectly and the black vertices indicating those that arelabeled correctly. Right: Another possible labeling such that all edges are centralized incorrectly. By the label correctness, we separate V (S) into two disjoint sets: V (S)c for the correctly labeledvertices and V (S)ic for the incorrectly labeled vertices. The deterministic relationship between 1and 2 is: V (S)1ic = V (S)2c . without loss of generality, we assume |V (S)1c | > |V (S)1ic |. Observethat event {A = 1} (resp. {A = 2}) is equivalent as saying the set of vertices on odd (resp.even) levels are labeled incorrectly (falling in the bad vertex set I as defined in ).Denote pa,b,s,,,V := nV D+(a,b,s,) + n(1o(1)) log n. We can apply Lemma 3.6,",
  "We observe the following:P(E) nD+(a,b,s,)(2M/2D)": "This inequality holds because there are 2M edges centralized incorrectly (required from event E)in S and T and each incorrect labeling of a vertex can lead to incorrect centralization on at mostD edges. Therefore, at least 2M/2D vertices should be wrongly labeled for E to happen.Substitute P(E) into (10.2). Assuming that D = o(log n",
  "V2": "(a) Analyzing V2.We first give the upper bound of the latter part. When analyzing with correctcentralization, we ignore this part as it is non-negative in the correct centralization case. However,in this case, it is possible to be negative because there can be odd number of edges occurring onceand also being incorrectly centralized.After factorizing V2,",
  "we can see that V2 0, and thus we have Var[ij1H] V1 for j = (i)": "(b) Analyzing V11.The main challenge here is that we do not have the condition that everyedge occurs at least twice in the union graph as in the analysis of Regime I. However, we can putunion graphs into two categories based on whether every edge is at least 2-decorated or not. Wekeep the notation of Wij as the collection of decorated union graphs U that are at least 2-decoratedand we decompose (11.1) as follows",
  "D (sp sq)v+k+12Ne(K11)E[g U(+, ) | H]": "It remains to calculate E[g U(+, ) | H].Similar as in the calculation in , where we only consider U being at least 2-decorated.Here, we need to generalize it into the case when U has 1-decorated edges.U can be decom-posed into a tree with an additional set of edges connecting vertices on the tree.We assumethat there are Ai i-decorated edges on the tree and Bi i-decorated edges in the additional edgeset of size e( U) v( U) + 1, for i . We apply the Corollary 3.10 and have that P(X(1,a) =a1, X(2,a) = a2, X(3,a) = a3, X(4,a) = a4, X(1,b) = b1, X(2,b) = b2, X(3,b) = b3, X(4,b) = b4 | H) (1 + o(1))A1a1A2a2A3a3A4a41 2A1+A2+A3+A4 , where X(i,a) is the number of i-decorated in-communityedges on the tree-part of U and X(i,b) is the number of i-decorated in-community edges among theadditional edge set.Ai and Bi are fixed but summed up to di for each U. ai (bi) takes possible values from 0 toAi (Bi), for i . The number of i-decorated in-community edges is ai + bi, and the number ofi-decorated cross-community edges is di ai bi = (Ai ai) + (Bi bi).",
  "Neff e(K12)+e(K21)+e(K22)22k+1.(11.3)": "After plugging the upper bound on cross-moments to the ratio, it remains to bound the numberof different union graph structures and their corresponding weights. In parallel to Wij, we defineSij as the collection of decorated union graphs that have at least one 1-decorated edge. Sij(v, k)denotes those with v + 1 + 1j=i vertices and excess k.",
  "(1 + o(1))n2N2N|T |2nzD+(a,b,s,)/D": "(a) Case k = 2.We first consider the special case when k = 2. When k = 2, there aretwo disjoint trees in the decorated union graph and all edges are decorated by a subset of either{S1, T1} or {S2, T2}. Then, e(K11) = e(K12) = e(K21) = e(K22) = 0. Also v 2N,",
  "(e(K12 K22 UL) + e(K21 K22 UL)). The total number of edges onS1, T1, S2 and T2 involved in UL is (2(vL +eL)z) and thus the total number of bulbs on S1, T1, S2and T2 involved in UL is b := 2(vL+eL)z": "K+M< 4L. Those b bulbs can be partly or fully overlapped(namely, tangled) with another stay on their own. From the definition of UL (8.2), it is impossibleto have three or more bulbs tangling with each other. If two bulbs are tangling with each other, weput them into a pair. If a bunch of bulbs are all not tangling with any other bulbs, we pair themup arbitrarily. We denote t1 as the number of pairs of bulbs that have decorations being a subsetof {S1, S2} or {T1, T2}. For all 2-decorated edges among these pairs, they are in K11. Since UL hasat most z 1-decorated edges, we have",
  "t1K z/2.(11.8)": "Next, we introduce three types of bulbs. The first type is called effective non-isomorphic bulbs,which is a selection of bulbs that are not isomorphic to each other and always pair with a bulbthat are not of the same type. The selection is not unique and we take the largest possible setof bulbs satisfying those rules as the set of effective non-isomorphic bulbs.Fixed the effectivebulb set, for bulbs that are isomorphic to those effective non-isomorphic bulbs, we name them asshadow effective bulbs. For the remaining bulbs, we name them as non-effective bulbs. We have thefollowing Claim 11.4:t12 a L + t1",
  ".(11.9)": "From definition, there is at most one non-effective bulb and at most one effective non-isomorphicbulb in each pair of bulbs, while two shadow bulbs can pair up.We call those effective non-isomorphic bulbs as effective because when enumerating throughthe chandelier structures, we let them having the priority of taking any possible structure from Jand serving the base of that pair. Shadow effective bulbs are named so because they mirror thestructure of effective non-isomorphic bulbs and thus will not increase the union graph richness toomuch. For non-effective bulbs, we let them take any possible structures with the constrain thatthere are at most z 1-decorated edges in UL.We denote the number of effective non-isomorphic bulbs as a. For all pairs, we upper boundthe number of different non-isomorphic tangled bulbs as following combinatorial factor|J |a",
  "(4N)z2 ,": "where|J |acomes from the structure of a effective non-isomorphic bulbs,bais the upper bound ofchoosing a effective non-isomorphic bulbs from b bulbs,2Nz/2is the upper bound on the selectionof which edges on effective non-isomorphic bulbs and shadow effective bulbs are overlapped asthere are at most 2K (< 2N) 2-decorated edges on bulbs if all bulbs are perfectly overlappingwith one another, and (4N)z2 bounds the placement of those remaining 1-decorated edges from the non-effective bulbs as each of them has at most 4N possible vertices to attach to on the uniongraph.Since wires cannot tangle with bulbs (otherwise, it is not a tree), we bound the possible struc-tures separately. There can be at most 4 wires tangling with each other, from top to bottom. Weapply a very loose bound even without using this fact, which is (b1)!Mb1. This is because thereare at most b wires and we determine the structure of wires on the union graph one by one. Whenthe t-th wire comes in, it can determine which of the t 1 wires to tangle with and the length ofoverlap, from 0 to M.Putting together (11.8) and (11.9) with the combinatorial observations, we have",
  ".(11.10)": "In the second inequality, we loose the upper bound of t1 from a to 2L and change the or-der of summation.In the third inequality, we bound the summation over a and b.Lastly,2Lt1=0(|J |2K)t12 L(|J |2K)L = L|T |2N.Plugging (11.10) back to (11.7), after a summation over , we complete the proof.",
  "w( UL) aut( UL)(2K)z": "Proof. Denote all bulbs contained in UL as B1, B2, . . . , Bw. (1) Some of them can be fully overlappedto form a 2-decorated bulbs in the union graph. (2) Some of them can be partly overlapped. (3)And the remaining of them are fully 1-decorated. There cannot be three or more bulbs overlappingwith each other thanks to the definition of UL (9.2).Each bulb Bi contributes to the w( UL) by aut(Bi) independently from definition (9.3) and (8.8).For any vertex on the bulbs, it will not be at the same orbit as any vertex on the wire, so studyingthe automorphism of the overlapped bulbs gives a lower bound on the automorphism of the wholedecorated graph. Since each bulb occurs in at most one overlapped bulb, to prove the claim, itsuffices to examine the relationship between weights and automorphism for each of the three casesaforementioned.For i, j [w], if bulbs Bi is partly overlapping with Bj. From Corollary 3.12,",
  "|T |2N )": "(b) Case k > 2.In general, we define UL, UM, and UN partition the same as (9.1) and (9.2).We also define the weights of each part the same as (9.3), (9.4), and (9.5). We define PL(vL, z) =UUL(vL,z) w( U). The definition of PM(vM) and PN(vN, k) follow. All union graph class should",
  "D,": "where S(v 2N, H, t1, t2) collects all the possible decorated union graph that have S1, S2 = H,T1, T2 = I for some I T such that aut(I) < aut(H), and S1 (resp. S2) differ in t1 (resp. t2) edgeswith T1 (resp. T2).Next, we bound |S(v 2N, H, t1, t2)| by the following way: First, enumerate through allS1, S2 = H on the complete graph with all possible structure, this givesn2N",
  "z": "We show the upper bound for UL part in Lemma 12.2. The upper bound for PM and PNtrivially follows from Lemma 9.2 and Lemma 9.3 as they do not use any assumption on edges areall at least 2-decorated, except for the number 11, the possible ways of decoration. So, we change11 to 15 and then every thing follows. When z = 0, eM as defined before in an arbitrary UM hasmaximum value 2N (v + k + 2) z/2 (same holds for eN, eL but we do not need to use them inour bound). In summary,",
  "nvLw( UL)aut( UL) (2K)znvL| UL(vL, z)|.(12.3)": "Recall that UL consists of two disjoint trees, one rooted at i and the other one rooted at j. Weconsider the branches of chandeliers without overlapping with each other.Then, we specify two categories of branches. A branch is called an invader if it is rooted at i(resp. j) but in UL(j) (resp.UL(i)). A branch that is not an invader is called a residence. Weobserve that there are at most L + z K+M + 4 effective non-isomorphic bulbs among residents(defined in , the proof of Proposition 4.5) because of the followings: 1) If branches areperfectly matched and overlapped, there are at most L pairs of them rooted at i and another L pairsrooted at j. We define effective non-isomorphic bulbs the same as in Lemma 11.2. Here we haveL effective non-isomorphic bulbs because S1 = S2, T1 = T2. 2) z K+M is the maximum number offully 1-decorated branches in allowed UL, and 3) There are at most 4 invading branches, each ofwhich can at most fully overlapping with one resident bulb, due to the fact that there cannot betwo branches on the same chandelier passing through the same vertex.The remaining is to bound |UL(vL, z)|. We observe that there are at most 4(K + M 1) edgesfrom invading branches, which might be attaching to at most 4(K +M 1) resident branches. Thisis because an invader rooted at j may only have its bulb overlapping with UL(i). In this case, oneinvader can overlap with multiple resident branches in UL(i).",
  "K+M +4is the structures of all resident branches,2Nz/2is the upper bound of choosing": "which edges to be not overlapped on bulbs assume starting from perfect overlapped bulbs, (4N)z2is the bound for placing the remaining z/2 1-decorated vertices, (4LM)4L is a trivial bound onhow resident branches have their wires tangling with each other, ()4(K+M1) is the structure ofinvading edges, and lastly 2(K+M1)(4L)! bounds the different interactions between invading edgesand the resident branches. To understand the quantity 2(K+M1)(4L)!, this comes from the factthat each invading edge connected to the root can choose one out of at most 4L resident branchto attach, and that the following invading edges can choose to stay overlapping with the currentresident branch or leave.Plugging (12.4) back into (12.3) with basic binomial bounds and |J | K, we complete theproof.",
  "w( UL) aut( UL)(2K)z.(12.5)": "Proof. Denote all bulbs contained in UL(i) (resp., j) and are attached to wires rooted at i (resp., j)as B1, B2, . . . , Bw. Denote all bulbs contained in UL(i) (resp., j) and are attached to wires rootedat j (resp., i) as T1, T2, . . . , Tm. For those branches rooted at i (resp., j) but connect to j (resp., i),although they can have their bulbs in UL(j) (resp., UL(i)), they contribute to the weight of non-treepart UN from definitions (9.3) and (9.5).For an arbitrary bulb Bt in UL(i) UL(j), we discuss the following three cases. Without loss ofgenerality, we assume that Bt is attached to a wire rooted at i.Firstly, if there exists another bulb Br such that Br and Bt be two bulbs with wires rooted bothat i and overlapping with each other. Then, from Corollary 3.12, we have that",
  "overlapping with Bt, then": "aut(Bt)aut(Tr) aut(Bt Tr)(2K)|E(B4)E(Tr)| from Corollary 3.12.Note that in this case, full overlap is not possible because this invader branch spends at least oneedge connecting from j to i. The third case can be considered as a generalized version of the firstcase.By a product over all overlapping bulbs, we have w( UL) aut( UL)(2K)z because the totalnumber of edges in the difference sets of overlapping bulbs are upper bounded by z, the number of 1-decorated edges, and the automorphism number of UL is greater than the product of automorphismnumber of all bulbs.",
  "Emmanuel Abbe, Jianqing Fan, Kaizheng Wang, and Yiqiao Zhong. Entrywise eigenvectoranalysis of random matrices with low expected rank. The Annals of Statistics, 48(3):14521474,2020": "Emmanuel Abbe and Colin Sandon. Community detection in general stochastic block mod-els: Fundamental limits and efficient algorithms for recovery.In 2015 IEEE 56th AnnualSymposium on Foundations of Computer Science (FOCS), pages 670688. IEEE, 2015. Boaz Barak, Chi-Ning Chou, Zhixian Lei, Tselil Schramm, and Yueqi Sheng. (Nearly) EfficientAlgorithms for the Graph Matching Problem on Correlated Random Graphs. In Advances inNeural Information Processing Systems (NeurIPS), volume 32, pages 91909198, 2019.",
  "Terry Beyer and Sandra Mitchell Hedetniemi. Constant Time Generation of Rooted Trees.SIAM Journal on Computing, 9(4):706712, 1980": "Guillaume Braun and Masashi Sugiyama. Vec-sbm: Optimal community detection with vec-torial edges covariates. In Proceedings of The 27th International Conference on Artificial In-telligence and Statistics (AISTATS), volume 238 of Proceedings of Machine Learning Research(PMLR), pages 532540, 2024. Karl Bringmann, Tobias Friedrich, and Anton Krohmer. De-anonymization of heterogeneousrandom graphs in quasilinear time. In Proceedings of the 22nd Annual European Symposiumon Algorithms (ESA), pages 197208, 2014.",
  "Jian Ding, Zongming Ma, Yihong Wu, and Jiaming Xu. Efficient random graph matching viadegree profiles. Probability Theory and Related Fields, 179(1):29115, 2021": "Zhou Fan, Cheng Mao, Yihong Wu, and Jiaming Xu. Spectral graph matching and regularizedquadratic relaxations: Algorithm and theory. In Proceedings of the 37th International Confer-ence on Machine Learning (ICML), volume 119 of Proceedings of Machine Learning Research(PMLR), pages 29852995, 2020. Luca Ganassali and Laurent Massoulie. From tree matching to sparse graph alignment. InProceedings of the 33rd Conference on Learning Theory (COLT), volume 125 of Proceedingsof Machine Learning Research (PMLR), pages 16331665, 2020. Luca Ganassali, Laurent Massoulie, and Marc Lelarge. Impossibility of Partial Recovery inthe Graph Alignment Problem. In Proceedings of the 34th Conference on Learning Theory(COLT), volume 134 of Proceedings of Machine Learning Research (PMLR), pages 20802102,2021. Julia Gaudio, Miklos Z. Racz, and Anirudh Sridhar.Exact community recovery in corre-lated stochastic block models. In Proceedings of Thirty Fifth Conference on Learning Theory(COLT), volume 178 of Proceedings of Machine Learning Research, pages 21832241. PMLR,0205 Jul 2022.",
  "Zongming Ma and Sagnik Nandy. Community detection with contextual multilayer networks.IEEE Transactions on Information Theory, 69(5):32033239, 2023": "Konstantin Makarychev, Rajsekar Manokaran, and Maxim Sviridenko. Maximum quadraticassignment problem: Reduction from maximum label cover and lp-based approximation al-gorithm. In International Colloquium on Automata, Languages, and Programming (ICALP),pages 594604. Springer, 2010. Cheng Mao, Mark Rudelson, and Konstantin Tikhomirov. Random Graph Matching with Im-proved Noise Robustness. In Proceedings of the 34th Conference on Learning Theory (COLT),volume 134 of Proceedings of Machine Learning Research (PMLR), pages 32963329, 2021.",
  "Arvind Narayanan and Vitaly Shmatikov. De-anonymizing social networks. In Proceedings ofthe 30th IEEE Symposium on Security and Privacy, pages 173187. IEEE Computer Society,2009": "Ryan ODonnell, John Wright, Chenggang Wu, and Yuan Zhou. Hardness of robust graph iso-morphism, lasserre gaps, and asymmetry of random graphs. In Proceedings of the Twenty-FifthAnnual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 16591677. SIAM,2014. Christoffer Olsson and Stephan Wagner. Automorphisms of Random Trees. In 33rd Interna-tional Conference on Probabilistic, Combinatorial and Asymptotic Methods for the Analysisof Algorithms (AofA 2022), volume 225 of Leibniz International Proceedings in Informatics(LIPIcs), pages 16:116:16. Schloss Dagstuhl-Leibniz-Zentrum fur Informatik, 2022. Efe Onaran, Siddharth Garg, and Elza Erkip. Optimal de-anonymization in random graphswith community structure. In 2016 50th Asilomar Conference on Signals, Systems and Com-puters, pages 709713. IEEE, 2016.",
  "Richard Otter. The Number of Trees. Annals of Mathematics, 49(3):583599, 1948": "Pedram Pedarsani and Matthias Grossglauser. On the privacy of anonymized networks. InProceedings of the 17th ACM SIGKDD International Conference on Knowledge Discovery andData Mining (KDD), pages 12351243, 2011. Miklos Z. Racz and Anirudh Sridhar.Correlated Stochastic Block Models: Exact GraphMatching with Applications to Recovering Communities. In Advances in Neural InformationProcessing Systems (NeurIPS), volume 34, pages 2225922273, 2021.",
  "Miklos Z. Racz and Jifan Zhang. Harnessing Multiple Correlated Networks for Exact Commu-nity Recovery. In Advances in Neural Information Processing Systems (NeurIPS), volume 38,2024": "Rohit Singh, Jinbo Xu, and Bonnie Berger.Global alignment of multiple protein interac-tion networks with application to functional orthology detection. Proceedings of the NationalAcademy of Sciences, 105(35):1276312768, 2008. Toni Vall`es-Catal`a, Francesco A. Massucci, Roger Guimer`a, and Marta Sales-Pardo. MultilayerStochastic Block Models Reveal the Multilayer Structure of Complex Networks.PhysicalReview X, 6(1):011036, 2016. Haoyu Wang, Yihong Wu, Jiaming Xu, and Israel Yolou. Random Graph Matching in Ge-ometric Models: the Case of Complete Graphs. In Proceedings of the 35th Conference onLearning Theory (COLT), volume 178 of Proceedings of Machine Learning Research (PMLR),pages 34413488, 2022. Ziao Wang, Weina Wang, and Lele Wang. Efficient Algorithms for Attributed Graph Alignmentwith Vanishing Edge Correlation. In Proceedings of the 37th Conference on Learning Theory(COLT), volume 247 of Proceedings of Machine Learning Research (PMLR), pages 48894890,2024."
}